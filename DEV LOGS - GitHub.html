<!DOCTYPE html>
<html>
<head>
<title>DEV LOGS - GitHub.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="data-structures--algorithms-learning-path">Data Structures &amp; Algorithms Learning Path</h1>
<h2 id="%F0%9F%8E%AF-complete-basic-to-medium-level-dsa-resource">🎯 Complete Basic to Medium-Level DSA Resource</h2>
<p>Welcome to your comprehensive journey through Data Structures and Algorithms! This learning resource is designed to take you from beginner to intermediate level with hands-on examples, practical implementations, and real-world applications.</p>
<hr>
<h2 id="%F0%9F%93%9A-course-structure">📚 Course Structure</h2>
<h3 id="fundamental-data-structures"><strong>Fundamental Data Structures</strong></h3>
<ol>
<li><strong><a href="01-arrays-strings.md">Arrays &amp; Strings</a></strong> - Foundation of data storage and manipulation</li>
<li><strong><a href="02-linked-lists.md">Linked Lists</a></strong> - Dynamic data structures and pointer manipulation</li>
<li><strong><a href="03-stacks-queues.md">Stacks &amp; Queues</a></strong> - LIFO and FIFO data structures</li>
<li><strong><a href="04-hash-tables-maps.md">Hash Tables/Maps</a></strong> - Fast lookups and key-value storage</li>
<li><strong><a href="05-trees.md">Trees</a></strong> - Hierarchical data structures and binary search trees</li>
</ol>
<h3 id="essential-algorithms"><strong>Essential Algorithms</strong></h3>
<ol start="6">
<li><strong><a href="06-recursion-basics.md">Recursion Basics</a></strong> - Fundamental recursive thinking and implementation</li>
<li><strong><a href="07-sorting-algorithms.md">Sorting Algorithms</a></strong> - Comparison and non-comparison sorting techniques</li>
<li><strong><a href="08-searching-algorithms.md">Searching Algorithms</a></strong> - Linear, binary, and advanced search methods</li>
<li><strong><a href="09-tree-traversals.md">Tree Traversals</a></strong> - DFS, BFS, and specialized tree traversal techniques</li>
<li><strong><a href="10-basic-graph-theory.md">Basic Graph Theory</a></strong> - Graph representations and fundamental algorithms</li>
</ol>
<h3 id="medium-complexity-topics"><strong>Medium Complexity Topics</strong></h3>
<ol start="11">
<li><strong><a href="11-two-pointers.md">Two Pointers Technique</a></strong> - Efficient array and string manipulation</li>
<li><strong><a href="12-sliding-window.md">Sliding Window</a></strong> - Optimizing subarray and substring problems</li>
<li><strong><a href="13-basic-dynamic-programming.md">Basic Dynamic Programming</a></strong> - Optimization through memoization</li>
<li><strong><a href="14-backtracking.md">Backtracking</a></strong> - Systematic solution space exploration</li>
<li><strong><a href="15-simple-greedy-algorithms.md">Simple Greedy Algorithms</a></strong> - Local optimization strategies</li>
</ol>
<h3 id="capstone-project"><strong>Capstone Project</strong></h3>
<ol start="16">
<li><strong><a href="16-mini-project-task-management-system.md">Mini-Project: Task Management System</a></strong> - Comprehensive application combining all concepts</li>
</ol>
<hr>
<h2 id="%F0%9F%8E%93-learning-objectives">🎓 Learning Objectives</h2>
<p>By the end of this course, you will:</p>
<ul>
<li>✅ <strong>Master fundamental data structures</strong> and their optimal use cases</li>
<li>✅ <strong>Implement essential algorithms</strong> in both JavaScript and C++</li>
<li>✅ <strong>Analyze time and space complexity</strong> for performance optimization</li>
<li>✅ <strong>Solve medium-level coding problems</strong> with confidence</li>
<li>✅ <strong>Apply DSA concepts</strong> to real-world software development</li>
<li>✅ <strong>Prepare effectively</strong> for technical interviews</li>
<li>✅ <strong>Build a comprehensive project</strong> showcasing your skills</li>
</ul>
<hr>
<h2 id="%F0%9F%9B%A0%EF%B8%8F-what-youll-learn">🛠️ What You'll Learn</h2>
<h3 id="programming-languages"><strong>Programming Languages</strong></h3>
<ul>
<li><strong>JavaScript</strong>: Modern ES6+ syntax with practical examples</li>
<li><strong>C++</strong>: Efficient implementations with STL usage</li>
<li><strong>Comparative Analysis</strong>: Understanding language-specific optimizations</li>
</ul>
<h3 id="core-concepts"><strong>Core Concepts</strong></h3>
<ul>
<li><strong>Time Complexity</strong>: Big O notation and performance analysis</li>
<li><strong>Space Complexity</strong>: Memory usage optimization</li>
<li><strong>Algorithm Design</strong>: Problem-solving strategies and patterns</li>
<li><strong>Data Structure Selection</strong>: Choosing the right tool for the job</li>
<li><strong>Code Optimization</strong>: Writing efficient and maintainable code</li>
</ul>
<h3 id="practical-skills"><strong>Practical Skills</strong></h3>
<ul>
<li><strong>Problem Decomposition</strong>: Breaking complex problems into manageable parts</li>
<li><strong>Pattern Recognition</strong>: Identifying common algorithmic patterns</li>
<li><strong>Testing Strategies</strong>: Validating implementations with edge cases</li>
<li><strong>Performance Benchmarking</strong>: Measuring and comparing algorithm efficiency</li>
<li><strong>System Design</strong>: Applying DSA concepts to larger systems</li>
</ul>
<hr>
<h2 id="%F0%9F%93%96-chapter-format">📖 Chapter Format</h2>
<p>Each chapter follows a consistent, comprehensive format:</p>
<h3 id="%F0%9F%93%8B-structure"><strong>📋 Structure</strong></h3>
<ol>
<li><strong>Clear Explanations</strong> - Conceptual understanding with visual aids</li>
<li><strong>Use Cases</strong> - Real-world applications and when to use each concept</li>
<li><strong>Step-by-Step Examples</strong> - Detailed walkthroughs with illustrations</li>
<li><strong>Code Implementations</strong> - Complete JavaScript and C++ examples</li>
<li><strong>Performance Analysis</strong> - Time/space complexity with detailed explanations</li>
<li><strong>Common Pitfalls</strong> - Mistakes to avoid and debugging tips</li>
<li><strong>Practice Problems</strong> - Graduated difficulty with detailed solutions</li>
<li><strong>Interview Tips</strong> - Common questions and optimal approaches</li>
</ol>
<h3 id="%F0%9F%92%BB-code-features"><strong>💻 Code Features</strong></h3>
<ul>
<li><strong>Comprehensive Comments</strong> - Every line explained for learning</li>
<li><strong>Multiple Implementations</strong> - Different approaches for comparison</li>
<li><strong>Performance Testing</strong> - Benchmarking code included</li>
<li><strong>Error Handling</strong> - Robust implementations with edge case handling</li>
<li><strong>Best Practices</strong> - Industry-standard coding conventions</li>
</ul>
<hr>
<h2 id="%F0%9F%8E%AF-target-audience">🎯 Target Audience</h2>
<h3 id="perfect-for"><strong>Perfect for:</strong></h3>
<ul>
<li><strong>Beginner Programmers</strong> looking to build strong foundations</li>
<li><strong>Self-taught Developers</strong> wanting structured DSA knowledge</li>
<li><strong>Computer Science Students</strong> seeking practical implementations</li>
<li><strong>Interview Candidates</strong> preparing for technical assessments</li>
<li><strong>Professional Developers</strong> refreshing algorithmic knowledge</li>
</ul>
<h3 id="prerequisites"><strong>Prerequisites:</strong></h3>
<ul>
<li>Basic programming knowledge in any language</li>
<li>Understanding of variables, loops, and functions</li>
<li>Familiarity with object-oriented programming concepts</li>
<li>Willingness to practice and experiment with code</li>
</ul>
<hr>
<h2 id="%F0%9F%93%88-learning-path-recommendations">📈 Learning Path Recommendations</h2>
<h3 id="%F0%9F%9A%80-fast-track-4-6-weeks"><strong>🚀 Fast Track (4-6 weeks)</strong></h3>
<p><strong>For experienced programmers or intensive study:</strong></p>
<ul>
<li>Week 1: Chapters 1-4 (Fundamental Data Structures)</li>
<li>Week 2: Chapters 5-7 (Trees, Recursion, Sorting)</li>
<li>Week 3: Chapters 8-10 (Searching, Traversals, Graphs)</li>
<li>Week 4: Chapters 11-13 (Two Pointers, Sliding Window, DP)</li>
<li>Week 5: Chapters 14-15 (Backtracking, Greedy)</li>
<li>Week 6: Chapter 16 (Mini-Project)</li>
</ul>
<h3 id="%F0%9F%8E%AF-standard-track-8-10-weeks"><strong>🎯 Standard Track (8-10 weeks)</strong></h3>
<p><strong>For balanced learning with practice time:</strong></p>
<ul>
<li>Weeks 1-2: Chapters 1-3 (Arrays, Strings, Linked Lists, Stacks, Queues)</li>
<li>Weeks 3-4: Chapters 4-6 (Hash Tables, Trees, Recursion)</li>
<li>Weeks 5-6: Chapters 7-9 (Sorting, Searching, Traversals)</li>
<li>Weeks 7-8: Chapters 10-12 (Graphs, Two Pointers, Sliding Window)</li>
<li>Weeks 9-10: Chapters 13-16 (DP, Backtracking, Greedy, Project)</li>
</ul>
<h3 id="%F0%9F%8C%B1-beginner-track-12-16-weeks"><strong>🌱 Beginner Track (12-16 weeks)</strong></h3>
<p><strong>For thorough understanding and mastery:</strong></p>
<ul>
<li>Weeks 1-3: Chapters 1-2 (Arrays, Strings, Linked Lists)</li>
<li>Weeks 4-6: Chapters 3-4 (Stacks, Queues, Hash Tables)</li>
<li>Weeks 7-9: Chapters 5-6 (Trees, Recursion)</li>
<li>Weeks 10-12: Chapters 7-9 (Sorting, Searching, Traversals)</li>
<li>Weeks 13-14: Chapters 10-12 (Graphs, Two Pointers, Sliding Window)</li>
<li>Weeks 15-16: Chapters 13-16 (DP, Backtracking, Greedy, Project)</li>
</ul>
<hr>
<h2 id="%F0%9F%8F%86-progress-tracking">🏆 Progress Tracking</h2>
<h3 id="completion-checklist"><strong>Completion Checklist</strong></h3>
<h4 id="fundamental-data-structures"><strong>Fundamental Data Structures</strong></h4>
<ul>
<li><input type="checkbox" id="checkbox0"><label for="checkbox0"></label><strong>Arrays &amp; Strings</strong> - Master array manipulation and string algorithms</li>
<li><input type="checkbox" id="checkbox1"><label for="checkbox1"></label><strong>Linked Lists</strong> - Implement singly and doubly linked lists</li>
<li><input type="checkbox" id="checkbox2"><label for="checkbox2"></label><strong>Stacks &amp; Queues</strong> - Build LIFO and FIFO data structures</li>
<li><input type="checkbox" id="checkbox3"><label for="checkbox3"></label><strong>Hash Tables</strong> - Create efficient key-value storage systems</li>
<li><input type="checkbox" id="checkbox4"><label for="checkbox4"></label><strong>Trees</strong> - Construct and manipulate binary trees and BSTs</li>
</ul>
<h4 id="essential-algorithms"><strong>Essential Algorithms</strong></h4>
<ul>
<li><input type="checkbox" id="checkbox5"><label for="checkbox5"></label><strong>Recursion</strong> - Master recursive thinking and implementation</li>
<li><input type="checkbox" id="checkbox6"><label for="checkbox6"></label><strong>Sorting</strong> - Implement and compare various sorting algorithms</li>
<li><input type="checkbox" id="checkbox7"><label for="checkbox7"></label><strong>Searching</strong> - Build efficient search algorithms</li>
<li><input type="checkbox" id="checkbox8"><label for="checkbox8"></label><strong>Tree Traversals</strong> - Master all traversal techniques</li>
<li><input type="checkbox" id="checkbox9"><label for="checkbox9"></label><strong>Graph Basics</strong> - Understand graph representations and algorithms</li>
</ul>
<h4 id="medium-complexity"><strong>Medium Complexity</strong></h4>
<ul>
<li><input type="checkbox" id="checkbox10"><label for="checkbox10"></label><strong>Two Pointers</strong> - Optimize array and string problems</li>
<li><input type="checkbox" id="checkbox11"><label for="checkbox11"></label><strong>Sliding Window</strong> - Solve subarray optimization problems</li>
<li><input type="checkbox" id="checkbox12"><label for="checkbox12"></label><strong>Dynamic Programming</strong> - Master memoization and optimization</li>
<li><input type="checkbox" id="checkbox13"><label for="checkbox13"></label><strong>Backtracking</strong> - Implement constraint satisfaction algorithms</li>
<li><input type="checkbox" id="checkbox14"><label for="checkbox14"></label><strong>Greedy Algorithms</strong> - Apply local optimization strategies</li>
</ul>
<h4 id="capstone-project"><strong>Capstone Project</strong></h4>
<ul>
<li><input type="checkbox" id="checkbox15"><label for="checkbox15"></label><strong>Task Management System</strong> - Build comprehensive application</li>
<li><input type="checkbox" id="checkbox16"><label for="checkbox16"></label><strong>Performance Analysis</strong> - Benchmark and optimize implementations</li>
<li><input type="checkbox" id="checkbox17"><label for="checkbox17"></label><strong>Testing Suite</strong> - Create comprehensive test coverage</li>
<li><input type="checkbox" id="checkbox18"><label for="checkbox18"></label><strong>Documentation</strong> - Write clear technical documentation</li>
</ul>
<hr>
<h2 id="%F0%9F%92%A1-study-tips">💡 Study Tips</h2>
<h3 id="%F0%9F%93%9D-effective-learning-strategies"><strong>📝 Effective Learning Strategies</strong></h3>
<ol>
<li><strong>Code Along</strong> - Don't just read, implement every example</li>
<li><strong>Modify Examples</strong> - Change parameters and see what happens</li>
<li><strong>Solve Practice Problems</strong> - Apply concepts immediately</li>
<li><strong>Explain to Others</strong> - Teaching reinforces understanding</li>
<li><strong>Build Projects</strong> - Create your own applications using learned concepts</li>
</ol>
<h3 id="%F0%9F%94%A7-debugging-and-problem-solving"><strong>🔧 Debugging and Problem-Solving</strong></h3>
<ol>
<li><strong>Start Simple</strong> - Begin with basic cases before complex scenarios</li>
<li><strong>Use Debuggers</strong> - Step through code to understand execution</li>
<li><strong>Draw Diagrams</strong> - Visualize data structures and algorithm flow</li>
<li><strong>Test Edge Cases</strong> - Always consider boundary conditions</li>
<li><strong>Optimize Later</strong> - Get it working first, then make it efficient</li>
</ol>
<h3 id="%F0%9F%93%8A-performance-analysis"><strong>📊 Performance Analysis</strong></h3>
<ol>
<li><strong>Measure Everything</strong> - Use timing functions to benchmark code</li>
<li><strong>Compare Approaches</strong> - Implement multiple solutions and compare</li>
<li><strong>Understand Trade-offs</strong> - Time vs. space complexity decisions</li>
<li><strong>Profile Memory Usage</strong> - Monitor memory consumption patterns</li>
<li><strong>Scale Testing</strong> - Test with increasingly large datasets</li>
</ol>
<hr>
<h2 id="%F0%9F%8E%AF-interview-preparation">🎯 Interview Preparation</h2>
<h3 id="%F0%9F%93%8B-common-interview-topics"><strong>📋 Common Interview Topics</strong></h3>
<ul>
<li><strong>Array Manipulation</strong> - Two pointers, sliding window, sorting</li>
<li><strong>String Processing</strong> - Pattern matching, parsing, transformation</li>
<li><strong>Linked List Operations</strong> - Reversal, cycle detection, merging</li>
<li><strong>Tree Problems</strong> - Traversals, path finding, validation</li>
<li><strong>Graph Algorithms</strong> - BFS, DFS, shortest path, cycle detection</li>
<li><strong>Dynamic Programming</strong> - Optimization problems, memoization</li>
<li><strong>System Design</strong> - Scalability, data structure selection</li>
</ul>
<h3 id="%F0%9F%92%BC-interview-success-strategies"><strong>💼 Interview Success Strategies</strong></h3>
<ol>
<li><strong>Practice Regularly</strong> - Solve problems daily to maintain skills</li>
<li><strong>Explain Your Thinking</strong> - Verbalize your problem-solving process</li>
<li><strong>Start with Brute Force</strong> - Get a working solution first</li>
<li><strong>Optimize Iteratively</strong> - Improve time and space complexity</li>
<li><strong>Handle Edge Cases</strong> - Consider null inputs, empty arrays, etc.</li>
<li><strong>Test Your Code</strong> - Walk through examples to verify correctness</li>
</ol>
<hr>
<h2 id="%F0%9F%9B%A0%EF%B8%8F-development-environment-setup">🛠️ Development Environment Setup</h2>
<h3 id="javascript-environment"><strong>JavaScript Environment</strong></h3>
<pre class="hljs"><code><div><span class="hljs-comment"># Node.js for running JavaScript</span>
npm install -g node

<span class="hljs-comment"># Optional: Testing framework</span>
npm install -g jest

<span class="hljs-comment"># Optional: Performance benchmarking</span>
npm install benchmark
</div></code></pre>
<h3 id="c-environment"><strong>C++ Environment</strong></h3>
<pre class="hljs"><code><div><span class="hljs-comment"># GCC compiler (Linux/Mac)</span>
sudo apt-get install g++  <span class="hljs-comment"># Ubuntu</span>
brew install gcc          <span class="hljs-comment"># macOS</span>

<span class="hljs-comment"># Visual Studio (Windows)</span>
<span class="hljs-comment"># Download from Microsoft website</span>

<span class="hljs-comment"># Compilation example</span>
g++ -std=c++17 -O2 -o program program.cpp
</div></code></pre>
<h3 id="recommended-tools"><strong>Recommended Tools</strong></h3>
<ul>
<li><strong>Code Editor</strong>: VS Code, CLion, or your preferred IDE</li>
<li><strong>Version Control</strong>: Git for tracking progress</li>
<li><strong>Online Judges</strong>: LeetCode, HackerRank for additional practice</li>
<li><strong>Visualization Tools</strong>: VisuAlgo, Algorithm Visualizer</li>
</ul>
<hr>
<h2 id="%F0%9F%93%9A-additional-resources">📚 Additional Resources</h2>
<h3 id="%F0%9F%93%96-recommended-books"><strong>📖 Recommended Books</strong></h3>
<ul>
<li>&quot;Introduction to Algorithms&quot; by Cormen, Leiserson, Rivest, Stein</li>
<li>&quot;Algorithms&quot; by Robert Sedgewick and Kevin Wayne</li>
<li>&quot;Cracking the Coding Interview&quot; by Gayle Laakmann McDowell</li>
<li>&quot;Elements of Programming Interviews&quot; by Aziz, Lee, and Prakash</li>
</ul>
<h3 id="%F0%9F%8C%90-online-resources"><strong>🌐 Online Resources</strong></h3>
<ul>
<li><strong>LeetCode</strong>: Practice problems with community solutions</li>
<li><strong>HackerRank</strong>: Structured challenges and competitions</li>
<li><strong>GeeksforGeeks</strong>: Comprehensive algorithm explanations</li>
<li><strong>VisuAlgo</strong>: Interactive algorithm visualizations</li>
<li><strong>Big-O Cheat Sheet</strong>: Quick complexity reference</li>
</ul>
<h3 id="%F0%9F%8E%A5-video-content"><strong>🎥 Video Content</strong></h3>
<ul>
<li><strong>YouTube Channels</strong>: Abdul Bari, MIT OpenCourseWare, Tushar Roy</li>
<li><strong>Online Courses</strong>: Coursera, edX, Udemy algorithm courses</li>
<li><strong>Coding Streams</strong>: Watch experienced developers solve problems</li>
</ul>
<hr>
<h2 id="%F0%9F%A4%9D-community-and-support">🤝 Community and Support</h2>
<h3 id="%F0%9F%92%AC-getting-help"><strong>💬 Getting Help</strong></h3>
<ul>
<li><strong>Stack Overflow</strong>: Technical questions and debugging help</li>
<li><strong>Reddit</strong>: r/algorithms, r/programming, r/learnprogramming</li>
<li><strong>Discord/Slack</strong>: Programming communities and study groups</li>
<li><strong>GitHub</strong>: Open source implementations and discussions</li>
</ul>
<h3 id="%F0%9F%8E%AF-practice-platforms"><strong>🎯 Practice Platforms</strong></h3>
<ul>
<li><strong>LeetCode</strong>: 2000+ problems with detailed solutions</li>
<li><strong>HackerRank</strong>: Structured learning paths and competitions</li>
<li><strong>CodeSignal</strong>: Interview practice and skill assessment</li>
<li><strong>AtCoder</strong>: Competitive programming contests</li>
<li><strong>Codeforces</strong>: Advanced competitive programming</li>
</ul>
<hr>
<h2 id="%F0%9F%8E%89-getting-started">🎉 Getting Started</h2>
<h3 id="%F0%9F%9A%80-quick-start-guide"><strong>🚀 Quick Start Guide</strong></h3>
<ol>
<li><strong>Choose Your Track</strong> - Select learning pace based on your schedule</li>
<li><strong>Set Up Environment</strong> - Install necessary tools and compilers</li>
<li><strong>Start with Chapter 1</strong> - Begin with Arrays &amp; Strings</li>
<li><strong>Code Every Example</strong> - Don't skip the implementation practice</li>
<li><strong>Solve Practice Problems</strong> - Apply concepts immediately</li>
<li><strong>Track Your Progress</strong> - Use the completion checklist</li>
<li><strong>Build the Final Project</strong> - Demonstrate your comprehensive skills</li>
</ol>
<h3 id="%F0%9F%93%85-study-schedule-template"><strong>📅 Study Schedule Template</strong></h3>
<pre class="hljs"><code><div>Week X: [Chapter Name]
├── Day 1: Read theory and examples
├── Day 2: Implement JavaScript solutions
├── Day 3: Implement C++ solutions
├── Day 4: Solve practice problems
├── Day 5: Review and optimize solutions
├── Day 6: Additional practice/projects
└── Day 7: Rest or review previous chapters
</div></code></pre>
<hr>
<h2 id="%F0%9F%8E%AF-success-metrics">🎯 Success Metrics</h2>
<h3 id="%F0%9F%93%8A-how-to-measure-progress"><strong>📊 How to Measure Progress</strong></h3>
<ul>
<li><strong>Completion Rate</strong>: Percentage of chapters finished</li>
<li><strong>Problem Solving</strong>: Number of practice problems solved</li>
<li><strong>Code Quality</strong>: Clean, efficient, well-commented implementations</li>
<li><strong>Performance Understanding</strong>: Ability to analyze time/space complexity</li>
<li><strong>Application Skills</strong>: Successfully building the final project</li>
<li><strong>Interview Readiness</strong>: Confidence in explaining and implementing solutions</li>
</ul>
<h3 id="%F0%9F%8F%86-milestones"><strong>🏆 Milestones</strong></h3>
<ul>
<li><strong>🥉 Bronze</strong>: Complete fundamental data structures (Chapters 1-5)</li>
<li><strong>🥈 Silver</strong>: Master essential algorithms (Chapters 6-10)</li>
<li><strong>🥇 Gold</strong>: Conquer medium complexity topics (Chapters 11-15)</li>
<li><strong>💎 Diamond</strong>: Build and optimize the final project (Chapter 16)</li>
</ul>
<hr>
<h2 id="%F0%9F%93%9D-final-notes">📝 Final Notes</h2>
<p>This learning resource is designed to be:</p>
<ul>
<li><strong>Comprehensive</strong>: Covering all essential DSA topics</li>
<li><strong>Practical</strong>: Focus on real-world applications</li>
<li><strong>Progressive</strong>: Building complexity gradually</li>
<li><strong>Interactive</strong>: Hands-on coding and problem-solving</li>
<li><strong>Interview-Ready</strong>: Preparing you for technical assessments</li>
</ul>
<p><strong>Remember</strong>: The key to mastering data structures and algorithms is consistent practice and application. Don't rush through the material—take time to understand each concept deeply and implement every example.</p>
<p><strong>Good luck on your DSA learning journey!</strong> 🚀</p>
<hr>
<p><em>&quot;The best way to learn algorithms is to implement them yourself. This resource gives you the structured path and practical examples to do exactly that.&quot;</em></p>
<p><strong>Happy Coding!</strong> 💻✨</p>
<hr>
<h2 id="%F0%9F%93%84-license">📄 License</h2>
<p>This educational resource is provided for learning purposes. Feel free to use, modify, and share for educational and non-commercial purposes.</p>
<hr>
<p><strong>Last Updated</strong>: December 2024<br>
<strong>Version</strong>: 1.0<br>
<strong>Maintainer</strong>: DSA Learning Community</p>
<h1 id="chapter-1-arrays--strings---foundation-of-data-structures">Chapter 1: Arrays &amp; Strings - Foundation of Data Structures</h1>
<h2 id="%F0%9F%8E%AF-what-are-arrays--strings">🎯 What Are Arrays &amp; Strings?</h2>
<p><strong>Arrays</strong> are collections of elements stored in contiguous memory locations, where each element can be accessed using an index. <strong>Strings</strong> are essentially arrays of characters with additional operations for text manipulation.</p>
<h3 id="why-arrays--strings-matter">Why Arrays &amp; Strings Matter:</h3>
<ul>
<li><strong>Foundation</strong>: Building blocks for more complex data structures</li>
<li><strong>Performance</strong>: O(1) random access to elements</li>
<li><strong>Memory Efficiency</strong>: Contiguous storage reduces memory overhead</li>
<li><strong>Ubiquitous</strong>: Used in almost every programming problem</li>
</ul>
<hr>
<h2 id="%F0%9F%94%8D-core-operations--concepts">🔍 Core Operations &amp; Concepts</h2>
<h3 id="1-array-traversal">1. Array Traversal</h3>
<p>Visiting each element in the array sequentially.</p>
<h3 id="2-insertion--deletion">2. Insertion &amp; Deletion</h3>
<p>Adding or removing elements at specific positions.</p>
<h3 id="3-searching">3. Searching</h3>
<p>Finding elements or patterns within arrays/strings.</p>
<h3 id="4-string-manipulation">4. String Manipulation</h3>
<p>Operations like concatenation, substring extraction, and pattern matching.</p>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayOperations</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.arr = [];
  }

  <span class="hljs-comment">// Insert element at specific index</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  insert(index, element) {
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-keyword">this</span>.arr.length) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Index out of bounds"</span>);
    }

    <span class="hljs-comment">// Shift elements to the right</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-keyword">this</span>.arr.length; i &gt; index; i--) {
      <span class="hljs-keyword">this</span>.arr[i] = <span class="hljs-keyword">this</span>.arr[i - <span class="hljs-number">1</span>];
    }

    <span class="hljs-keyword">this</span>.arr[index] = element;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr;
  }

  <span class="hljs-comment">// Delete element at specific index</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  <span class="hljs-keyword">delete</span>(index) {
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-keyword">this</span>.arr.length) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Index out of bounds"</span>);
    }

    <span class="hljs-keyword">const</span> deletedElement = <span class="hljs-keyword">this</span>.arr[index];

    <span class="hljs-comment">// Shift elements to the left</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; <span class="hljs-keyword">this</span>.arr.length - <span class="hljs-number">1</span>; i++) {
      <span class="hljs-keyword">this</span>.arr[i] = <span class="hljs-keyword">this</span>.arr[i + <span class="hljs-number">1</span>];
    }

    <span class="hljs-keyword">this</span>.arr.length--; <span class="hljs-comment">// Reduce array size</span>
    <span class="hljs-keyword">return</span> deletedElement;
  }

  <span class="hljs-comment">// Linear search for element</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  search(element) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.arr.length; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.arr[i] === element) {
        <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// Return index if found</span>
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Element not found</span>
  }

  <span class="hljs-comment">// Reverse array in-place</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  reverse() {
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = <span class="hljs-keyword">this</span>.arr.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
      <span class="hljs-comment">// Swap elements</span>
      [<span class="hljs-keyword">this</span>.arr[left], <span class="hljs-keyword">this</span>.arr[right]] = [<span class="hljs-keyword">this</span>.arr[right], <span class="hljs-keyword">this</span>.arr[left]];
      left++;
      right--;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr;
  }
}

<span class="hljs-comment">// String Operations</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringOperations</span> </span>{
  <span class="hljs-comment">// Check if string is palindrome</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  <span class="hljs-keyword">static</span> isPalindrome(str) {
    <span class="hljs-keyword">const</span> cleaned = str.toLowerCase().replace(<span class="hljs-regexp">/[^a-z0-9]/g</span>, <span class="hljs-string">""</span>);
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = cleaned.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
      <span class="hljs-keyword">if</span> (cleaned[left] !== cleaned[right]) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      left++;
      right--;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Find all anagrams of pattern in text</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1) - assuming fixed alphabet size</span>
  <span class="hljs-keyword">static</span> findAnagrams(text, pattern) {
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> patternCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>).fill(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">const</span> windowCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>).fill(<span class="hljs-number">0</span>);

    <span class="hljs-comment">// Count characters in pattern</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> pattern) {
      patternCount[char.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-string">"a"</span>.charCodeAt(<span class="hljs-number">0</span>)]++;
    }

    <span class="hljs-comment">// Sliding window approach</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; text.length; i++) {
      <span class="hljs-comment">// Add current character to window</span>
      windowCount[text[i].charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-string">"a"</span>.charCodeAt(<span class="hljs-number">0</span>)]++;

      <span class="hljs-comment">// Remove character that's out of window</span>
      <span class="hljs-keyword">if</span> (i &gt;= pattern.length) {
        windowCount[
          text[i - pattern.length].charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-string">"a"</span>.charCodeAt(<span class="hljs-number">0</span>)
        ]--;
      }

      <span class="hljs-comment">// Check if current window is an anagram</span>
      <span class="hljs-keyword">if</span> (
        i &gt;= pattern.length - <span class="hljs-number">1</span> &amp;&amp;
        <span class="hljs-keyword">this</span>.arraysEqual(patternCount, windowCount)
      ) {
        result.push(i - pattern.length + <span class="hljs-number">1</span>);
      }
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">static</span> arraysEqual(arr1, arr2) {
    <span class="hljs-keyword">return</span> arr1.every(<span class="hljs-function">(<span class="hljs-params">val, index</span>) =&gt;</span> val === arr2[index]);
  }
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-keyword">const</span> arrayOps = <span class="hljs-keyword">new</span> ArrayOperations();
arrayOps.arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(arrayOps.insert(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// [1, 2, 10, 3, 4, 5]</span>
<span class="hljs-built_in">console</span>.log(arrayOps.search(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">console</span>.log(arrayOps.reverse()); <span class="hljs-comment">// [5, 4, 3, 10, 2, 1]</span>

<span class="hljs-built_in">console</span>.log(StringOperations.isPalindrome(<span class="hljs-string">"A man a plan a canal Panama"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(StringOperations.findAnagrams(<span class="hljs-string">"abab"</span>, <span class="hljs-string">"ab"</span>)); <span class="hljs-comment">// [0, 2]</span>
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayOperations</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Insert element at specific index</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> element)</span> </span>{
        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; arr.size()) {
            <span class="hljs-keyword">throw</span> out_of_range(<span class="hljs-string">"Index out of bounds"</span>);
        }

        arr.insert(arr.begin() + index, element);
    }

    <span class="hljs-comment">// Delete element at specific index</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= arr.size()) {
            <span class="hljs-keyword">throw</span> out_of_range(<span class="hljs-string">"Index out of bounds"</span>);
        }

        <span class="hljs-keyword">int</span> deletedElement = arr[index];
        arr.erase(arr.begin() + index);
        <span class="hljs-keyword">return</span> deletedElement;
    }

    <span class="hljs-comment">// Linear search for element</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> element)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) {
            <span class="hljs-keyword">if</span> (arr[i] == element) {
                <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// Return index if found</span>
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Element not found</span>
    }

    <span class="hljs-comment">// Reverse array in-place</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span> (left &lt; right) {
            swap(arr[left], arr[right]);
            left++;
            right--;
        }
    }

    <span class="hljs-comment">// Display array</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"["</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; arr[i];
            <span class="hljs-keyword">if</span> (i &lt; arr.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">", "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Initialize array</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; newArr)</span> </span>{
        arr = newArr;
    }
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringOperations</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Check if string is palindrome</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span> </span>{
        <span class="hljs-comment">// Clean string: remove non-alphanumeric and convert to lowercase</span>
        <span class="hljs-built_in">string</span> cleaned = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str) {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalnum</span>(c)) {
                cleaned += <span class="hljs-built_in">tolower</span>(c);
            }
        }

        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> right = cleaned.length() - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span> (left &lt; right) {
            <span class="hljs-keyword">if</span> (cleaned[left] != cleaned[right]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            left++;
            right--;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Find all anagrams of pattern in text</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1) - assuming fixed alphabet size</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">string</span> text, <span class="hljs-built_in">string</span> pattern)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        <span class="hljs-keyword">if</span> (text.length() &lt; pattern.length()) <span class="hljs-keyword">return</span> result;

        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">patternCount</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">windowCount</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;

        <span class="hljs-comment">// Count characters in pattern</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : pattern) {
            patternCount[c - <span class="hljs-string">'a'</span>]++;
        }

        <span class="hljs-comment">// Sliding window approach</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; text.length(); i++) {
            <span class="hljs-comment">// Add current character to window</span>
            windowCount[text[i] - <span class="hljs-string">'a'</span>]++;

            <span class="hljs-comment">// Remove character that's out of window</span>
            <span class="hljs-keyword">if</span> (i &gt;= pattern.length()) {
                windowCount[text[i - pattern.length()] - <span class="hljs-string">'a'</span>]--;
            }

            <span class="hljs-comment">// Check if current window is an anagram</span>
            <span class="hljs-keyword">if</span> (i &gt;= pattern.length() - <span class="hljs-number">1</span> &amp;&amp; patternCount == windowCount) {
                result.push_back(i - pattern.length() + <span class="hljs-number">1</span>);
            }
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Longest substring without repeating characters</span>
    <span class="hljs-comment">// Time: O(n), Space: O(min(m,n)) where m is charset size</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestUniqueSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; charIndex;
        <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; end &lt; s.length(); end++) {
            <span class="hljs-keyword">char</span> currentChar = s[end];

            <span class="hljs-comment">// If character is already in current window, move start</span>
            <span class="hljs-keyword">if</span> (charIndex.find(currentChar) != charIndex.end() &amp;&amp;
                charIndex[currentChar] &gt;= start) {
                start = charIndex[currentChar] + <span class="hljs-number">1</span>;
            }

            charIndex[currentChar] = end;
            maxLength = max(maxLength, end - start + <span class="hljs-number">1</span>);
        }

        <span class="hljs-keyword">return</span> maxLength;
    }
};

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Array operations</span>
    ArrayOperations arrayOps;
    arrayOps.setArray({<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>});

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original array: "</span>;
    arrayOps.display();

    arrayOps.insert(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After inserting 10 at index 2: "</span>;
    arrayOps.display();

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Search for 10: "</span> &lt;&lt; arrayOps.search(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    arrayOps.reverse();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After reversing: "</span>;
    arrayOps.display();

    <span class="hljs-comment">// String operations</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nString Operations:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is 'A man a plan a canal Panama' palindrome? "</span>
         &lt;&lt; (StringOperations::isPalindrome(<span class="hljs-string">"A man a plan a canal Panama"</span>) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; anagrams = StringOperations::findAnagrams(<span class="hljs-string">"abab"</span>, <span class="hljs-string">"ab"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Anagram positions of 'ab' in 'abab': "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pos : anagrams) {
        <span class="hljs-built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Longest unique substring in 'abcabcbb': "</span>
         &lt;&lt; StringOperations::longestUniqueSubstring(<span class="hljs-string">"abcabcbb"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity">Time Complexity:</h3>
<ul>
<li><strong>Access</strong>: O(1) - Direct indexing</li>
<li><strong>Search</strong>: O(n) - Linear search through elements</li>
<li><strong>Insertion</strong>: O(n) - May need to shift elements</li>
<li><strong>Deletion</strong>: O(n) - May need to shift elements</li>
<li><strong>Traversal</strong>: O(n) - Visit each element once</li>
</ul>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>Fixed-size arrays</strong>: O(1) additional space</li>
<li><strong>Dynamic arrays</strong>: O(n) for the array itself</li>
<li><strong>String operations</strong>: Often O(1) additional space with in-place algorithms</li>
</ul>
<h3 id="common-pitfalls">Common Pitfalls:</h3>
<ol>
<li><strong>Index out of bounds</strong>: Always validate array indices</li>
<li><strong>Off-by-one errors</strong>: Be careful with loop boundaries</li>
<li><strong>Memory management</strong>: In C++, be mindful of dynamic allocation</li>
<li><strong>String immutability</strong>: In some languages, strings are immutable</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-two-sum">Problem 1: Two Sum</h3>
<p><strong>Question</strong>: Given an array of integers and a target sum, return indices of two numbers that add up to the target.</p>
<p><strong>Hint</strong>: Use a hash map to store complements as you iterate.</p>
<p><strong>Solution Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">nums, target</span>) </span>{
  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
    <span class="hljs-keyword">const</span> complement = target - nums[i];
    <span class="hljs-keyword">if</span> (map.has(complement)) {
      <span class="hljs-keyword">return</span> [map.get(complement), i];
    }
    map.set(nums[i], i);
  }

  <span class="hljs-keyword">return</span> [];
}
</div></code></pre>
<h3 id="problem-2-valid-anagram">Problem 2: Valid Anagram</h3>
<p><strong>Question</strong>: Given two strings, determine if they are anagrams of each other.</p>
<p><strong>Hint</strong>: Count character frequencies or sort both strings.</p>
<h3 id="problem-3-remove-duplicates">Problem 3: Remove Duplicates</h3>
<p><strong>Question</strong>: Remove duplicates from a sorted array in-place.</p>
<p><strong>Hint</strong>: Use two pointers - one for reading, one for writing.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Edge case handling</strong>: Empty arrays, single elements, null inputs</li>
<li><strong>Optimization awareness</strong>: Can you improve from O(n²) to O(n)?</li>
<li><strong>Space-time tradeoffs</strong>: When to use extra space for better time complexity</li>
<li><strong>Clean code</strong>: Readable, well-commented implementations</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Two Pointers</strong>: For problems involving pairs or reversing</li>
<li><strong>Sliding Window</strong>: For substring/subarray problems</li>
<li><strong>Hash Maps</strong>: For frequency counting and lookups</li>
<li><strong>In-place operations</strong>: Modifying arrays without extra space</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Not asking about input constraints</li>
<li>Jumping to code without explaining approach</li>
<li>Ignoring edge cases</li>
<li>Not discussing time/space complexity</li>
</ul>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Arrays are fundamental</strong> - Master them before moving to complex structures</li>
<li><strong>Index management is crucial</strong> - Most bugs come from incorrect indexing</li>
<li><strong>Consider both time and space</strong> - Sometimes trading space for time is worth it</li>
<li><strong>Practice string manipulation</strong> - Very common in interviews</li>
<li><strong>Learn common patterns</strong> - Two pointers, sliding window, etc.</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Linked Lists and see how they differ from arrays in memory layout and operations.</p>
<h1 id="chapter-2-linked-lists---dynamic-memory-management">Chapter 2: Linked Lists - Dynamic Memory Management</h1>
<h2 id="%F0%9F%8E%AF-what-are-linked-lists">🎯 What Are Linked Lists?</h2>
<p><strong>Linked Lists</strong> are linear data structures where elements (nodes) are stored in sequence, but unlike arrays, they don't require contiguous memory. Each node contains data and a reference (pointer) to the next node in the sequence.</p>
<h3 id="why-linked-lists-matter">Why Linked Lists Matter:</h3>
<ul>
<li><strong>Dynamic Size</strong>: Can grow or shrink during runtime</li>
<li><strong>Efficient Insertion/Deletion</strong>: O(1) at known positions</li>
<li><strong>Memory Efficiency</strong>: Only allocate what you need</li>
<li><strong>Foundation</strong>: Building block for stacks, queues, and graphs</li>
</ul>
<h3 id="types-of-linked-lists">Types of Linked Lists:</h3>
<ol>
<li><strong>Singly Linked List</strong>: Each node points to the next node</li>
<li><strong>Doubly Linked List</strong>: Each node has pointers to both next and previous nodes</li>
<li><strong>Circular Linked List</strong>: Last node points back to the first node</li>
</ol>
<hr>
<h2 id="%F0%9F%94%8D-core-operations">🔍 Core Operations</h2>
<h3 id="1-insertion">1. Insertion</h3>
<ul>
<li>At the beginning (head)</li>
<li>At the end (tail)</li>
<li>At a specific position</li>
</ul>
<h3 id="2-deletion">2. Deletion</h3>
<ul>
<li>From the beginning</li>
<li>From the end</li>
<li>From a specific position</li>
<li>By value</li>
</ul>
<h3 id="3-traversal">3. Traversal</h3>
<ul>
<li>Forward traversal</li>
<li>Backward traversal (doubly linked)</li>
</ul>
<h3 id="4-search">4. Search</h3>
<ul>
<li>Finding a node by value</li>
<li>Finding a node by position</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Node class for singly linked list</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(data) {
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-comment">// Singly Linked List Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinglyLinkedList</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.head = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Insert at the beginning</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  insertAtHead(data) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> ListNode(data);
    newNode.next = <span class="hljs-keyword">this</span>.head;
    <span class="hljs-keyword">this</span>.head = newNode;
    <span class="hljs-keyword">this</span>.size++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-comment">// Insert at the end</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  insertAtTail(data) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> ListNode(data);

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head) {
      <span class="hljs-keyword">this</span>.head = newNode;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head;
      <span class="hljs-keyword">while</span> (current.next) {
        current = current.next;
      }
      current.next = newNode;
    }

    <span class="hljs-keyword">this</span>.size++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-comment">// Insert at specific index</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  insertAt(index, data) {
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-keyword">this</span>.size) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Index out of bounds"</span>);
    }

    <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.insertAtHead(data);
    }

    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> ListNode(data);
    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head;

    <span class="hljs-comment">// Traverse to position index-1</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index - <span class="hljs-number">1</span>; i++) {
      current = current.next;
    }

    newNode.next = current.next;
    current.next = newNode;
    <span class="hljs-keyword">this</span>.size++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-comment">// Delete from head</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  deleteHead() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">const</span> deletedData = <span class="hljs-keyword">this</span>.head.data;
    <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.head.next;
    <span class="hljs-keyword">this</span>.size--;
    <span class="hljs-keyword">return</span> deletedData;
  }

  <span class="hljs-comment">// Delete from tail</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  deleteTail() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head.next) {
      <span class="hljs-keyword">const</span> deletedData = <span class="hljs-keyword">this</span>.head.data;
      <span class="hljs-keyword">this</span>.head = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.size--;
      <span class="hljs-keyword">return</span> deletedData;
    }

    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head;
    <span class="hljs-keyword">while</span> (current.next.next) {
      current = current.next;
    }

    <span class="hljs-keyword">const</span> deletedData = current.next.data;
    current.next = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.size--;
    <span class="hljs-keyword">return</span> deletedData;
  }

  <span class="hljs-comment">// Delete by value</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  deleteByValue(value) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head.data === value) {
      <span class="hljs-keyword">this</span>.deleteHead();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head;
    <span class="hljs-keyword">while</span> (current.next &amp;&amp; current.next.data !== value) {
      current = current.next;
    }

    <span class="hljs-keyword">if</span> (current.next) {
      current.next = current.next.next;
      <span class="hljs-keyword">this</span>.size--;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Search for value</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  search(value) {
    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head;
    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (current) {
      <span class="hljs-keyword">if</span> (current.data === value) {
        <span class="hljs-keyword">return</span> index;
      }
      current = current.next;
      index++;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// Reverse the linked list</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  reverse() {
    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head;
    <span class="hljs-keyword">let</span> next = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">while</span> (current) {
      next = current.next; <span class="hljs-comment">// Store next node</span>
      current.next = prev; <span class="hljs-comment">// Reverse the link</span>
      prev = current; <span class="hljs-comment">// Move prev forward</span>
      current = next; <span class="hljs-comment">// Move current forward</span>
    }

    <span class="hljs-keyword">this</span>.head = prev;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-comment">// Find middle element (Floyd's Cycle Detection)</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  findMiddle() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">let</span> slow = <span class="hljs-keyword">this</span>.head;
    <span class="hljs-keyword">let</span> fast = <span class="hljs-keyword">this</span>.head;

    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.next) {
      slow = slow.next;
      fast = fast.next.next;
    }

    <span class="hljs-keyword">return</span> slow.data;
  }

  <span class="hljs-comment">// Detect cycle in linked list</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
  hasCycle() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">let</span> slow = <span class="hljs-keyword">this</span>.head;
    <span class="hljs-keyword">let</span> fast = <span class="hljs-keyword">this</span>.head;

    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast.next) {
      slow = slow.next;
      fast = fast.next.next;

      <span class="hljs-keyword">if</span> (slow === fast) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Convert to array for easy display</span>
  toArray() {
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head;

    <span class="hljs-keyword">while</span> (current) {
      result.push(current.data);
      current = current.next;
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Get size</span>
  getSize() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size;
  }
}

<span class="hljs-comment">// Doubly Linked List Node</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublyListNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(data) {
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.prev = <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-comment">// Doubly Linked List Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublyLinkedList</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.head = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.tail = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Insert at head</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  insertAtHead(data) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> DoublyListNode(data);

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head) {
      <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.tail = newNode;
    } <span class="hljs-keyword">else</span> {
      newNode.next = <span class="hljs-keyword">this</span>.head;
      <span class="hljs-keyword">this</span>.head.prev = newNode;
      <span class="hljs-keyword">this</span>.head = newNode;
    }

    <span class="hljs-keyword">this</span>.size++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-comment">// Insert at tail</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  insertAtTail(data) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> DoublyListNode(data);

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.tail) {
      <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.tail = newNode;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.tail.next = newNode;
      newNode.prev = <span class="hljs-keyword">this</span>.tail;
      <span class="hljs-keyword">this</span>.tail = newNode;
    }

    <span class="hljs-keyword">this</span>.size++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-comment">// Delete from head</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  deleteHead() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">const</span> deletedData = <span class="hljs-keyword">this</span>.head.data;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head === <span class="hljs-keyword">this</span>.tail) {
      <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.tail = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.head.next;
      <span class="hljs-keyword">this</span>.head.prev = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">this</span>.size--;
    <span class="hljs-keyword">return</span> deletedData;
  }

  <span class="hljs-comment">// Delete from tail</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  deleteTail() {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">const</span> deletedData = <span class="hljs-keyword">this</span>.tail.data;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head === <span class="hljs-keyword">this</span>.tail) {
      <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.tail = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">this</span>.tail.prev;
      <span class="hljs-keyword">this</span>.tail.next = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">this</span>.size--;
    <span class="hljs-keyword">return</span> deletedData;
  }

  <span class="hljs-comment">// Convert to array (forward)</span>
  toArray() {
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.head;

    <span class="hljs-keyword">while</span> (current) {
      result.push(current.data);
      current = current.next;
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Convert to array (backward)</span>
  toArrayReverse() {
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>.tail;

    <span class="hljs-keyword">while</span> (current) {
      result.push(current.data);
      current = current.prev;
    }

    <span class="hljs-keyword">return</span> result;
  }
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-keyword">const</span> sll = <span class="hljs-keyword">new</span> SinglyLinkedList();
sll.insertAtHead(<span class="hljs-number">1</span>).insertAtHead(<span class="hljs-number">2</span>).insertAtTail(<span class="hljs-number">3</span>).insertAt(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Singly Linked List:"</span>, sll.toArray()); <span class="hljs-comment">// [2, 5, 1, 3]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Middle element:"</span>, sll.findMiddle()); <span class="hljs-comment">// 5</span>
sll.reverse();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"After reverse:"</span>, sll.toArray()); <span class="hljs-comment">// [3, 1, 5, 2]</span>

<span class="hljs-keyword">const</span> dll = <span class="hljs-keyword">new</span> DoublyLinkedList();
dll.insertAtHead(<span class="hljs-number">1</span>).insertAtTail(<span class="hljs-number">2</span>).insertAtHead(<span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Doubly Linked List:"</span>, dll.toArray()); <span class="hljs-comment">// [0, 1, 2]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Reverse traversal:"</span>, dll.toArrayReverse()); <span class="hljs-comment">// [2, 1, 0]</span>
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Node structure for singly linked list</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> data;
    ListNode* next;

    ListNode(<span class="hljs-keyword">int</span> val) : data(val), next(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-comment">// Singly Linked List Class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinglyLinkedList</span> {</span>
<span class="hljs-keyword">private</span>:
    ListNode* head;
    <span class="hljs-keyword">int</span> size;

<span class="hljs-keyword">public</span>:
    SinglyLinkedList() : head(<span class="hljs-literal">nullptr</span>), size(<span class="hljs-number">0</span>) {}

    <span class="hljs-comment">// Destructor to prevent memory leaks</span>
    ~SinglyLinkedList() {
        clear();
    }

    <span class="hljs-comment">// Insert at the beginning</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>{
        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode(data);
        newNode-&gt;next = head;
        head = newNode;
        size++;
    }

    <span class="hljs-comment">// Insert at the end</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>{
        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode(data);

        <span class="hljs-keyword">if</span> (!head) {
            head = newNode;
        } <span class="hljs-keyword">else</span> {
            ListNode* current = head;
            <span class="hljs-keyword">while</span> (current-&gt;next) {
                current = current-&gt;next;
            }
            current-&gt;next = newNode;
        }

        size++;
    }

    <span class="hljs-comment">// Insert at specific index</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> data)</span> </span>{
        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) {
            <span class="hljs-keyword">throw</span> out_of_range(<span class="hljs-string">"Index out of bounds"</span>);
        }

        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) {
            insertAtHead(data);
            <span class="hljs-keyword">return</span>;
        }

        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode(data);
        ListNode* current = head;

        <span class="hljs-comment">// Traverse to position index-1</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index - <span class="hljs-number">1</span>; i++) {
            current = current-&gt;next;
        }

        newNode-&gt;next = current-&gt;next;
        current-&gt;next = newNode;
        size++;
    }

    <span class="hljs-comment">// Delete from head</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!head) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        ListNode* temp = head;
        head = head-&gt;next;
        <span class="hljs-keyword">delete</span> temp;
        size--;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Delete by value</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteByValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
        <span class="hljs-keyword">if</span> (!head) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (head-&gt;data == value) {
            <span class="hljs-keyword">return</span> deleteHead();
        }

        ListNode* current = head;
        <span class="hljs-keyword">while</span> (current-&gt;next &amp;&amp; current-&gt;next-&gt;data != value) {
            current = current-&gt;next;
        }

        <span class="hljs-keyword">if</span> (current-&gt;next) {
            ListNode* temp = current-&gt;next;
            current-&gt;next = current-&gt;next-&gt;next;
            <span class="hljs-keyword">delete</span> temp;
            size--;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Search for value</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
        ListNode* current = head;
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">while</span> (current) {
            <span class="hljs-keyword">if</span> (current-&gt;data == value) {
                <span class="hljs-keyword">return</span> index;
            }
            current = current-&gt;next;
            index++;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-comment">// Reverse the linked list</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">()</span> </span>{
        ListNode* prev = <span class="hljs-literal">nullptr</span>;
        ListNode* current = head;
        ListNode* next = <span class="hljs-literal">nullptr</span>;

        <span class="hljs-keyword">while</span> (current) {
            next = current-&gt;next;  <span class="hljs-comment">// Store next node</span>
            current-&gt;next = prev;  <span class="hljs-comment">// Reverse the link</span>
            prev = current;        <span class="hljs-comment">// Move prev forward</span>
            current = next;        <span class="hljs-comment">// Move current forward</span>
        }

        head = prev;
    }

    <span class="hljs-comment">// Find middle element using Floyd's algorithm</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMiddle</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!head) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"List is empty"</span>);
        }

        ListNode* slow = head;
        ListNode* fast = head;

        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }

        <span class="hljs-keyword">return</span> slow-&gt;data;
    }

    <span class="hljs-comment">// Detect cycle in linked list</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        ListNode* slow = head;
        ListNode* fast = head;

        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;

            <span class="hljs-keyword">if</span> (slow == fast) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Merge two sorted linked lists</span>
    <span class="hljs-comment">// Time: O(m + n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> ListNode* <span class="hljs-title">mergeSorted</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{
        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;
        ListNode* current = &amp;dummy;

        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) {
            <span class="hljs-keyword">if</span> (l1-&gt;data &lt;= l2-&gt;data) {
                current-&gt;next = l1;
                l1 = l1-&gt;next;
            } <span class="hljs-keyword">else</span> {
                current-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            current = current-&gt;next;
        }

        <span class="hljs-comment">// Attach remaining nodes</span>
        current-&gt;next = l1 ? l1 : l2;

        <span class="hljs-keyword">return</span> dummy.next;
    }

    <span class="hljs-comment">// Display the list</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>{
        ListNode* current = head;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"["</span>;

        <span class="hljs-keyword">while</span> (current) {
            <span class="hljs-built_in">cout</span> &lt;&lt; current-&gt;data;
            <span class="hljs-keyword">if</span> (current-&gt;next) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" -&gt; "</span>;
            current = current-&gt;next;
        }

        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Get size</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> size;
    }

    <span class="hljs-comment">// Clear all nodes</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (head) {
            ListNode* temp = head;
            head = head-&gt;next;
            <span class="hljs-keyword">delete</span> temp;
        }
        size = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// Get head for external operations</span>
    <span class="hljs-function">ListNode* <span class="hljs-title">getHead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> head;
    }
};

<span class="hljs-comment">// Doubly Linked List Node</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DoublyListNode</span> {</span>
    <span class="hljs-keyword">int</span> data;
    DoublyListNode* next;
    DoublyListNode* prev;

    DoublyListNode(<span class="hljs-keyword">int</span> val) : data(val), next(<span class="hljs-literal">nullptr</span>), prev(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-comment">// Doubly Linked List Class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublyLinkedList</span> {</span>
<span class="hljs-keyword">private</span>:
    DoublyListNode* head;
    DoublyListNode* tail;
    <span class="hljs-keyword">int</span> size;

<span class="hljs-keyword">public</span>:
    DoublyLinkedList() : head(<span class="hljs-literal">nullptr</span>), tail(<span class="hljs-literal">nullptr</span>), size(<span class="hljs-number">0</span>) {}

    <span class="hljs-comment">// Destructor</span>
    ~DoublyLinkedList() {
        clear();
    }

    <span class="hljs-comment">// Insert at head</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>{
        DoublyListNode* newNode = <span class="hljs-keyword">new</span> DoublyListNode(data);

        <span class="hljs-keyword">if</span> (!head) {
            head = tail = newNode;
        } <span class="hljs-keyword">else</span> {
            newNode-&gt;next = head;
            head-&gt;prev = newNode;
            head = newNode;
        }

        size++;
    }

    <span class="hljs-comment">// Insert at tail</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>{
        DoublyListNode* newNode = <span class="hljs-keyword">new</span> DoublyListNode(data);

        <span class="hljs-keyword">if</span> (!tail) {
            head = tail = newNode;
        } <span class="hljs-keyword">else</span> {
            tail-&gt;next = newNode;
            newNode-&gt;prev = tail;
            tail = newNode;
        }

        size++;
    }

    <span class="hljs-comment">// Delete from head</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (head == tail) {
            <span class="hljs-keyword">delete</span> head;
            head = tail = <span class="hljs-literal">nullptr</span>;
        } <span class="hljs-keyword">else</span> {
            DoublyListNode* temp = head;
            head = head-&gt;next;
            head-&gt;prev = <span class="hljs-literal">nullptr</span>;
            <span class="hljs-keyword">delete</span> temp;
        }

        size--;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Delete from tail</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteTail</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (head == tail) {
            <span class="hljs-keyword">delete</span> tail;
            head = tail = <span class="hljs-literal">nullptr</span>;
        } <span class="hljs-keyword">else</span> {
            DoublyListNode* temp = tail;
            tail = tail-&gt;prev;
            tail-&gt;next = <span class="hljs-literal">nullptr</span>;
            <span class="hljs-keyword">delete</span> temp;
        }

        size--;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Display forward</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayForward</span><span class="hljs-params">()</span> </span>{
        DoublyListNode* current = head;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Forward: ["</span>;

        <span class="hljs-keyword">while</span> (current) {
            <span class="hljs-built_in">cout</span> &lt;&lt; current-&gt;data;
            <span class="hljs-keyword">if</span> (current-&gt;next) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" &lt;-&gt; "</span>;
            current = current-&gt;next;
        }

        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Display backward</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">displayBackward</span><span class="hljs-params">()</span> </span>{
        DoublyListNode* current = tail;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Backward: ["</span>;

        <span class="hljs-keyword">while</span> (current) {
            <span class="hljs-built_in">cout</span> &lt;&lt; current-&gt;data;
            <span class="hljs-keyword">if</span> (current-&gt;prev) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" &lt;-&gt; "</span>;
            current = current-&gt;prev;
        }

        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Clear all nodes</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (head) {
            DoublyListNode* temp = head;
            head = head-&gt;next;
            <span class="hljs-keyword">delete</span> temp;
        }
        head = tail = <span class="hljs-literal">nullptr</span>;
        size = <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> size;
    }
};

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Singly Linked List Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    SinglyLinkedList sll;

    sll.insertAtHead(<span class="hljs-number">1</span>);
    sll.insertAtHead(<span class="hljs-number">2</span>);
    sll.insertAtTail(<span class="hljs-number">3</span>);
    sll.insertAt(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original list: "</span>;
    sll.display();

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Middle element: "</span> &lt;&lt; sll.findMiddle() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Search for 5: "</span> &lt;&lt; sll.search(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    sll.reverse();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After reverse: "</span>;
    sll.display();

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Doubly Linked List Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    DoublyLinkedList dll;

    dll.insertAtHead(<span class="hljs-number">1</span>);
    dll.insertAtTail(<span class="hljs-number">2</span>);
    dll.insertAtHead(<span class="hljs-number">0</span>);

    dll.displayForward();
    dll.displayBackward();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity-comparison">Time Complexity Comparison:</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Array</th>
<th>Singly Linked List</th>
<th>Doubly Linked List</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Search</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Insert at head</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Insert at tail</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Delete at head</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Delete at tail</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>Singly Linked List</strong>: O(n) - one pointer per node</li>
<li><strong>Doubly Linked List</strong>: O(n) - two pointers per node</li>
<li><strong>Additional space per operation</strong>: O(1)</li>
</ul>
<h3 id="common-pitfalls">Common Pitfalls:</h3>
<ol>
<li><strong>Memory leaks</strong>: Always delete nodes in C++</li>
<li><strong>Null pointer access</strong>: Check for null before dereferencing</li>
<li><strong>Lost references</strong>: Keep track of nodes during operations</li>
<li><strong>Infinite loops</strong>: Be careful with cycle detection</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-remove-nth-node-from-end">Problem 1: Remove Nth Node from End</h3>
<p><strong>Question</strong>: Given a linked list, remove the nth node from the end.</p>
<p><strong>Hint</strong>: Use two pointers with n distance between them.</p>
<p><strong>Solution Approach</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">head, n</span>) </span>{
  <span class="hljs-keyword">const</span> dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
  dummy.next = head;
  <span class="hljs-keyword">let</span> first = dummy;
  <span class="hljs-keyword">let</span> second = dummy;

  <span class="hljs-comment">// Move first pointer n+1 steps ahead</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    first = first.next;
  }

  <span class="hljs-comment">// Move both pointers until first reaches end</span>
  <span class="hljs-keyword">while</span> (first) {
    first = first.next;
    second = second.next;
  }

  <span class="hljs-comment">// Remove the nth node</span>
  second.next = second.next.next;
  <span class="hljs-keyword">return</span> dummy.next;
}
</div></code></pre>
<h3 id="problem-2-merge-two-sorted-lists">Problem 2: Merge Two Sorted Lists</h3>
<p><strong>Question</strong>: Merge two sorted linked lists into one sorted list.</p>
<p><strong>Hint</strong>: Use a dummy node and compare values iteratively.</p>
<h3 id="problem-3-linked-list-cycle-ii">Problem 3: Linked List Cycle II</h3>
<p><strong>Question</strong>: Find the starting node of a cycle in a linked list.</p>
<p><strong>Hint</strong>: Use Floyd's algorithm, then find the intersection point.</p>
<h3 id="problem-4-palindrome-linked-list">Problem 4: Palindrome Linked List</h3>
<p><strong>Question</strong>: Check if a linked list is a palindrome.</p>
<p><strong>Hint</strong>: Find middle, reverse second half, compare with first half.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Pointer manipulation</strong>: Can you handle next/prev pointers correctly?</li>
<li><strong>Edge cases</strong>: Empty lists, single nodes, cycles</li>
<li><strong>Memory management</strong>: Proper allocation/deallocation in C++</li>
<li><strong>Algorithm optimization</strong>: Using techniques like Floyd's cycle detection</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Two Pointers</strong>: Fast/slow pointers for cycle detection, finding middle</li>
<li><strong>Dummy Nodes</strong>: Simplify edge cases in insertion/deletion</li>
<li><strong>Recursion</strong>: For problems like reversing or merging</li>
<li><strong>Stack</strong>: For problems requiring backtracking</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Modifying input without permission</li>
<li>Not handling null pointers</li>
<li>Creating memory leaks in C++</li>
<li>Not considering edge cases (empty list, single node)</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Draw it out</strong>: Visualize pointer movements</li>
<li><strong>Use dummy nodes</strong>: Simplifies many operations</li>
<li><strong>Check for cycles</strong>: Always consider if cycles are possible</li>
<li><strong>Practice pointer arithmetic</strong>: Master the fundamentals</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Linked lists excel at insertion/deletion</strong> - O(1) at known positions</li>
<li><strong>Trade-off with arrays</strong> - Dynamic size vs. random access</li>
<li><strong>Pointer manipulation is crucial</strong> - Practice makes perfect</li>
<li><strong>Memory management matters</strong> - Especially in C++</li>
<li><strong>Many algorithms use two pointers</strong> - Fast/slow, leading/trailing</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Stacks &amp; Queues and see how they can be implemented using linked lists and arrays.</p>
<h1 id="chapter-3-stacks--queues---lifo-and-fifo-data-structures">Chapter 3: Stacks &amp; Queues - LIFO and FIFO Data Structures</h1>
<h2 id="%F0%9F%8E%AF-what-are-stacks--queues">🎯 What Are Stacks &amp; Queues?</h2>
<p><strong>Stack</strong> is a linear data structure that follows the Last In, First Out (LIFO) principle. Think of it like a stack of plates - you can only add or remove plates from the top.</p>
<p><strong>Queue</strong> is a linear data structure that follows the First In, First Out (FIFO) principle. Think of it like a line at a store - the first person in line is the first to be served.</p>
<h3 id="why-stacks--queues-matter">Why Stacks &amp; Queues Matter:</h3>
<ul>
<li><strong>Function calls</strong>: Call stack in programming languages</li>
<li><strong>Undo operations</strong>: Text editors, browsers</li>
<li><strong>Expression evaluation</strong>: Parsing mathematical expressions</li>
<li><strong>BFS/DFS</strong>: Graph traversal algorithms</li>
<li><strong>Task scheduling</strong>: Operating systems, print queues</li>
</ul>
<hr>
<h2 id="%F0%9F%94%8D-stack-operations">🔍 Stack Operations</h2>
<h3 id="core-operations">Core Operations:</h3>
<ol>
<li><strong>Push</strong>: Add element to the top</li>
<li><strong>Pop</strong>: Remove element from the top</li>
<li><strong>Peek/Top</strong>: View the top element without removing</li>
<li><strong>isEmpty</strong>: Check if stack is empty</li>
<li><strong>Size</strong>: Get number of elements</li>
</ol>
<h3 id="applications">Applications:</h3>
<ul>
<li><strong>Expression evaluation</strong> (infix to postfix)</li>
<li><strong>Parentheses matching</strong></li>
<li><strong>Function call management</strong></li>
<li><strong>Undo/Redo operations</strong></li>
<li><strong>Depth-First Search (DFS)</strong></li>
</ul>
<hr>
<h2 id="%F0%9F%94%8D-queue-operations">🔍 Queue Operations</h2>
<h3 id="core-operations">Core Operations:</h3>
<ol>
<li><strong>Enqueue</strong>: Add element to the rear</li>
<li><strong>Dequeue</strong>: Remove element from the front</li>
<li><strong>Front</strong>: View the front element</li>
<li><strong>Rear</strong>: View the rear element</li>
<li><strong>isEmpty</strong>: Check if queue is empty</li>
<li><strong>Size</strong>: Get number of elements</li>
</ol>
<h3 id="types-of-queues">Types of Queues:</h3>
<ul>
<li><strong>Simple Queue</strong>: Basic FIFO queue</li>
<li><strong>Circular Queue</strong>: Rear connects back to front</li>
<li><strong>Priority Queue</strong>: Elements have priorities</li>
<li><strong>Deque</strong>: Double-ended queue (insertion/deletion at both ends)</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Stack Implementation using Array</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.items = [];
  }

  <span class="hljs-comment">// Push element to top</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  push(element) {
    <span class="hljs-keyword">this</span>.items.push(element);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size();
  }

  <span class="hljs-comment">// Pop element from top</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  pop() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Stack is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.pop();
  }

  <span class="hljs-comment">// Peek at top element</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  peek() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Stack is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.items.length - <span class="hljs-number">1</span>];
  }

  <span class="hljs-comment">// Check if stack is empty</span>
  isEmpty() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length === <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Get stack size</span>
  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length;
  }

  <span class="hljs-comment">// Clear stack</span>
  clear() {
    <span class="hljs-keyword">this</span>.items = [];
  }

  <span class="hljs-comment">// Convert to array for display</span>
  toArray() {
    <span class="hljs-keyword">return</span> [...this.items];
  }
}

<span class="hljs-comment">// Stack Implementation using Linked List</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(data) {
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedStack</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.top = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Push element</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  push(data) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> StackNode(data);
    newNode.next = <span class="hljs-keyword">this</span>.top;
    <span class="hljs-keyword">this</span>.top = newNode;
    <span class="hljs-keyword">this</span>.count++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;
  }

  <span class="hljs-comment">// Pop element</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  pop() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Stack is empty"</span>);
    }

    <span class="hljs-keyword">const</span> poppedData = <span class="hljs-keyword">this</span>.top.data;
    <span class="hljs-keyword">this</span>.top = <span class="hljs-keyword">this</span>.top.next;
    <span class="hljs-keyword">this</span>.count--;
    <span class="hljs-keyword">return</span> poppedData;
  }

  <span class="hljs-comment">// Peek at top</span>
  peek() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Stack is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.top.data;
  }

  isEmpty() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.top === <span class="hljs-literal">null</span>;
  }

  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;
  }
}

<span class="hljs-comment">// Queue Implementation using Array</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.items = [];
  }

  <span class="hljs-comment">// Add element to rear</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  enqueue(element) {
    <span class="hljs-keyword">this</span>.items.push(element);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size();
  }

  <span class="hljs-comment">// Remove element from front</span>
  <span class="hljs-comment">// Time: O(n) due to array shift, Space: O(1)</span>
  dequeue() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.shift();
  }

  <span class="hljs-comment">// View front element</span>
  front() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-number">0</span>];
  }

  <span class="hljs-comment">// View rear element</span>
  rear() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.items.length - <span class="hljs-number">1</span>];
  }

  isEmpty() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length === <span class="hljs-number">0</span>;
  }

  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length;
  }

  toArray() {
    <span class="hljs-keyword">return</span> [...this.items];
  }
}

<span class="hljs-comment">// Optimized Queue using Two Pointers</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimizedQueue</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.items = [];
    <span class="hljs-keyword">this</span>.frontIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.rearIndex = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Enqueue operation</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  enqueue(element) {
    <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.rearIndex] = element;
    <span class="hljs-keyword">this</span>.rearIndex++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size();
  }

  <span class="hljs-comment">// Dequeue operation</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  dequeue() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is empty"</span>);
    }

    <span class="hljs-keyword">const</span> dequeuedElement = <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.frontIndex];
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.frontIndex];
    <span class="hljs-keyword">this</span>.frontIndex++;

    <span class="hljs-comment">// Reset pointers when queue becomes empty</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.frontIndex === <span class="hljs-keyword">this</span>.rearIndex) {
      <span class="hljs-keyword">this</span>.frontIndex = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">this</span>.rearIndex = <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">return</span> dequeuedElement;
  }

  front() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.frontIndex];
  }

  isEmpty() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.frontIndex === <span class="hljs-keyword">this</span>.rearIndex;
  }

  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.rearIndex - <span class="hljs-keyword">this</span>.frontIndex;
  }
}

<span class="hljs-comment">// Circular Queue Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> </span>{
  <span class="hljs-keyword">constructor</span>(capacity) {
    <span class="hljs-keyword">this</span>.capacity = capacity;
    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(capacity);
    <span class="hljs-keyword">this</span>.front = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">this</span>.rear = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Check if queue is full</span>
  isFull() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count === <span class="hljs-keyword">this</span>.capacity;
  }

  isEmpty() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count === <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Enqueue operation</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  enqueue(element) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isFull()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is full"</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">this</span>.front = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">this</span>.rear = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.rear = (<span class="hljs-keyword">this</span>.rear + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.capacity;
    }

    <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.rear] = element;
    <span class="hljs-keyword">this</span>.count++;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;
  }

  <span class="hljs-comment">// Dequeue operation</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  dequeue() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is empty"</span>);
    }

    <span class="hljs-keyword">const</span> dequeuedElement = <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.front];
    <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.front] = <span class="hljs-literal">undefined</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.front = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">this</span>.rear = <span class="hljs-number">-1</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.front = (<span class="hljs-keyword">this</span>.front + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.capacity;
    }

    <span class="hljs-keyword">this</span>.count--;
    <span class="hljs-keyword">return</span> dequeuedElement;
  }

  getFront() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.front];
  }

  getRear() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Queue is empty"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.rear];
  }

  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;
  }

  display() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) {
      <span class="hljs-keyword">return</span> [];
    }

    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">let</span> i = <span class="hljs-keyword">this</span>.front;
    <span class="hljs-keyword">let</span> itemsAdded = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (itemsAdded &lt; <span class="hljs-keyword">this</span>.count) {
      result.push(<span class="hljs-keyword">this</span>.items[i]);
      i = (i + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.capacity;
      itemsAdded++;
    }

    <span class="hljs-keyword">return</span> result;
  }
}

<span class="hljs-comment">// Stack Applications</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackApplications</span> </span>{
  <span class="hljs-comment">// Check balanced parentheses</span>
  <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
  <span class="hljs-keyword">static</span> isBalanced(expression) {
    <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack();
    <span class="hljs-keyword">const</span> pairs = {
      <span class="hljs-string">")"</span>: <span class="hljs-string">"("</span>,
      <span class="hljs-string">"}"</span>: <span class="hljs-string">"{"</span>,
      <span class="hljs-string">"]"</span>: <span class="hljs-string">"["</span>,
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> expression) {
      <span class="hljs-keyword">if</span> (char === <span class="hljs-string">"("</span> || char === <span class="hljs-string">"{"</span> || char === <span class="hljs-string">"["</span>) {
        stack.push(char);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">")"</span> || char === <span class="hljs-string">"}"</span> || char === <span class="hljs-string">"]"</span>) {
        <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.pop() !== pairs[char]) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
    }

    <span class="hljs-keyword">return</span> stack.isEmpty();
  }

  <span class="hljs-comment">// Convert infix to postfix</span>
  <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
  <span class="hljs-keyword">static</span> infixToPostfix(infix) {
    <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack();
    <span class="hljs-keyword">let</span> postfix = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">const</span> precedence = {
      <span class="hljs-string">"+"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-string">"-"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-string">"*"</span>: <span class="hljs-number">2</span>,
      <span class="hljs-string">"/"</span>: <span class="hljs-number">2</span>,
      <span class="hljs-string">"^"</span>: <span class="hljs-number">3</span>,
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> infix) {
      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/[a-zA-Z0-9]/</span>.test(char)) {
        postfix += char;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">"("</span>) {
        stack.push(char);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">")"</span>) {
        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() !== <span class="hljs-string">"("</span>) {
          postfix += stack.pop();
        }
        stack.pop(); <span class="hljs-comment">// Remove '('</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (precedence[char]) {
        <span class="hljs-keyword">while</span> (
          !stack.isEmpty() &amp;&amp;
          stack.peek() !== <span class="hljs-string">"("</span> &amp;&amp;
          precedence[stack.peek()] &gt;= precedence[char]
        ) {
          postfix += stack.pop();
        }
        stack.push(char);
      }
    }

    <span class="hljs-keyword">while</span> (!stack.isEmpty()) {
      postfix += stack.pop();
    }

    <span class="hljs-keyword">return</span> postfix;
  }

  <span class="hljs-comment">// Evaluate postfix expression</span>
  <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
  <span class="hljs-keyword">static</span> evaluatePostfix(postfix) {
    <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> postfix) {
      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\d/</span>.test(char)) {
        stack.push(<span class="hljs-built_in">parseInt</span>(char));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">const</span> b = stack.pop();
        <span class="hljs-keyword">const</span> a = stack.pop();

        <span class="hljs-keyword">switch</span> (char) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">"+"</span>:
            stack.push(a + b);
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">"-"</span>:
            stack.push(a - b);
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">"*"</span>:
            stack.push(a * b);
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">"/"</span>:
            stack.push(<span class="hljs-built_in">Math</span>.floor(a / b));
            <span class="hljs-keyword">break</span>;
        }
      }
    }

    <span class="hljs-keyword">return</span> stack.pop();
  }
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Stack Demo ==="</span>);
<span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack();
stack.push(<span class="hljs-number">1</span>);
stack.push(<span class="hljs-number">2</span>);
stack.push(<span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Stack:"</span>, stack.toArray()); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Pop:"</span>, stack.pop()); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Peek:"</span>, stack.peek()); <span class="hljs-comment">// 2</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Queue Demo ==="</span>);
<span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue();
queue.enqueue(<span class="hljs-string">"A"</span>);
queue.enqueue(<span class="hljs-string">"B"</span>);
queue.enqueue(<span class="hljs-string">"C"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Queue:"</span>, queue.toArray()); <span class="hljs-comment">// ['A', 'B', 'C']</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Dequeue:"</span>, queue.dequeue()); <span class="hljs-comment">// 'A'</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Front:"</span>, queue.front()); <span class="hljs-comment">// 'B'</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Circular Queue Demo ==="</span>);
<span class="hljs-keyword">const</span> circularQueue = <span class="hljs-keyword">new</span> CircularQueue(<span class="hljs-number">3</span>);
circularQueue.enqueue(<span class="hljs-number">1</span>);
circularQueue.enqueue(<span class="hljs-number">2</span>);
circularQueue.enqueue(<span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Circular Queue:"</span>, circularQueue.display()); <span class="hljs-comment">// [1, 2, 3]</span>
circularQueue.dequeue();
circularQueue.enqueue(<span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"After dequeue and enqueue:"</span>, circularQueue.display()); <span class="hljs-comment">// [2, 3, 4]</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Stack Applications ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Balanced "({[]})": '</span>, StackApplications.isBalanced(<span class="hljs-string">"({[]})"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'Infix "A+B*C" to postfix:'</span>,
  StackApplications.infixToPostfix(<span class="hljs-string">"A+B*C"</span>)
); <span class="hljs-comment">// ABC*+</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Evaluate "23*4+":'</span>, StackApplications.evaluatePostfix(<span class="hljs-string">"23*4+"</span>)); <span class="hljs-comment">// 10</span>
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdexcept&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Stack Implementation using Array</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">vector</span>&lt;T&gt; items;

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Push element to top</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; element)</span> </span>{
        items.push_back(element);
    }

    <span class="hljs-comment">// Pop element from top</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Stack is empty"</span>);
        }

        T topElement = items.back();
        items.pop_back();
        <span class="hljs-keyword">return</span> topElement;
    }

    <span class="hljs-comment">// Peek at top element</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function">T <span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Stack is empty"</span>);
        }
        <span class="hljs-keyword">return</span> items.back();
    }

    <span class="hljs-comment">// Check if stack is empty</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> items.empty();
    }

    <span class="hljs-comment">// Get stack size</span>
    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> items.size();
    }

    <span class="hljs-comment">// Display stack</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Stack (top to bottom): ["</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = items.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-built_in">cout</span> &lt;&lt; items[i];
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">", "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};

<span class="hljs-comment">// Stack Implementation using Linked List</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> {</span>
    T data;
    StackNode* next;

    StackNode(<span class="hljs-keyword">const</span> T&amp; value) : data(value), next(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedStack</span> {</span>
<span class="hljs-keyword">private</span>:
    StackNode&lt;T&gt;* top;
    <span class="hljs-keyword">size_t</span> count;

<span class="hljs-keyword">public</span>:
    LinkedStack() : top(<span class="hljs-literal">nullptr</span>), count(<span class="hljs-number">0</span>) {}

    <span class="hljs-comment">// Destructor</span>
    ~LinkedStack() {
        clear();
    }

    <span class="hljs-comment">// Push element</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; data)</span> </span>{
        StackNode&lt;T&gt;* newNode = <span class="hljs-keyword">new</span> StackNode&lt;T&gt;(data);
        newNode-&gt;next = top;
        top = newNode;
        count++;
    }

    <span class="hljs-comment">// Pop element</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Stack is empty"</span>);
        }

        T poppedData = top-&gt;data;
        StackNode&lt;T&gt;* temp = top;
        top = top-&gt;next;
        <span class="hljs-keyword">delete</span> temp;
        count--;
        <span class="hljs-keyword">return</span> poppedData;
    }

    <span class="hljs-comment">// Peek at top</span>
    <span class="hljs-function">T <span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Stack is empty"</span>);
        }
        <span class="hljs-keyword">return</span> top-&gt;data;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> top == <span class="hljs-literal">nullptr</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> count;
    }

    <span class="hljs-comment">// Clear all elements</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (!isEmpty()) {
            pop();
        }
    }
};

<span class="hljs-comment">// Circular Queue Implementation</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">vector</span>&lt;T&gt; items;
    <span class="hljs-keyword">int</span> front;
    <span class="hljs-keyword">int</span> rear;
    <span class="hljs-keyword">int</span> capacity;
    <span class="hljs-keyword">int</span> count;

<span class="hljs-keyword">public</span>:
    CircularQueue(<span class="hljs-keyword">int</span> cap) : capacity(cap), front(<span class="hljs-number">-1</span>), rear(<span class="hljs-number">-1</span>), count(<span class="hljs-number">0</span>) {
        items.resize(capacity);
    }

    <span class="hljs-comment">// Check if queue is full</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> count == capacity;
    }

    <span class="hljs-comment">// Check if queue is empty</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// Enqueue operation</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; element)</span> </span>{
        <span class="hljs-keyword">if</span> (isFull()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Queue is full"</span>);
        }

        <span class="hljs-keyword">if</span> (isEmpty()) {
            front = <span class="hljs-number">0</span>;
            rear = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> {
            rear = (rear + <span class="hljs-number">1</span>) % capacity;
        }

        items[rear] = element;
        count++;
    }

    <span class="hljs-comment">// Dequeue operation</span>
    <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
    <span class="hljs-function">T <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Queue is empty"</span>);
        }

        T dequeuedElement = items[front];

        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) {
            front = <span class="hljs-number">-1</span>;
            rear = <span class="hljs-number">-1</span>;
        } <span class="hljs-keyword">else</span> {
            front = (front + <span class="hljs-number">1</span>) % capacity;
        }

        count--;
        <span class="hljs-keyword">return</span> dequeuedElement;
    }

    <span class="hljs-comment">// Get front element</span>
    <span class="hljs-function">T <span class="hljs-title">getFront</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Queue is empty"</span>);
        }
        <span class="hljs-keyword">return</span> items[front];
    }

    <span class="hljs-comment">// Get rear element</span>
    <span class="hljs-function">T <span class="hljs-title">getRear</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Queue is empty"</span>);
        }
        <span class="hljs-keyword">return</span> items[rear];
    }

    <span class="hljs-comment">// Get size</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> count;
    }

    <span class="hljs-comment">// Display queue</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Queue is empty"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Queue: ["</span>;
        <span class="hljs-keyword">int</span> i = front;
        <span class="hljs-keyword">int</span> itemsDisplayed = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">while</span> (itemsDisplayed &lt; count) {
            <span class="hljs-built_in">cout</span> &lt;&lt; items[i];
            <span class="hljs-keyword">if</span> (itemsDisplayed &lt; count - <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">", "</span>;
            i = (i + <span class="hljs-number">1</span>) % capacity;
            itemsDisplayed++;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};

<span class="hljs-comment">// Stack Applications</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackApplications</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Check balanced parentheses</span>
    <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; expression)</span> </span>{
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; s;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : expression) {
            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'('</span> || ch == <span class="hljs-string">'{'</span> || ch == <span class="hljs-string">'['</span>) {
                s.push(ch);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">')'</span> || ch == <span class="hljs-string">'}'</span> || ch == <span class="hljs-string">']'</span>) {
                <span class="hljs-keyword">if</span> (s.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

                <span class="hljs-keyword">char</span> top = s.top();
                s.pop();

                <span class="hljs-keyword">if</span> ((ch == <span class="hljs-string">')'</span> &amp;&amp; top != <span class="hljs-string">'('</span>) ||
                    (ch == <span class="hljs-string">'}'</span> &amp;&amp; top != <span class="hljs-string">'{'</span>) ||
                    (ch == <span class="hljs-string">']'</span> &amp;&amp; top != <span class="hljs-string">'['</span>)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
        }

        <span class="hljs-keyword">return</span> s.empty();
    }

    <span class="hljs-comment">// Get precedence of operator</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPrecedence</span><span class="hljs-params">(<span class="hljs-keyword">char</span> op)</span> </span>{
        <span class="hljs-keyword">switch</span> (op) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-comment">// Convert infix to postfix</span>
    <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">infixToPostfix</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; infix)</span> </span>{
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; s;
        <span class="hljs-built_in">string</span> postfix = <span class="hljs-string">""</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : infix) {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalnum</span>(ch)) {
                postfix += ch;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'('</span>) {
                s.push(ch);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">')'</span>) {
                <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top() != <span class="hljs-string">'('</span>) {
                    postfix += s.top();
                    s.pop();
                }
                <span class="hljs-keyword">if</span> (!s.empty()) s.pop(); <span class="hljs-comment">// Remove '('</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getPrecedence(ch) &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp;
                       s.top() != <span class="hljs-string">'('</span> &amp;&amp;
                       getPrecedence(s.top()) &gt;= getPrecedence(ch)) {
                    postfix += s.top();
                    s.pop();
                }
                s.push(ch);
            }
        }

        <span class="hljs-keyword">while</span> (!s.empty()) {
            postfix += s.top();
            s.pop();
        }

        <span class="hljs-keyword">return</span> postfix;
    }

    <span class="hljs-comment">// Evaluate postfix expression</span>
    <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evaluatePostfix</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; postfix)</span> </span>{
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : postfix) {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(ch)) {
                s.push(ch - <span class="hljs-string">'0'</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">int</span> b = s.top(); s.pop();
                <span class="hljs-keyword">int</span> a = s.top(); s.pop();

                <span class="hljs-keyword">switch</span> (ch) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>: s.push(a + b); <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>: s.push(a - b); <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>: s.push(a * b); <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>: s.push(a / b); <span class="hljs-keyword">break</span>;
                }
            }
        }

        <span class="hljs-keyword">return</span> s.top();
    }
};

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Array Stack Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    ArrayStack&lt;<span class="hljs-keyword">int</span>&gt; arrayStack;
    arrayStack.push(<span class="hljs-number">1</span>);
    arrayStack.push(<span class="hljs-number">2</span>);
    arrayStack.push(<span class="hljs-number">3</span>);
    arrayStack.display();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Pop: "</span> &lt;&lt; arrayStack.pop() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Peek: "</span> &lt;&lt; arrayStack.peek() &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Linked Stack Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    LinkedStack&lt;<span class="hljs-built_in">string</span>&gt; linkedStack;
    linkedStack.push(<span class="hljs-string">"First"</span>);
    linkedStack.push(<span class="hljs-string">"Second"</span>);
    linkedStack.push(<span class="hljs-string">"Third"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Size: "</span> &lt;&lt; linkedStack.size() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Pop: "</span> &lt;&lt; linkedStack.pop() &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Circular Queue Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-function">CircularQueue&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cq</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;
    cq.enqueue(<span class="hljs-number">1</span>);
    cq.enqueue(<span class="hljs-number">2</span>);
    cq.enqueue(<span class="hljs-number">3</span>);
    cq.display();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Dequeue: "</span> &lt;&lt; cq.dequeue() &lt;&lt; <span class="hljs-built_in">endl</span>;
    cq.enqueue(<span class="hljs-number">4</span>);
    cq.display();

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Stack Applications ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Balanced \"({[]})\": "</span> &lt;&lt; (StackApplications::isBalanced(<span class="hljs-string">"({[]})"</span>) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Infix \"A+B*C\" to postfix: "</span> &lt;&lt; StackApplications::infixToPostfix(<span class="hljs-string">"A+B*C"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Evaluate \"23*4+\": "</span> &lt;&lt; StackApplications::evaluatePostfix(<span class="hljs-string">"23*4+"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity">Time Complexity:</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Array Stack</th>
<th>Linked Stack</th>
<th>Array Queue</th>
<th>Circular Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td>Push/Enqueue</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Pop/Dequeue</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)*</td>
<td>O(1)</td>
</tr>
<tr>
<td>Peek/Front</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>*Array queue dequeue is O(n) due to shifting elements</p>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>Array-based</strong>: O(n) where n is the number of elements</li>
<li><strong>Linked-based</strong>: O(n) + pointer overhead</li>
<li><strong>Circular Queue</strong>: O(k) where k is the fixed capacity</li>
</ul>
<h3 id="common-pitfalls">Common Pitfalls:</h3>
<ol>
<li><strong>Stack overflow</strong>: Pushing too many elements</li>
<li><strong>Queue overflow</strong>: In fixed-size implementations</li>
<li><strong>Underflow</strong>: Popping from empty structures</li>
<li><strong>Memory leaks</strong>: Not properly deallocating in C++</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-valid-parentheses">Problem 1: Valid Parentheses</h3>
<p><strong>Question</strong>: Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.</p>
<p><strong>Solution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">const</span> stack = [];
  <span class="hljs-keyword">const</span> map = { <span class="hljs-string">")"</span>: <span class="hljs-string">"("</span>, <span class="hljs-string">"}"</span>: <span class="hljs-string">"{"</span>, <span class="hljs-string">"]"</span>: <span class="hljs-string">"["</span> };

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> s) {
    <span class="hljs-keyword">if</span> (char <span class="hljs-keyword">in</span> map) {
      <span class="hljs-keyword">if</span> (stack.pop() !== map[char]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
      stack.push(char);
    }
  }

  <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="problem-2-implement-queue-using-stacks">Problem 2: Implement Queue using Stacks</h3>
<p><strong>Question</strong>: Implement a first in first out (FIFO) queue using only two stacks.</p>
<p><strong>Hint</strong>: Use one stack for enqueue and another for dequeue operations.</p>
<h3 id="problem-3-next-greater-element">Problem 3: Next Greater Element</h3>
<p><strong>Question</strong>: Find the next greater element for each element in an array.</p>
<p><strong>Hint</strong>: Use a stack to keep track of elements for which we haven't found the next greater element yet.</p>
<h3 id="problem-4-sliding-window-maximum">Problem 4: Sliding Window Maximum</h3>
<p><strong>Question</strong>: Find the maximum element in each sliding window of size k.</p>
<p><strong>Hint</strong>: Use a deque to maintain elements in decreasing order.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Understanding of LIFO/FIFO</strong>: Can you explain the principles clearly?</li>
<li><strong>Implementation choices</strong>: When to use array vs. linked list?</li>
<li><strong>Edge case handling</strong>: Empty structures, overflow/underflow</li>
<li><strong>Application knowledge</strong>: Real-world uses of stacks and queues</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Monotonic Stack</strong>: For next greater/smaller element problems</li>
<li><strong>Two Stacks</strong>: To implement queue or undo/redo functionality</li>
<li><strong>BFS with Queue</strong>: Level-order traversal, shortest path</li>
<li><strong>DFS with Stack</strong>: Tree/graph traversal, backtracking</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Not checking for empty structures before operations</li>
<li>Confusing LIFO and FIFO principles</li>
<li>Not considering space complexity in recursive solutions</li>
<li>Implementing inefficient queue operations</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Visualize the operations</strong>: Draw the stack/queue state</li>
<li><strong>Consider circular arrays</strong>: For efficient queue implementation</li>
<li><strong>Think about applications</strong>: Expression evaluation, BFS/DFS</li>
<li><strong>Practice with constraints</strong>: Fixed size vs. dynamic size</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Stacks are perfect for LIFO scenarios</strong> - Function calls, undo operations</li>
<li><strong>Queues excel at FIFO processing</strong> - Task scheduling, BFS</li>
<li><strong>Circular queues optimize space</strong> - Better than simple array queues</li>
<li><strong>Choose implementation wisely</strong> - Array vs. linked list trade-offs</li>
<li><strong>Master the applications</strong> - Expression evaluation, parentheses matching</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Hash Tables/Maps and learn about efficient key-value storage and retrieval.</p>
<h1 id="chapter-4-hash-tables--maps---efficient-key-value-storage">Chapter 4: Hash Tables &amp; Maps - Efficient Key-Value Storage</h1>
<h2 id="%F0%9F%8E%AF-what-are-hash-tables">🎯 What Are Hash Tables?</h2>
<p><strong>Hash Tables</strong> (also called Hash Maps) are data structures that implement an associative array abstract data type, mapping keys to values. They use a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.</p>
<h3 id="why-hash-tables-matter">Why Hash Tables Matter:</h3>
<ul>
<li><strong>Fast Access</strong>: Average O(1) time for search, insert, and delete</li>
<li><strong>Flexible Keys</strong>: Can use strings, numbers, or custom objects as keys</li>
<li><strong>Memory Efficient</strong>: Direct indexing eliminates need for comparisons</li>
<li><strong>Ubiquitous</strong>: Foundation for databases, caches, and many algorithms</li>
</ul>
<h3 id="core-concepts">Core Concepts:</h3>
<ol>
<li><strong>Hash Function</strong>: Converts keys into array indices</li>
<li><strong>Buckets</strong>: Array slots where key-value pairs are stored</li>
<li><strong>Collision</strong>: When two keys hash to the same index</li>
<li><strong>Load Factor</strong>: Ratio of stored elements to total capacity</li>
</ol>
<hr>
<h2 id="%F0%9F%94%8D-hash-functions--collision-resolution">🔍 Hash Functions &amp; Collision Resolution</h2>
<h3 id="hash-function-properties">Hash Function Properties:</h3>
<ul>
<li><strong>Deterministic</strong>: Same key always produces same hash</li>
<li><strong>Uniform Distribution</strong>: Spreads keys evenly across buckets</li>
<li><strong>Fast Computation</strong>: Should be quick to calculate</li>
<li><strong>Avalanche Effect</strong>: Small key changes cause large hash changes</li>
</ul>
<h3 id="collision-resolution-techniques">Collision Resolution Techniques:</h3>
<h4 id="1-separate-chaining-open-hashing">1. Separate Chaining (Open Hashing)</h4>
<ul>
<li>Each bucket contains a linked list of key-value pairs</li>
<li>Multiple elements can exist in the same bucket</li>
</ul>
<h4 id="2-open-addressing-closed-hashing">2. Open Addressing (Closed Hashing)</h4>
<ul>
<li>All elements stored in the hash table itself</li>
<li>When collision occurs, probe for next available slot</li>
<li><strong>Linear Probing</strong>: Check next slot sequentially</li>
<li><strong>Quadratic Probing</strong>: Check slots at quadratic intervals</li>
<li><strong>Double Hashing</strong>: Use second hash function for probing</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Hash Table with Separate Chaining</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTableChaining</span> </span>{
  <span class="hljs-keyword">constructor</span>(size = 10) {
    <span class="hljs-keyword">this</span>.size = size;
    <span class="hljs-keyword">this</span>.buckets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Initialize buckets as empty arrays</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
      <span class="hljs-keyword">this</span>.buckets[i] = [];
    }
  }

  <span class="hljs-comment">// Simple hash function</span>
  <span class="hljs-comment">// Time: O(k) where k is key length, Space: O(1)</span>
  hash(key) {
    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> keyStr = <span class="hljs-built_in">String</span>(key);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keyStr.length; i++) {
      hash = (hash + keyStr.charCodeAt(i) * (i + <span class="hljs-number">1</span>)) % <span class="hljs-keyword">this</span>.size;
    }

    <span class="hljs-keyword">return</span> hash;
  }

  <span class="hljs-comment">// Insert or update key-value pair</span>
  <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
  <span class="hljs-keyword">set</span>(key, value) {
    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.hash(key);
    <span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">this</span>.buckets[index];

    <span class="hljs-comment">// Check if key already exists</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) {
      <span class="hljs-keyword">if</span> (bucket[i][<span class="hljs-number">0</span>] === key) {
        bucket[i][<span class="hljs-number">1</span>] = value; <span class="hljs-comment">// Update existing</span>
        <span class="hljs-keyword">return</span>;
      }
    }

    <span class="hljs-comment">// Add new key-value pair</span>
    bucket.push([key, value]);
    <span class="hljs-keyword">this</span>.count++;

    <span class="hljs-comment">// Resize if load factor exceeds threshold</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt; <span class="hljs-keyword">this</span>.size * <span class="hljs-number">0.75</span>) {
      <span class="hljs-keyword">this</span>.resize();
    }
  }

  <span class="hljs-comment">// Get value by key</span>
  <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
  <span class="hljs-keyword">get</span>(key) {
    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.hash(key);
    <span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">this</span>.buckets[index];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) {
      <span class="hljs-keyword">if</span> (bucket[i][<span class="hljs-number">0</span>] === key) {
        <span class="hljs-keyword">return</span> bucket[i][<span class="hljs-number">1</span>];
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-comment">// Check if key exists</span>
  <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
  has(key) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(key) !== <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-comment">// Delete key-value pair</span>
  <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
  <span class="hljs-keyword">delete</span>(key) {
    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.hash(key);
    <span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">this</span>.buckets[index];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) {
      <span class="hljs-keyword">if</span> (bucket[i][<span class="hljs-number">0</span>] === key) {
        bucket.splice(i, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">this</span>.count--;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Get all keys</span>
  keys() {
    <span class="hljs-keyword">const</span> keys = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bucket <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.buckets) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key] <span class="hljs-keyword">of</span> bucket) {
        keys.push(key);
      }
    }
    <span class="hljs-keyword">return</span> keys;
  }

  <span class="hljs-comment">// Get all values</span>
  values() {
    <span class="hljs-keyword">const</span> values = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bucket <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.buckets) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [, value] <span class="hljs-keyword">of</span> bucket) {
        values.push(value);
      }
    }
    <span class="hljs-keyword">return</span> values;
  }

  <span class="hljs-comment">// Resize hash table when load factor is high</span>
  resize() {
    <span class="hljs-keyword">const</span> oldBuckets = <span class="hljs-keyword">this</span>.buckets;
    <span class="hljs-keyword">this</span>.size *= <span class="hljs-number">2</span>;
    <span class="hljs-keyword">this</span>.buckets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">this</span>.size);
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Initialize new buckets</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.size; i++) {
      <span class="hljs-keyword">this</span>.buckets[i] = [];
    }

    <span class="hljs-comment">// Rehash all existing elements</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bucket <span class="hljs-keyword">of</span> oldBuckets) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> bucket) {
        <span class="hljs-keyword">this</span>.set(key, value);
      }
    }
  }

  <span class="hljs-comment">// Get load factor</span>
  getLoadFactor() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count / <span class="hljs-keyword">this</span>.size;
  }

  <span class="hljs-comment">// Display hash table structure</span>
  display() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hash Table Structure:"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.buckets.length; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buckets[i].length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Bucket <span class="hljs-subst">${i}</span>:`</span>, <span class="hljs-keyword">this</span>.buckets[i]);
      }
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Load Factor: <span class="hljs-subst">${<span class="hljs-keyword">this</span>.getLoadFactor().toFixed(<span class="hljs-number">2</span>)}</span>`</span>);
  }
}

<span class="hljs-comment">// Hash Table with Linear Probing</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTableLinearProbing</span> </span>{
  <span class="hljs-keyword">constructor</span>(size = 10) {
    <span class="hljs-keyword">this</span>.size = size;
    <span class="hljs-keyword">this</span>.keys = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);
    <span class="hljs-keyword">this</span>.values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Hash function</span>
  hash(key) {
    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> keyStr = <span class="hljs-built_in">String</span>(key);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keyStr.length; i++) {
      hash = (hash + keyStr.charCodeAt(i) * <span class="hljs-number">31</span>) % <span class="hljs-keyword">this</span>.size;
    }

    <span class="hljs-keyword">return</span> hash;
  }

  <span class="hljs-comment">// Insert or update key-value pair</span>
  <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
  <span class="hljs-keyword">set</span>(key, value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt;= <span class="hljs-keyword">this</span>.size * <span class="hljs-number">0.75</span>) {
      <span class="hljs-keyword">this</span>.resize();
    }

    <span class="hljs-keyword">let</span> index = <span class="hljs-keyword">this</span>.hash(key);

    <span class="hljs-comment">// Linear probing to find empty slot or existing key</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.keys[index] !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keys[index] === key) {
        <span class="hljs-keyword">this</span>.values[index] = value; <span class="hljs-comment">// Update existing</span>
        <span class="hljs-keyword">return</span>;
      }
      index = (index + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.size;
    }

    <span class="hljs-comment">// Insert new key-value pair</span>
    <span class="hljs-keyword">this</span>.keys[index] = key;
    <span class="hljs-keyword">this</span>.values[index] = value;
    <span class="hljs-keyword">this</span>.count++;
  }

  <span class="hljs-comment">// Get value by key</span>
  <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
  <span class="hljs-keyword">get</span>(key) {
    <span class="hljs-keyword">let</span> index = <span class="hljs-keyword">this</span>.hash(key);

    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.keys[index] !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keys[index] === key) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.values[index];
      }
      index = (index + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.size;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-comment">// Delete key-value pair</span>
  <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
  <span class="hljs-keyword">delete</span>(key) {
    <span class="hljs-keyword">let</span> index = <span class="hljs-keyword">this</span>.hash(key);

    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.keys[index] !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keys[index] === key) {
        <span class="hljs-keyword">this</span>.keys[index] = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">this</span>.values[index] = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">this</span>.count--;

        <span class="hljs-comment">// Rehash subsequent elements to maintain clustering</span>
        <span class="hljs-keyword">this</span>.rehashCluster(index);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      index = (index + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.size;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Rehash elements after deletion to maintain proper clustering</span>
  rehashCluster(deletedIndex) {
    <span class="hljs-keyword">let</span> index = (deletedIndex + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.size;

    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.keys[index] !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">const</span> keyToRehash = <span class="hljs-keyword">this</span>.keys[index];
      <span class="hljs-keyword">const</span> valueToRehash = <span class="hljs-keyword">this</span>.values[index];

      <span class="hljs-keyword">this</span>.keys[index] = <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">this</span>.values[index] = <span class="hljs-literal">undefined</span>;
      <span class="hljs-keyword">this</span>.count--;

      <span class="hljs-keyword">this</span>.set(keyToRehash, valueToRehash);
      index = (index + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.size;
    }
  }

  <span class="hljs-comment">// Resize hash table</span>
  resize() {
    <span class="hljs-keyword">const</span> oldKeys = <span class="hljs-keyword">this</span>.keys;
    <span class="hljs-keyword">const</span> oldValues = <span class="hljs-keyword">this</span>.values;

    <span class="hljs-keyword">this</span>.size *= <span class="hljs-number">2</span>;
    <span class="hljs-keyword">this</span>.keys = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">this</span>.size);
    <span class="hljs-keyword">this</span>.values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">this</span>.size);
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Rehash all existing elements</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; oldKeys.length; i++) {
      <span class="hljs-keyword">if</span> (oldKeys[i] !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">this</span>.set(oldKeys[i], oldValues[i]);
      }
    }
  }

  <span class="hljs-comment">// Check if key exists</span>
  has(key) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(key) !== <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-comment">// Get all keys</span>
  getKeys() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.keys.filter(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> key !== <span class="hljs-literal">undefined</span>);
  }

  <span class="hljs-comment">// Get load factor</span>
  getLoadFactor() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count / <span class="hljs-keyword">this</span>.size;
  }
}

<span class="hljs-comment">// Hash Set Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> HashTableChaining();
  }

  <span class="hljs-comment">// Add element to set</span>
  add(element) {
    <span class="hljs-keyword">this</span>.map.set(element, <span class="hljs-literal">true</span>);
  }

  <span class="hljs-comment">// Check if element exists</span>
  has(element) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map.has(element);
  }

  <span class="hljs-comment">// Remove element from set</span>
  <span class="hljs-keyword">delete</span>(element) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map.delete(element);
  }

  <span class="hljs-comment">// Get all elements</span>
  values() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map.keys();
  }

  <span class="hljs-comment">// Get size</span>
  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map.count;
  }

  <span class="hljs-comment">// Clear all elements</span>
  clear() {
    <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> HashTableChaining();
  }
}

<span class="hljs-comment">// Hash Table Applications</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTableApplications</span> </span>{
  <span class="hljs-comment">// Find two numbers that sum to target</span>
  <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
  <span class="hljs-keyword">static</span> twoSum(nums, target) {
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
      <span class="hljs-keyword">const</span> complement = target - nums[i];
      <span class="hljs-keyword">if</span> (map.has(complement)) {
        <span class="hljs-keyword">return</span> [map.get(complement), i];
      }
      map.set(nums[i], i);
    }

    <span class="hljs-keyword">return</span> [];
  }

  <span class="hljs-comment">// Group anagrams together</span>
  <span class="hljs-comment">// Time: O(n * k log k), Space: O(n * k)</span>
  <span class="hljs-keyword">static</span> groupAnagrams(strs) {
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> str <span class="hljs-keyword">of</span> strs) {
      <span class="hljs-keyword">const</span> sorted = str.split(<span class="hljs-string">""</span>).sort().join(<span class="hljs-string">""</span>);
      <span class="hljs-keyword">if</span> (!map.has(sorted)) {
        map.set(sorted, []);
      }
      map.get(sorted).push(str);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(map.values());
  }

  <span class="hljs-comment">// Find first non-repeating character</span>
  <span class="hljs-comment">// Time: O(n), Space: O(1) - limited character set</span>
  <span class="hljs-keyword">static</span> firstUniqueChar(s) {
    <span class="hljs-keyword">const</span> charCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-comment">// Count character frequencies</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> s) {
      charCount.set(char, (charCount.get(char) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// Find first character with count 1</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) {
      <span class="hljs-keyword">if</span> (charCount.get(s[i]) === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> i;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// Implement LRU Cache</span>
  <span class="hljs-keyword">static</span> createLRUCache(capacity) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LRUCache(capacity);
  }
}

<span class="hljs-comment">// LRU Cache Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>{
  <span class="hljs-keyword">constructor</span>(capacity) {
    <span class="hljs-keyword">this</span>.capacity = capacity;
    <span class="hljs-keyword">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  }

  <span class="hljs-comment">// Get value and mark as recently used</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  <span class="hljs-keyword">get</span>(key) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cache.has(key)) {
      <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">this</span>.cache.get(key);
      <span class="hljs-comment">// Move to end (most recently used)</span>
      <span class="hljs-keyword">this</span>.cache.delete(key);
      <span class="hljs-keyword">this</span>.cache.set(key, value);
      <span class="hljs-keyword">return</span> value;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// Put key-value pair</span>
  <span class="hljs-comment">// Time: O(1), Space: O(1)</span>
  put(key, value) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cache.has(key)) {
      <span class="hljs-comment">// Update existing key</span>
      <span class="hljs-keyword">this</span>.cache.delete(key);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cache.size &gt;= <span class="hljs-keyword">this</span>.capacity) {
      <span class="hljs-comment">// Remove least recently used (first item)</span>
      <span class="hljs-keyword">const</span> firstKey = <span class="hljs-keyword">this</span>.cache.keys().next().value;
      <span class="hljs-keyword">this</span>.cache.delete(firstKey);
    }

    <span class="hljs-keyword">this</span>.cache.set(key, value);
  }

  <span class="hljs-comment">// Display cache state</span>
  display() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"LRU Cache:"</span>, <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>.cache.entries()));
  }
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Hash Table with Chaining Demo ==="</span>);
<span class="hljs-keyword">const</span> hashTable = <span class="hljs-keyword">new</span> HashTableChaining(<span class="hljs-number">5</span>);
hashTable.set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"John"</span>);
hashTable.set(<span class="hljs-string">"age"</span>, <span class="hljs-number">30</span>);
hashTable.set(<span class="hljs-string">"city"</span>, <span class="hljs-string">"New York"</span>);
hashTable.set(<span class="hljs-string">"country"</span>, <span class="hljs-string">"USA"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Get name:"</span>, hashTable.get(<span class="hljs-string">"name"</span>)); <span class="hljs-comment">// John</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Has age:"</span>, hashTable.has(<span class="hljs-string">"age"</span>)); <span class="hljs-comment">// true</span>
hashTable.display();

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Hash Table with Linear Probing Demo ==="</span>);
<span class="hljs-keyword">const</span> hashTableLP = <span class="hljs-keyword">new</span> HashTableLinearProbing(<span class="hljs-number">7</span>);
hashTableLP.set(<span class="hljs-string">"apple"</span>, <span class="hljs-number">5</span>);
hashTableLP.set(<span class="hljs-string">"banana"</span>, <span class="hljs-number">3</span>);
hashTableLP.set(<span class="hljs-string">"orange"</span>, <span class="hljs-number">8</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Get apple:"</span>, hashTableLP.get(<span class="hljs-string">"apple"</span>)); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Load factor:"</span>, hashTableLP.getLoadFactor().toFixed(<span class="hljs-number">2</span>));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Hash Set Demo ==="</span>);
<span class="hljs-keyword">const</span> hashSet = <span class="hljs-keyword">new</span> HashSet();
hashSet.add(<span class="hljs-string">"red"</span>);
hashSet.add(<span class="hljs-string">"blue"</span>);
hashSet.add(<span class="hljs-string">"green"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Has red:"</span>, hashSet.has(<span class="hljs-string">"red"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Set values:"</span>, hashSet.values());

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Hash Table Applications ==="</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Two Sum [2,7,11,15], target 9:"</span>,
  HashTableApplications.twoSum([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], <span class="hljs-number">9</span>)
); <span class="hljs-comment">// [0,1]</span>
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Group Anagrams:"</span>,
  HashTableApplications.groupAnagrams([
    <span class="hljs-string">"eat"</span>,
    <span class="hljs-string">"tea"</span>,
    <span class="hljs-string">"tan"</span>,
    <span class="hljs-string">"ate"</span>,
    <span class="hljs-string">"nat"</span>,
    <span class="hljs-string">"bat"</span>,
  ])
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'First unique char in "leetcode":'</span>,
  HashTableApplications.firstUniqueChar(<span class="hljs-string">"leetcode"</span>)
); <span class="hljs-comment">// 0</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== LRU Cache Demo ==="</span>);
<span class="hljs-keyword">const</span> lru = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">2</span>);
lru.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
lru.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Get 1:"</span>, lru.get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 1</span>
lru.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// Evicts key 2</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Get 2:"</span>, lru.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">// -1 (not found)</span>
lru.display();
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Hash Table with Separate Chaining</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTableChaining</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span> {</span>
        K key;
        V value;
        KeyValue(<span class="hljs-keyword">const</span> K&amp; k, <span class="hljs-keyword">const</span> V&amp; v) : key(k), value(v) {}
    };

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">list</span>&lt;KeyValue&gt;&gt; buckets;
    <span class="hljs-keyword">size_t</span> bucket_count;
    <span class="hljs-keyword">size_t</span> size;

    <span class="hljs-comment">// Hash function for different types</span>
    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::hash&lt;K&gt;{}(key) % bucket_count;
    }

<span class="hljs-keyword">public</span>:
    HashTableChaining(<span class="hljs-keyword">size_t</span> initial_bucket_count = <span class="hljs-number">10</span>)
        : bucket_count(initial_bucket_count), size(<span class="hljs-number">0</span>) {
        buckets.resize(bucket_count);
    }

    <span class="hljs-comment">// Insert or update key-value pair</span>
    <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key, <span class="hljs-keyword">const</span> V&amp; value)</span> </span>{
        <span class="hljs-keyword">size_t</span> index = hash(key);
        <span class="hljs-keyword">auto</span>&amp; bucket = buckets[index];

        <span class="hljs-comment">// Check if key already exists</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; kv : bucket) {
            <span class="hljs-keyword">if</span> (kv.key == key) {
                kv.value = value; <span class="hljs-comment">// Update existing</span>
                <span class="hljs-keyword">return</span>;
            }
        }

        <span class="hljs-comment">// Add new key-value pair</span>
        bucket.emplace_back(key, value);
        size++;

        <span class="hljs-comment">// Resize if load factor exceeds threshold</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(size) / bucket_count &gt; <span class="hljs-number">0.75</span>) {
            resize();
        }
    }

    <span class="hljs-comment">// Get value by key</span>
    <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key, V&amp; value)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">size_t</span> index = hash(key);
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; bucket = buckets[index];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; kv : bucket) {
            <span class="hljs-keyword">if</span> (kv.key == key) {
                value = kv.value;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Check if key exists</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">has</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key)</span> <span class="hljs-keyword">const</span> </span>{
        V dummy;
        <span class="hljs-keyword">return</span> get(key, dummy);
    }

    <span class="hljs-comment">// Delete key-value pair</span>
    <span class="hljs-comment">// Average Time: O(1), Worst Time: O(n), Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key)</span> </span>{
        <span class="hljs-keyword">size_t</span> index = hash(key);
        <span class="hljs-keyword">auto</span>&amp; bucket = buckets[index];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = bucket.begin(); it != bucket.end(); ++it) {
            <span class="hljs-keyword">if</span> (it-&gt;key == key) {
                bucket.erase(it);
                size--;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Get all keys</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;K&gt; <span class="hljs-title">keys</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;K&gt; result;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; bucket : buckets) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; kv : bucket) {
                result.push_back(kv.key);
            }
        }
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Get load factor</span>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getLoadFactor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(size) / bucket_count;
    }

    <span class="hljs-comment">// Get size</span>
    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> size;
    }

    <span class="hljs-comment">// Display hash table structure</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hash Table Structure:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; buckets.size(); i++) {
            <span class="hljs-keyword">if</span> (!buckets[i].empty()) {
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bucket "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; kv : buckets[i]) {
                    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; kv.key &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; kv.value &lt;&lt; <span class="hljs-string">") "</span>;
                }
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
            }
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Load Factor: "</span> &lt;&lt; getLoadFactor() &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// Resize hash table when load factor is high</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">list</span>&lt;KeyValue&gt;&gt; old_buckets = move(buckets);
        bucket_count *= <span class="hljs-number">2</span>;
        buckets.clear();
        buckets.resize(bucket_count);
        size = <span class="hljs-number">0</span>;

        <span class="hljs-comment">// Rehash all existing elements</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; bucket : old_buckets) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; kv : bucket) {
                <span class="hljs-built_in">set</span>(kv.key, kv.value);
            }
        }
    }
};

<span class="hljs-comment">// Hash Table with Linear Probing</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTableLinearProbing</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Entry</span> {</span>
        K key;
        V value;
        <span class="hljs-keyword">bool</span> deleted;

        Entry() : deleted(<span class="hljs-literal">true</span>) {}
        Entry(<span class="hljs-keyword">const</span> K&amp; k, <span class="hljs-keyword">const</span> V&amp; v) : key(k), value(v), deleted(<span class="hljs-literal">false</span>) {}
    };

    <span class="hljs-built_in">vector</span>&lt;Entry&gt; table;
    <span class="hljs-keyword">size_t</span> capacity;
    <span class="hljs-keyword">size_t</span> size;

    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::hash&lt;K&gt;{}(key) % capacity;
    }

<span class="hljs-keyword">public</span>:
    HashTableLinearProbing(<span class="hljs-keyword">size_t</span> initial_capacity = <span class="hljs-number">10</span>)
        : capacity(initial_capacity), size(<span class="hljs-number">0</span>) {
        table.resize(capacity);
    }

    <span class="hljs-comment">// Insert or update key-value pair</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key, <span class="hljs-keyword">const</span> V&amp; value)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(size) / capacity &gt; <span class="hljs-number">0.75</span>) {
            resize();
        }

        <span class="hljs-keyword">size_t</span> index = hash(key);

        <span class="hljs-comment">// Linear probing to find empty slot or existing key</span>
        <span class="hljs-keyword">while</span> (!table[index].deleted) {
            <span class="hljs-keyword">if</span> (table[index].key == key) {
                table[index].value = value; <span class="hljs-comment">// Update existing</span>
                <span class="hljs-keyword">return</span>;
            }
            index = (index + <span class="hljs-number">1</span>) % capacity;
        }

        <span class="hljs-comment">// Insert new key-value pair</span>
        table[index] = Entry(key, value);
        size++;
    }

    <span class="hljs-comment">// Get value by key</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key, V&amp; value)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">size_t</span> index = hash(key);
        <span class="hljs-keyword">size_t</span> original_index = index;

        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> (table[index].deleted) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Empty slot found, key doesn't exist</span>
            }
            <span class="hljs-keyword">if</span> (table[index].key == key) {
                value = table[index].value;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            index = (index + <span class="hljs-number">1</span>) % capacity;
        } <span class="hljs-keyword">while</span> (index != original_index);

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Check if key exists</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">has</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key)</span> <span class="hljs-keyword">const</span> </span>{
        V dummy;
        <span class="hljs-keyword">return</span> get(key, dummy);
    }

    <span class="hljs-comment">// Delete key-value pair</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key)</span> </span>{
        <span class="hljs-keyword">size_t</span> index = hash(key);
        <span class="hljs-keyword">size_t</span> original_index = index;

        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> (table[index].deleted) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Empty slot found, key doesn't exist</span>
            }
            <span class="hljs-keyword">if</span> (table[index].key == key) {
                table[index].deleted = <span class="hljs-literal">true</span>;
                size--;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            index = (index + <span class="hljs-number">1</span>) % capacity;
        } <span class="hljs-keyword">while</span> (index != original_index);

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Get load factor</span>
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getLoadFactor</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(size) / capacity;
    }

    <span class="hljs-comment">// Get size</span>
    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> size;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// Resize hash table</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;Entry&gt; old_table = move(table);
        capacity *= <span class="hljs-number">2</span>;
        table.clear();
        table.resize(capacity);
        size = <span class="hljs-number">0</span>;

        <span class="hljs-comment">// Rehash all existing elements</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; entry : old_table) {
            <span class="hljs-keyword">if</span> (!entry.deleted) {
                <span class="hljs-built_in">set</span>(entry.key, entry.value);
            }
        }
    }
};

<span class="hljs-comment">// Hash Set Implementation</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span> {</span>
<span class="hljs-keyword">private</span>:
    HashTableChaining&lt;T, <span class="hljs-keyword">bool</span>&gt; table;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; element)</span> </span>{
        table.<span class="hljs-built_in">set</span>(element, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">has</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; element)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> table.has(element);
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; element)</span> </span>{
        <span class="hljs-keyword">return</span> table.remove(element);
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> table.keys();
    }

    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> table.getSize();
    }
};

<span class="hljs-comment">// Hash Table Applications</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTableApplications</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Find two numbers that sum to target</span>
    <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) {
            <span class="hljs-keyword">int</span> complement = target - nums[i];
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.find(complement) != <span class="hljs-built_in">map</span>.end()) {
                <span class="hljs-keyword">return</span> {<span class="hljs-built_in">map</span>[complement], i};
            }
            <span class="hljs-built_in">map</span>[nums[i]] = i;
        }

        <span class="hljs-keyword">return</span> {};
    }

    <span class="hljs-comment">// Group anagrams together</span>
    <span class="hljs-comment">// Time: O(n * k log k), Space: O(n * k)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> </span>{
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-built_in">map</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str : strs) {
            <span class="hljs-built_in">string</span> sorted = str;
            sort(sorted.begin(), sorted.end());
            <span class="hljs-built_in">map</span>[sorted].push_back(str);
        }

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; result;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : <span class="hljs-built_in">map</span>) {
            result.push_back(pair.second);
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Find first non-repeating character</span>
    <span class="hljs-comment">// Time: O(n), Space: O(1) - limited character set</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqueChar</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s)</span> </span>{
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; charCount;

        <span class="hljs-comment">// Count character frequencies</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s) {
            charCount[c]++;
        }

        <span class="hljs-comment">// Find first character with count 1</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {
            <span class="hljs-keyword">if</span> (charCount[s[i]] == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> i;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
};

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Hash Table with Chaining Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    HashTableChaining&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; hashTable;
    hashTable.<span class="hljs-built_in">set</span>(<span class="hljs-string">"apple"</span>, <span class="hljs-number">5</span>);
    hashTable.<span class="hljs-built_in">set</span>(<span class="hljs-string">"banana"</span>, <span class="hljs-number">3</span>);
    hashTable.<span class="hljs-built_in">set</span>(<span class="hljs-string">"orange"</span>, <span class="hljs-number">8</span>);

    <span class="hljs-keyword">int</span> value;
    <span class="hljs-keyword">if</span> (hashTable.get(<span class="hljs-string">"apple"</span>, value)) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Apple: "</span> &lt;&lt; value &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    hashTable.display();

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Hash Table with Linear Probing Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    HashTableLinearProbing&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; hashTableLP;
    hashTableLP.<span class="hljs-built_in">set</span>(<span class="hljs-string">"red"</span>, <span class="hljs-number">1</span>);
    hashTableLP.<span class="hljs-built_in">set</span>(<span class="hljs-string">"green"</span>, <span class="hljs-number">2</span>);
    hashTableLP.<span class="hljs-built_in">set</span>(<span class="hljs-string">"blue"</span>, <span class="hljs-number">3</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Load factor: "</span> &lt;&lt; hashTableLP.getLoadFactor() &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Hash Set Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    HashSet&lt;<span class="hljs-built_in">string</span>&gt; hashSet;
    hashSet.add(<span class="hljs-string">"cat"</span>);
    hashSet.add(<span class="hljs-string">"dog"</span>);
    hashSet.add(<span class="hljs-string">"bird"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Has cat: "</span> &lt;&lt; (hashSet.has(<span class="hljs-string">"cat"</span>) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set size: "</span> &lt;&lt; hashSet.size() &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Hash Table Applications ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>};
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result = HashTableApplications::twoSum(nums, <span class="hljs-number">9</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Two Sum result: ["</span> &lt;&lt; result[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; result[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"First unique char in 'leetcode': "</span>
         &lt;&lt; HashTableApplications::firstUniqueChar(<span class="hljs-string">"leetcode"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity">Time Complexity:</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Best Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>Search</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Insert</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Delete</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>Hash Table</strong>: O(n) where n is the number of key-value pairs</li>
<li><strong>Additional space per operation</strong>: O(1)</li>
</ul>
<h3 id="load-factor-impact">Load Factor Impact:</h3>
<ul>
<li><strong>Low load factor (&lt; 0.5)</strong>: Fewer collisions, more memory usage</li>
<li><strong>High load factor (&gt; 0.75)</strong>: More collisions, less memory usage</li>
<li><strong>Optimal range</strong>: 0.5 - 0.75 for good balance</li>
</ul>
<h3 id="collision-resolution-comparison">Collision Resolution Comparison:</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Separate Chaining</th>
<th>Linear Probing</th>
</tr>
</thead>
<tbody>
<tr>
<td>Memory</td>
<td>Higher (pointers)</td>
<td>Lower (no pointers)</td>
</tr>
<tr>
<td>Cache Performance</td>
<td>Poor</td>
<td>Better</td>
</tr>
<tr>
<td>Deletion</td>
<td>Easy</td>
<td>Complex</td>
</tr>
<tr>
<td>Load Factor Tolerance</td>
<td>Higher</td>
<td>Lower</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-two-sum">Problem 1: Two Sum</h3>
<p><strong>Question</strong>: Given an array of integers and a target, return indices of two numbers that add up to target.</p>
<p><strong>Solution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">nums, target</span>) </span>{
  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
    <span class="hljs-keyword">const</span> complement = target - nums[i];
    <span class="hljs-keyword">if</span> (map.has(complement)) {
      <span class="hljs-keyword">return</span> [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
  <span class="hljs-keyword">return</span> [];
}
</div></code></pre>
<h3 id="problem-2-group-anagrams">Problem 2: Group Anagrams</h3>
<p><strong>Question</strong>: Group strings that are anagrams of each other.</p>
<p><strong>Hint</strong>: Use sorted string as key in hash map.</p>
<h3 id="problem-3-longest-substring-without-repeating-characters">Problem 3: Longest Substring Without Repeating Characters</h3>
<p><strong>Question</strong>: Find the length of the longest substring without repeating characters.</p>
<p><strong>Hint</strong>: Use sliding window with hash set to track characters.</p>
<h3 id="problem-4-design-hashmap">Problem 4: Design HashMap</h3>
<p><strong>Question</strong>: Design a HashMap without using built-in hash table libraries.</p>
<p><strong>Hint</strong>: Implement with array of buckets and handle collisions.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Hash function understanding</strong>: Can you explain how hashing works?</li>
<li><strong>Collision handling</strong>: Knowledge of different resolution techniques</li>
<li><strong>Load factor awareness</strong>: Understanding of performance implications</li>
<li><strong>Real-world applications</strong>: When to use hash tables vs. other structures</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Frequency counting</strong>: Character/element frequency problems</li>
<li><strong>Two-pointer with hash</strong>: Finding pairs, triplets with specific sums</li>
<li><strong>Caching</strong>: LRU cache, memoization problems</li>
<li><strong>Grouping</strong>: Anagrams, similar strings, etc.</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Not considering hash collisions</li>
<li>Ignoring load factor and resizing</li>
<li>Using hash tables when order matters</li>
<li>Not handling edge cases (empty keys, null values)</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Understand trade-offs</strong>: Hash tables vs. trees vs. arrays</li>
<li><strong>Consider hash quality</strong>: Good distribution reduces collisions</li>
<li><strong>Think about resizing</strong>: When and how to resize</li>
<li><strong>Practice common patterns</strong>: Two sum, anagrams, frequency counting</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Hash tables provide O(1) average access</strong> - Excellent for lookups</li>
<li><strong>Hash function quality matters</strong> - Good distribution prevents clustering</li>
<li><strong>Handle collisions properly</strong> - Choose appropriate resolution method</li>
<li><strong>Monitor load factor</strong> - Resize when necessary for performance</li>
<li><strong>Perfect for many algorithms</strong> - Frequency counting, caching, grouping</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Trees and see how they provide hierarchical data organization with efficient search, insertion, and deletion operations.</p>
<h1 id="chapter-5-trees---hierarchical-data-structures">Chapter 5: Trees - Hierarchical Data Structures</h1>
<h2 id="%F0%9F%8E%AF-what-are-trees">🎯 What Are Trees?</h2>
<p><strong>Trees</strong> are hierarchical data structures consisting of nodes connected by edges. Unlike linear structures (arrays, linked lists), trees represent hierarchical relationships with a root node at the top and child nodes branching downward.</p>
<h3 id="why-trees-matter">Why Trees Matter:</h3>
<ul>
<li><strong>Hierarchical Organization</strong>: Natural representation of hierarchical data</li>
<li><strong>Efficient Search</strong>: O(log n) operations in balanced trees</li>
<li><strong>Flexible Structure</strong>: Can represent many real-world relationships</li>
<li><strong>Foundation</strong>: Basis for databases, file systems, and decision trees</li>
</ul>
<h3 id="tree-terminology">Tree Terminology:</h3>
<ul>
<li><strong>Root</strong>: Top node with no parent</li>
<li><strong>Parent</strong>: Node with child nodes</li>
<li><strong>Child</strong>: Node with a parent</li>
<li><strong>Leaf</strong>: Node with no children</li>
<li><strong>Height</strong>: Longest path from root to leaf</li>
<li><strong>Depth</strong>: Distance from root to a specific node</li>
<li><strong>Subtree</strong>: Tree formed by a node and its descendants</li>
</ul>
<hr>
<h2 id="%F0%9F%94%8D-types-of-trees">🔍 Types of Trees</h2>
<h3 id="1-binary-tree">1. Binary Tree</h3>
<ul>
<li>Each node has at most two children (left and right)</li>
<li>Foundation for many other tree types</li>
</ul>
<h3 id="2-binary-search-tree-bst">2. Binary Search Tree (BST)</h3>
<ul>
<li>Binary tree with ordering property</li>
<li>Left subtree values &lt; parent &lt; right subtree values</li>
<li>Enables efficient searching</li>
</ul>
<h3 id="3-complete-binary-tree">3. Complete Binary Tree</h3>
<ul>
<li>All levels filled except possibly the last</li>
<li>Last level filled from left to right</li>
</ul>
<h3 id="4-full-binary-tree">4. Full Binary Tree</h3>
<ul>
<li>Every node has either 0 or 2 children</li>
<li>No node has exactly one child</li>
</ul>
<h3 id="5-perfect-binary-tree">5. Perfect Binary Tree</h3>
<ul>
<li>All internal nodes have two children</li>
<li>All leaves are at the same level</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Binary Tree Node</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(data) {
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.left = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.right = <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-comment">// Binary Tree Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.root = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// Insert node (level-order insertion for complete tree)</span>
  <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
  insert(data) {
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> TreeNode(data);

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.root) {
      <span class="hljs-keyword">this</span>.root = newNode;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Use queue for level-order insertion</span>
    <span class="hljs-keyword">const</span> queue = [<span class="hljs-keyword">this</span>.root];

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> current = queue.shift();

      <span class="hljs-keyword">if</span> (!current.left) {
        current.left = newNode;
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!current.right) {
        current.right = newNode;
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> {
        queue.push(current.left);
        queue.push(current.right);
      }
    }
  }

  <span class="hljs-comment">// Search for a value</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h) where h is height</span>
  search(data, node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (node.data === data) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.search(data, node.left) || <span class="hljs-keyword">this</span>.search(data, node.right);
  }

  <span class="hljs-comment">// Get height of tree</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  getHeight(node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.getHeight(node.left), <span class="hljs-keyword">this</span>.getHeight(node.right));
  }

  <span class="hljs-comment">// Count total nodes</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  countNodes(node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-keyword">this</span>.countNodes(node.left) + <span class="hljs-keyword">this</span>.countNodes(node.right);
  }

  <span class="hljs-comment">// Check if tree is balanced</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  isBalanced(node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">const</span> leftHeight = <span class="hljs-keyword">this</span>.getHeight(node.left);
    <span class="hljs-keyword">const</span> rightHeight = <span class="hljs-keyword">this</span>.getHeight(node.right);

    <span class="hljs-keyword">return</span> (
      <span class="hljs-built_in">Math</span>.abs(leftHeight - rightHeight) &lt;= <span class="hljs-number">1</span> &amp;&amp;
      <span class="hljs-keyword">this</span>.isBalanced(node.left) &amp;&amp;
      <span class="hljs-keyword">this</span>.isBalanced(node.right)
    );
  }

  <span class="hljs-comment">// Find maximum value</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  findMax(node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">let</span> max = node.data;
    <span class="hljs-keyword">const</span> leftMax = <span class="hljs-keyword">this</span>.findMax(node.left);
    <span class="hljs-keyword">const</span> rightMax = <span class="hljs-keyword">this</span>.findMax(node.right);

    <span class="hljs-keyword">if</span> (leftMax !== <span class="hljs-literal">null</span> &amp;&amp; leftMax &gt; max) {
      max = leftMax;
    }
    <span class="hljs-keyword">if</span> (rightMax !== <span class="hljs-literal">null</span> &amp;&amp; rightMax &gt; max) {
      max = rightMax;
    }

    <span class="hljs-keyword">return</span> max;
  }

  <span class="hljs-comment">// Find minimum value</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  findMin(node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">let</span> min = node.data;
    <span class="hljs-keyword">const</span> leftMin = <span class="hljs-keyword">this</span>.findMin(node.left);
    <span class="hljs-keyword">const</span> rightMin = <span class="hljs-keyword">this</span>.findMin(node.right);

    <span class="hljs-keyword">if</span> (leftMin !== <span class="hljs-literal">null</span> &amp;&amp; leftMin &lt; min) {
      min = leftMin;
    }
    <span class="hljs-keyword">if</span> (rightMin !== <span class="hljs-literal">null</span> &amp;&amp; rightMin &lt; min) {
      min = rightMin;
    }

    <span class="hljs-keyword">return</span> min;
  }
}

<span class="hljs-comment">// Binary Search Tree Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.root = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// Insert node maintaining BST property</span>
  <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
  insert(data) {
    <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">this</span>.insertNode(<span class="hljs-keyword">this</span>.root, data);
  }

  insertNode(node, data) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(data);
    }

    <span class="hljs-keyword">if</span> (data &lt; node.data) {
      node.left = <span class="hljs-keyword">this</span>.insertNode(node.left, data);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; node.data) {
      node.right = <span class="hljs-keyword">this</span>.insertNode(node.right, data);
    }
    <span class="hljs-comment">// Ignore duplicates</span>

    <span class="hljs-keyword">return</span> node;
  }

  <span class="hljs-comment">// Search for a value</span>
  <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
  search(data, node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (data === node.data) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &lt; node.data) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.search(data, node.left);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.search(data, node.right);
    }
  }

  <span class="hljs-comment">// Find minimum value (leftmost node)</span>
  <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
  findMin(node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">while</span> (node.left) {
      node = node.left;
    }

    <span class="hljs-keyword">return</span> node.data;
  }

  <span class="hljs-comment">// Find maximum value (rightmost node)</span>
  <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
  findMax(node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">while</span> (node.right) {
      node = node.right;
    }

    <span class="hljs-keyword">return</span> node.data;
  }

  <span class="hljs-comment">// Delete node</span>
  <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
  <span class="hljs-keyword">delete</span>(data) {
    <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">this</span>.deleteNode(<span class="hljs-keyword">this</span>.root, data);
  }

  deleteNode(node, data) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (data &lt; node.data) {
      node.left = <span class="hljs-keyword">this</span>.deleteNode(node.left, data);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; node.data) {
      node.right = <span class="hljs-keyword">this</span>.deleteNode(node.right, data);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Node to be deleted found</span>

      <span class="hljs-comment">// Case 1: No children (leaf node)</span>
      <span class="hljs-keyword">if</span> (!node.left &amp;&amp; !node.right) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-comment">// Case 2: One child</span>
      <span class="hljs-keyword">if</span> (!node.left) {
        <span class="hljs-keyword">return</span> node.right;
      }
      <span class="hljs-keyword">if</span> (!node.right) {
        <span class="hljs-keyword">return</span> node.left;
      }

      <span class="hljs-comment">// Case 3: Two children</span>
      <span class="hljs-comment">// Find inorder successor (smallest in right subtree)</span>
      <span class="hljs-keyword">const</span> successor = <span class="hljs-keyword">this</span>.findMinNode(node.right);
      node.data = successor.data;
      node.right = <span class="hljs-keyword">this</span>.deleteNode(node.right, successor.data);
    }

    <span class="hljs-keyword">return</span> node;
  }

  <span class="hljs-comment">// Helper method to find minimum node</span>
  findMinNode(node) {
    <span class="hljs-keyword">while</span> (node.left) {
      node = node.left;
    }
    <span class="hljs-keyword">return</span> node;
  }

  <span class="hljs-comment">// Validate if tree is a valid BST</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  isValidBST(node = <span class="hljs-keyword">this</span>.root, min = <span class="hljs-literal">null</span>, max = <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (
      (min !== <span class="hljs-literal">null</span> &amp;&amp; node.data &lt;= min) ||
      (max !== <span class="hljs-literal">null</span> &amp;&amp; node.data &gt;= max)
    ) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> (
      <span class="hljs-keyword">this</span>.isValidBST(node.left, min, node.data) &amp;&amp;
      <span class="hljs-keyword">this</span>.isValidBST(node.right, node.data, max)
    );
  }

  <span class="hljs-comment">// Find kth smallest element</span>
  <span class="hljs-comment">// Time: O(k), Space: O(h)</span>
  kthSmallest(k) {
    <span class="hljs-keyword">const</span> result = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> };
    <span class="hljs-keyword">this</span>.inorderKth(<span class="hljs-keyword">this</span>.root, k, result);
    <span class="hljs-keyword">return</span> result.value;
  }

  inorderKth(node, k, result) {
    <span class="hljs-keyword">if</span> (!node || result.count &gt;= k) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">this</span>.inorderKth(node.left, k, result);

    result.count++;
    <span class="hljs-keyword">if</span> (result.count === k) {
      result.value = node.data;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">this</span>.inorderKth(node.right, k, result);
  }

  <span class="hljs-comment">// Find lowest common ancestor</span>
  <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
  findLCA(node1Data, node2Data, node = <span class="hljs-keyword">this</span>.root) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-comment">// If both nodes are smaller, LCA is in left subtree</span>
    <span class="hljs-keyword">if</span> (node1Data &lt; node.data &amp;&amp; node2Data &lt; node.data) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.findLCA(node1Data, node2Data, node.left);
    }

    <span class="hljs-comment">// If both nodes are larger, LCA is in right subtree</span>
    <span class="hljs-keyword">if</span> (node1Data &gt; node.data &amp;&amp; node2Data &gt; node.data) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.findLCA(node1Data, node2Data, node.right);
    }

    <span class="hljs-comment">// If one is smaller and one is larger, current node is LCA</span>
    <span class="hljs-keyword">return</span> node.data;
  }
}

<span class="hljs-comment">// Tree Traversal Methods</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeTraversal</span> </span>{
  <span class="hljs-comment">// Inorder Traversal (Left, Root, Right)</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  <span class="hljs-keyword">static</span> inorder(node, result = []) {
    <span class="hljs-keyword">if</span> (node) {
      TreeTraversal.inorder(node.left, result);
      result.push(node.data);
      TreeTraversal.inorder(node.right, result);
    }
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Preorder Traversal (Root, Left, Right)</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  <span class="hljs-keyword">static</span> preorder(node, result = []) {
    <span class="hljs-keyword">if</span> (node) {
      result.push(node.data);
      TreeTraversal.preorder(node.left, result);
      TreeTraversal.preorder(node.right, result);
    }
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Postorder Traversal (Left, Right, Root)</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  <span class="hljs-keyword">static</span> postorder(node, result = []) {
    <span class="hljs-keyword">if</span> (node) {
      TreeTraversal.postorder(node.left, result);
      TreeTraversal.postorder(node.right, result);
      result.push(node.data);
    }
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Level Order Traversal (Breadth-First)</span>
  <span class="hljs-comment">// Time: O(n), Space: O(w) where w is maximum width</span>
  <span class="hljs-keyword">static</span> levelOrder(root) {
    <span class="hljs-keyword">if</span> (!root) {
      <span class="hljs-keyword">return</span> [];
    }

    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> queue = [root];

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> levelSize = queue.length;
      <span class="hljs-keyword">const</span> currentLevel = [];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
        <span class="hljs-keyword">const</span> node = queue.shift();
        currentLevel.push(node.data);

        <span class="hljs-keyword">if</span> (node.left) queue.push(node.left);
        <span class="hljs-keyword">if</span> (node.right) queue.push(node.right);
      }

      result.push(currentLevel);
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Iterative Inorder Traversal</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  <span class="hljs-keyword">static</span> inorderIterative(root) {
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> stack = [];
    <span class="hljs-keyword">let</span> current = root;

    <span class="hljs-keyword">while</span> (current || stack.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// Go to leftmost node</span>
      <span class="hljs-keyword">while</span> (current) {
        stack.push(current);
        current = current.left;
      }

      <span class="hljs-comment">// Process current node</span>
      current = stack.pop();
      result.push(current.data);

      <span class="hljs-comment">// Move to right subtree</span>
      current = current.right;
    }

    <span class="hljs-keyword">return</span> result;
  }
}

<span class="hljs-comment">// Tree Applications</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeApplications</span> </span>{
  <span class="hljs-comment">// Build tree from inorder and preorder traversals</span>
  <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
  <span class="hljs-keyword">static</span> buildTreeFromTraversals(preorder, inorder) {
    <span class="hljs-keyword">if</span> (preorder.length === <span class="hljs-number">0</span> || inorder.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">const</span> rootVal = preorder[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> TreeNode(rootVal);
    <span class="hljs-keyword">const</span> rootIndex = inorder.indexOf(rootVal);

    <span class="hljs-keyword">const</span> leftInorder = inorder.slice(<span class="hljs-number">0</span>, rootIndex);
    <span class="hljs-keyword">const</span> rightInorder = inorder.slice(rootIndex + <span class="hljs-number">1</span>);

    <span class="hljs-keyword">const</span> leftPreorder = preorder.slice(<span class="hljs-number">1</span>, <span class="hljs-number">1</span> + leftInorder.length);
    <span class="hljs-keyword">const</span> rightPreorder = preorder.slice(<span class="hljs-number">1</span> + leftInorder.length);

    root.left = TreeApplications.buildTreeFromTraversals(
      leftPreorder,
      leftInorder
    );
    root.right = TreeApplications.buildTreeFromTraversals(
      rightPreorder,
      rightInorder
    );

    <span class="hljs-keyword">return</span> root;
  }

  <span class="hljs-comment">// Convert sorted array to balanced BST</span>
  <span class="hljs-comment">// Time: O(n), Space: O(log n)</span>
  <span class="hljs-keyword">static</span> sortedArrayToBST(nums) {
    <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(nums.length / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);

    root.left = TreeApplications.sortedArrayToBST(nums.slice(<span class="hljs-number">0</span>, mid));
    root.right = TreeApplications.sortedArrayToBST(nums.slice(mid + <span class="hljs-number">1</span>));

    <span class="hljs-keyword">return</span> root;
  }

  <span class="hljs-comment">// Find diameter of binary tree</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  <span class="hljs-keyword">static</span> diameterOfBinaryTree(root) {
    <span class="hljs-keyword">let</span> diameter = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">height</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

      <span class="hljs-keyword">const</span> leftHeight = height(node.left);
      <span class="hljs-keyword">const</span> rightHeight = height(node.right);

      <span class="hljs-comment">// Update diameter if path through current node is longer</span>
      diameter = <span class="hljs-built_in">Math</span>.max(diameter, leftHeight + rightHeight);

      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.max(leftHeight, rightHeight);
    }

    height(root);
    <span class="hljs-keyword">return</span> diameter;
  }

  <span class="hljs-comment">// Check if two trees are identical</span>
  <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
  <span class="hljs-keyword">static</span> isSameTree(p, q) {
    <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">return</span> (
      p.data === q.data &amp;&amp;
      TreeApplications.isSameTree(p.left, q.left) &amp;&amp;
      TreeApplications.isSameTree(p.right, q.right)
    );
  }
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Binary Tree Demo ==="</span>);
<span class="hljs-keyword">const</span> bt = <span class="hljs-keyword">new</span> BinaryTree();
bt.insert(<span class="hljs-number">1</span>);
bt.insert(<span class="hljs-number">2</span>);
bt.insert(<span class="hljs-number">3</span>);
bt.insert(<span class="hljs-number">4</span>);
bt.insert(<span class="hljs-number">5</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Tree height:"</span>, bt.getHeight()); <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Node count:"</span>, bt.countNodes()); <span class="hljs-comment">// 5</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Is balanced:"</span>, bt.isBalanced()); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Search 4:"</span>, bt.search(<span class="hljs-number">4</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Binary Search Tree Demo ==="</span>);
<span class="hljs-keyword">const</span> bst = <span class="hljs-keyword">new</span> BinarySearchTree();
[<span class="hljs-number">50</span>, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>, <span class="hljs-number">80</span>].forEach(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> bst.insert(val));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Search 40:"</span>, bst.search(<span class="hljs-number">40</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Min value:"</span>, bst.findMin()); <span class="hljs-comment">// 20</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Max value:"</span>, bst.findMax()); <span class="hljs-comment">// 80</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Is valid BST:"</span>, bst.isValidBST()); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"3rd smallest:"</span>, bst.kthSmallest(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 40</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"LCA of 20 and 40:"</span>, bst.findLCA(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// 30</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Tree Traversals ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Inorder:"</span>, TreeTraversal.inorder(bst.root)); <span class="hljs-comment">// [20, 30, 40, 50, 60, 70, 80]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Preorder:"</span>, TreeTraversal.preorder(bst.root)); <span class="hljs-comment">// [50, 30, 20, 40, 70, 60, 80]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Postorder:"</span>, TreeTraversal.postorder(bst.root)); <span class="hljs-comment">// [20, 40, 30, 60, 80, 70, 50]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Level order:"</span>, TreeTraversal.levelOrder(bst.root));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Tree Applications ==="</span>);
<span class="hljs-keyword">const</span> sortedArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
<span class="hljs-keyword">const</span> balancedBST = TreeApplications.sortedArrayToBST(sortedArray);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Balanced BST from sorted array:"</span>,
  TreeTraversal.inorder(balancedBST)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Diameter of tree:"</span>,
  TreeApplications.diameterOfBinaryTree(bst.root)
);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Binary Tree Node</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> {</span>
    <span class="hljs-keyword">int</span> data;
    TreeNode* left;
    TreeNode* right;

    TreeNode(<span class="hljs-keyword">int</span> val) : data(val), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-comment">// Binary Tree Class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> {</span>
<span class="hljs-keyword">public</span>:
    TreeNode* root;

    BinaryTree() : root(<span class="hljs-literal">nullptr</span>) {}

    <span class="hljs-comment">// Destructor to prevent memory leaks</span>
    ~BinaryTree() {
        destroyTree(root);
    }

    <span class="hljs-comment">// Insert node (level-order insertion)</span>
    <span class="hljs-comment">// Time: O(n), Space: O(n)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>{
        TreeNode* newNode = <span class="hljs-keyword">new</span> TreeNode(data);

        <span class="hljs-keyword">if</span> (!root) {
            root = newNode;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
        q.push(root);

        <span class="hljs-keyword">while</span> (!q.empty()) {
            TreeNode* current = q.front();
            q.pop();

            <span class="hljs-keyword">if</span> (!current-&gt;left) {
                current-&gt;left = newNode;
                <span class="hljs-keyword">return</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!current-&gt;right) {
                current-&gt;right = newNode;
                <span class="hljs-keyword">return</span>;
            } <span class="hljs-keyword">else</span> {
                q.push(current-&gt;left);
                q.push(current-&gt;right);
            }
        }
    }

    <span class="hljs-comment">// Search for a value</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data, TreeNode* node = <span class="hljs-literal">nullptr</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) node = root;
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (node-&gt;data == data) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">return</span> search(data, node-&gt;left) || search(data, node-&gt;right);
    }

    <span class="hljs-comment">// Get height of tree</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node = <span class="hljs-literal">nullptr</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) node = root;
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(getHeight(node-&gt;left), getHeight(node-&gt;right));
    }

    <span class="hljs-comment">// Count total nodes</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* node = <span class="hljs-literal">nullptr</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) node = root;
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(node-&gt;left) + countNodes(node-&gt;right);
    }

    <span class="hljs-comment">// Check if tree is balanced</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* node = <span class="hljs-literal">nullptr</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) node = root;
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">int</span> leftHeight = getHeight(node-&gt;left);
        <span class="hljs-keyword">int</span> rightHeight = getHeight(node-&gt;right);

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &lt;= <span class="hljs-number">1</span> &amp;&amp;
               isBalanced(node-&gt;left) &amp;&amp;
               isBalanced(node-&gt;right);
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// Helper function to destroy tree</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroyTree</span><span class="hljs-params">(TreeNode* node)</span> </span>{
        <span class="hljs-keyword">if</span> (node) {
            destroyTree(node-&gt;left);
            destroyTree(node-&gt;right);
            <span class="hljs-keyword">delete</span> node;
        }
    }
};

<span class="hljs-comment">// Binary Search Tree Class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> {</span>
<span class="hljs-keyword">public</span>:
    TreeNode* root;

    BinarySearchTree() : root(<span class="hljs-literal">nullptr</span>) {}

    <span class="hljs-comment">// Destructor</span>
    ~BinarySearchTree() {
        destroyTree(root);
    }

    <span class="hljs-comment">// Insert node maintaining BST property</span>
    <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>{
        root = insertNode(root, data);
    }

    <span class="hljs-comment">// Search for a value</span>
    <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data, TreeNode* node = <span class="hljs-literal">nullptr</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) node = root;
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (data == node-&gt;data) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &lt; node-&gt;data) {
            <span class="hljs-keyword">return</span> search(data, node-&gt;left);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> search(data, node-&gt;right);
        }
    }

    <span class="hljs-comment">// Find minimum value</span>
    <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Tree is empty"</span>);

        TreeNode* current = root;
        <span class="hljs-keyword">while</span> (current-&gt;left) {
            current = current-&gt;left;
        }
        <span class="hljs-keyword">return</span> current-&gt;data;
    }

    <span class="hljs-comment">// Find maximum value</span>
    <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(1)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMax</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Tree is empty"</span>);

        TreeNode* current = root;
        <span class="hljs-keyword">while</span> (current-&gt;right) {
            current = current-&gt;right;
        }
        <span class="hljs-keyword">return</span> current-&gt;data;
    }

    <span class="hljs-comment">// Delete node</span>
    <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>{
        root = deleteNodeHelper(root, data);
    }

    <span class="hljs-comment">// Validate if tree is a valid BST</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> isValidBSTHelper(root, INT_MIN, INT_MAX);
    }

    <span class="hljs-comment">// Find kth smallest element</span>
    <span class="hljs-comment">// Time: O(k), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> result = <span class="hljs-number">-1</span>;
        inorderKth(root, k, count, result);
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Find lowest common ancestor</span>
    <span class="hljs-comment">// Time: O(log n) average, O(n) worst, Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node1, <span class="hljs-keyword">int</span> node2)</span> </span>{
        TreeNode* lca = findLCAHelper(root, node1, node2);
        <span class="hljs-keyword">return</span> lca ? lca-&gt;data : <span class="hljs-number">-1</span>;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">insertNode</span><span class="hljs-params">(TreeNode* node, <span class="hljs-keyword">int</span> data)</span> </span>{
        <span class="hljs-keyword">if</span> (!node) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(data);
        }

        <span class="hljs-keyword">if</span> (data &lt; node-&gt;data) {
            node-&gt;left = insertNode(node-&gt;left, data);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; node-&gt;data) {
            node-&gt;right = insertNode(node-&gt;right, data);
        }
        <span class="hljs-comment">// Ignore duplicates</span>

        <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNodeHelper</span><span class="hljs-params">(TreeNode* node, <span class="hljs-keyword">int</span> data)</span> </span>{
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

        <span class="hljs-keyword">if</span> (data &lt; node-&gt;data) {
            node-&gt;left = deleteNodeHelper(node-&gt;left, data);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; node-&gt;data) {
            node-&gt;right = deleteNodeHelper(node-&gt;right, data);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Node to be deleted found</span>

            <span class="hljs-comment">// Case 1: No children</span>
            <span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) {
                <span class="hljs-keyword">delete</span> node;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
            }

            <span class="hljs-comment">// Case 2: One child</span>
            <span class="hljs-keyword">if</span> (!node-&gt;left) {
                TreeNode* temp = node-&gt;right;
                <span class="hljs-keyword">delete</span> node;
                <span class="hljs-keyword">return</span> temp;
            }
            <span class="hljs-keyword">if</span> (!node-&gt;right) {
                TreeNode* temp = node-&gt;left;
                <span class="hljs-keyword">delete</span> node;
                <span class="hljs-keyword">return</span> temp;
            }

            <span class="hljs-comment">// Case 3: Two children</span>
            TreeNode* successor = findMinNode(node-&gt;right);
            node-&gt;data = successor-&gt;data;
            node-&gt;right = deleteNodeHelper(node-&gt;right, successor-&gt;data);
        }

        <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-function">TreeNode* <span class="hljs-title">findMinNode</span><span class="hljs-params">(TreeNode* node)</span> </span>{
        <span class="hljs-keyword">while</span> (node-&gt;left) {
            node = node-&gt;left;
        }
        <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBSTHelper</span><span class="hljs-params">(TreeNode* node, <span class="hljs-keyword">int</span> minVal, <span class="hljs-keyword">int</span> maxVal)</span> </span>{
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (node-&gt;data &lt;= minVal || node-&gt;data &gt;= maxVal) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> isValidBSTHelper(node-&gt;left, minVal, node-&gt;data) &amp;&amp;
               isValidBSTHelper(node-&gt;right, node-&gt;data, maxVal);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorderKth</span><span class="hljs-params">(TreeNode* node, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>&amp; count, <span class="hljs-keyword">int</span>&amp; result)</span> </span>{
        <span class="hljs-keyword">if</span> (!node || count &gt;= k) <span class="hljs-keyword">return</span>;

        inorderKth(node-&gt;left, k, count, result);

        count++;
        <span class="hljs-keyword">if</span> (count == k) {
            result = node-&gt;data;
            <span class="hljs-keyword">return</span>;
        }

        inorderKth(node-&gt;right, k, count, result);
    }

    <span class="hljs-function">TreeNode* <span class="hljs-title">findLCAHelper</span><span class="hljs-params">(TreeNode* node, <span class="hljs-keyword">int</span> node1, <span class="hljs-keyword">int</span> node2)</span> </span>{
        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

        <span class="hljs-keyword">if</span> (node1 &lt; node-&gt;data &amp;&amp; node2 &lt; node-&gt;data) {
            <span class="hljs-keyword">return</span> findLCAHelper(node-&gt;left, node1, node2);
        }

        <span class="hljs-keyword">if</span> (node1 &gt; node-&gt;data &amp;&amp; node2 &gt; node-&gt;data) {
            <span class="hljs-keyword">return</span> findLCAHelper(node-&gt;right, node1, node2);
        }

        <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroyTree</span><span class="hljs-params">(TreeNode* node)</span> </span>{
        <span class="hljs-keyword">if</span> (node) {
            destroyTree(node-&gt;left);
            destroyTree(node-&gt;right);
            <span class="hljs-keyword">delete</span> node;
        }
    }
};

<span class="hljs-comment">// Tree Traversal Class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeTraversal</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Inorder Traversal (Left, Root, Right)</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* node, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
        <span class="hljs-keyword">if</span> (node) {
            inorder(node-&gt;left, result);
            result.push_back(node-&gt;data);
            inorder(node-&gt;right, result);
        }
    }

    <span class="hljs-comment">// Preorder Traversal (Root, Left, Right)</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* node, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
        <span class="hljs-keyword">if</span> (node) {
            result.push_back(node-&gt;data);
            preorder(node-&gt;left, result);
            preorder(node-&gt;right, result);
        }
    }

    <span class="hljs-comment">// Postorder Traversal (Left, Right, Root)</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* node, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
        <span class="hljs-keyword">if</span> (node) {
            postorder(node-&gt;left, result);
            postorder(node-&gt;right, result);
            result.push_back(node-&gt;data);
        }
    }

    <span class="hljs-comment">// Level Order Traversal</span>
    <span class="hljs-comment">// Time: O(n), Space: O(w)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> result;

        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
        q.push(root);

        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-keyword">int</span> levelSize = q.size();
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; currentLevel;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
                TreeNode* node = q.front();
                q.pop();
                currentLevel.push_back(node-&gt;data);

                <span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);
                <span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right);
            }

            result.push_back(currentLevel);
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Iterative Inorder Traversal</span>
    <span class="hljs-comment">// Time: O(n), Space: O(h)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderIterative</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;
        TreeNode* current = root;

        <span class="hljs-keyword">while</span> (current || !stk.empty()) {
            <span class="hljs-keyword">while</span> (current) {
                stk.push(current);
                current = current-&gt;left;
            }

            current = stk.top();
            stk.pop();
            result.push_back(current-&gt;data);

            current = current-&gt;right;
        }

        <span class="hljs-keyword">return</span> result;
    }
};

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Binary Tree Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    BinaryTree bt;
    bt.insert(<span class="hljs-number">1</span>);
    bt.insert(<span class="hljs-number">2</span>);
    bt.insert(<span class="hljs-number">3</span>);
    bt.insert(<span class="hljs-number">4</span>);
    bt.insert(<span class="hljs-number">5</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Tree height: "</span> &lt;&lt; bt.getHeight() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Node count: "</span> &lt;&lt; bt.countNodes() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is balanced: "</span> &lt;&lt; (bt.isBalanced() ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Search 4: "</span> &lt;&lt; (bt.search(<span class="hljs-number">4</span>) ? <span class="hljs-string">"Found"</span> : <span class="hljs-string">"Not found"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Binary Search Tree Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    BinarySearchTree bst;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; values = {<span class="hljs-number">50</span>, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>, <span class="hljs-number">80</span>};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : values) {
        bst.insert(val);
    }

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Search 40: "</span> &lt;&lt; (bst.search(<span class="hljs-number">40</span>) ? <span class="hljs-string">"Found"</span> : <span class="hljs-string">"Not found"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Min value: "</span> &lt;&lt; bst.findMin() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Max value: "</span> &lt;&lt; bst.findMax() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is valid BST: "</span> &lt;&lt; (bst.isValidBST() ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"3rd smallest: "</span> &lt;&lt; bst.kthSmallest(<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"LCA of 20 and 40: "</span> &lt;&lt; bst.findLCA(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Tree Traversals ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorderResult, preorderResult, postorderResult;

    TreeTraversal::inorder(bst.root, inorderResult);
    TreeTraversal::preorder(bst.root, preorderResult);
    TreeTraversal::postorder(bst.root, postorderResult);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inorder: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : inorderResult) <span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Preorder: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : preorderResult) <span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Postorder: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : postorderResult) <span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; levelOrderResult = TreeTraversal::levelOrder(bst.root);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Level order: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; level : levelOrderResult) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"["</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level.size(); i++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; level[i];
            <span class="hljs-keyword">if</span> (i &lt; level.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">", "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"] "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity-comparison">Time Complexity Comparison:</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Binary Tree</th>
<th>Binary Search Tree (Balanced)</th>
<th>Binary Search Tree (Worst)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Search</td>
<td>O(n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Insert</td>
<td>O(n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Delete</td>
<td>O(n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Traversal</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>Tree storage</strong>: O(n) where n is number of nodes</li>
<li><strong>Recursive operations</strong>: O(h) where h is height</li>
<li><strong>Balanced tree height</strong>: O(log n)</li>
<li><strong>Worst case height</strong>: O(n) - skewed tree</li>
</ul>
<h3 id="common-pitfalls">Common Pitfalls:</h3>
<ol>
<li><strong>Memory leaks</strong>: Not properly deallocating nodes in C++</li>
<li><strong>Stack overflow</strong>: Deep recursion in skewed trees</li>
<li><strong>BST property violation</strong>: Incorrect insertion/deletion</li>
<li><strong>Null pointer access</strong>: Not checking for null nodes</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-validate-binary-search-tree">Problem 1: Validate Binary Search Tree</h3>
<p><strong>Question</strong>: Determine if a binary tree is a valid BST.</p>
<p><strong>Solution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidBST</span>(<span class="hljs-params">root, min = null, max = null</span>) </span>{
  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">if</span> ((min !== <span class="hljs-literal">null</span> &amp;&amp; root.val &lt;= min) || (max !== <span class="hljs-literal">null</span> &amp;&amp; root.val &gt;= max)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">return</span> (
    isValidBST(root.left, min, root.val) &amp;&amp;
    isValidBST(root.right, root.val, max)
  );
}
</div></code></pre>
<h3 id="problem-2-lowest-common-ancestor">Problem 2: Lowest Common Ancestor</h3>
<p><strong>Question</strong>: Find the lowest common ancestor of two nodes in a BST.</p>
<p><strong>Hint</strong>: Use BST property to navigate efficiently.</p>
<h3 id="problem-3-binary-tree-level-order-traversal">Problem 3: Binary Tree Level Order Traversal</h3>
<p><strong>Question</strong>: Return the level order traversal of a binary tree.</p>
<p><strong>Hint</strong>: Use a queue for breadth-first traversal.</p>
<h3 id="problem-4-convert-sorted-array-to-bst">Problem 4: Convert Sorted Array to BST</h3>
<p><strong>Question</strong>: Convert a sorted array to a height-balanced BST.</p>
<p><strong>Hint</strong>: Use divide and conquer with middle element as root.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Tree traversal mastery</strong>: Can you implement all traversal methods?</li>
<li><strong>BST property understanding</strong>: Do you maintain ordering during operations?</li>
<li><strong>Recursion skills</strong>: Comfortable with recursive tree algorithms?</li>
<li><strong>Edge case handling</strong>: Empty trees, single nodes, null pointers</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Tree traversal</strong>: Inorder, preorder, postorder, level-order</li>
<li><strong>Tree construction</strong>: From traversals, from sorted arrays</li>
<li><strong>Tree validation</strong>: BST validation, balanced tree checks</li>
<li><strong>Path problems</strong>: Root to leaf paths, path sums</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Not handling null/empty trees</li>
<li>Confusing tree traversal orders</li>
<li>Violating BST property during modifications</li>
<li>Not considering tree balance and performance</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Draw the tree</strong>: Visualize the problem</li>
<li><strong>Think recursively</strong>: Most tree problems have recursive solutions</li>
<li><strong>Consider base cases</strong>: Empty nodes, leaf nodes</li>
<li><strong>Practice traversals</strong>: Master all four traversal methods</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Trees provide hierarchical organization</strong> - Natural for many data relationships</li>
<li><strong>BSTs enable efficient searching</strong> - O(log n) in balanced trees</li>
<li><strong>Traversals are fundamental</strong> - Master inorder, preorder, postorder, level-order</li>
<li><strong>Balance matters for performance</strong> - Avoid skewed trees</li>
<li><strong>Recursion is your friend</strong> - Most tree algorithms are naturally recursive</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Recursion in detail and see how it's the foundation for many tree and other algorithms.</p>
<h1 id="chapter-6-recursion-basics---the-art-of-self-reference">Chapter 6: Recursion Basics - The Art of Self-Reference</h1>
<h2 id="%F0%9F%8E%AF-what-is-recursion">🎯 What is Recursion?</h2>
<p><strong>Recursion</strong> is a programming technique where a function calls itself to solve a smaller version of the same problem. It's like looking into two mirrors facing each other - you see infinite reflections, each smaller than the last.</p>
<h3 id="why-recursion-matters">Why Recursion Matters:</h3>
<ul>
<li><strong>Natural problem-solving</strong>: Many problems have recursive structure</li>
<li><strong>Elegant solutions</strong>: Often simpler and more readable than iterative approaches</li>
<li><strong>Tree and graph algorithms</strong>: Essential for hierarchical data structures</li>
<li><strong>Divide and conquer</strong>: Foundation for many efficient algorithms</li>
</ul>
<h3 id="recursion-components">Recursion Components:</h3>
<ol>
<li><strong>Base Case</strong>: Condition that stops the recursion</li>
<li><strong>Recursive Case</strong>: Function calls itself with modified parameters</li>
<li><strong>Progress</strong>: Each call moves closer to the base case</li>
</ol>
<hr>
<h2 id="%F0%9F%94%8D-how-recursion-works">🔍 How Recursion Works</h2>
<h3 id="the-call-stack">The Call Stack:</h3>
<p>When a function calls itself, each call is added to the <strong>call stack</strong>:</p>
<pre class="hljs"><code><div>factorial(4)
├── factorial(3)
│   ├── factorial(2)
│   │   ├── factorial(1)
│   │   │   └── factorial(0) → returns 1
│   │   └── returns 1 * 1 = 1
│   └── returns 2 * 1 = 2
└── returns 3 * 2 = 6
returns 4 * 6 = 24
</div></code></pre>
<h3 id="recursion-vs-iteration">Recursion vs Iteration:</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Recursion</th>
<th>Iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Readability</strong></td>
<td>Often cleaner</td>
<td>Can be verbose</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>Uses call stack</td>
<td>Uses variables</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Function call overhead</td>
<td>Generally faster</td>
</tr>
<tr>
<td><strong>Stack overflow</strong></td>
<td>Possible with deep recursion</td>
<td>Not applicable</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Basic Recursion Examples</span>

<span class="hljs-comment">// 1. Factorial</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-comment">// Base case: factorial of 0 or 1 is 1</span>
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// Recursive case: n! = n * (n-1)!</span>
  <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 2. Fibonacci Sequence</span>
<span class="hljs-comment">// Time: O(2^n), Space: O(n) - naive approach</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-comment">// Base cases</span>
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> n;
  }

  <span class="hljs-comment">// Recursive case: F(n) = F(n-1) + F(n-2)</span>
  <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>);
}

<span class="hljs-comment">// Optimized Fibonacci with Memoization</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacciMemo</span>(<span class="hljs-params">n, memo = {}</span>) </span>{
  <span class="hljs-comment">// Check if already computed</span>
  <span class="hljs-keyword">if</span> (n <span class="hljs-keyword">in</span> memo) {
    <span class="hljs-keyword">return</span> memo[n];
  }

  <span class="hljs-comment">// Base cases</span>
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> n;
  }

  <span class="hljs-comment">// Store result in memo and return</span>
  memo[n] = fibonacciMemo(n - <span class="hljs-number">1</span>, memo) + fibonacciMemo(n - <span class="hljs-number">2</span>, memo);
  <span class="hljs-keyword">return</span> memo[n];
}

<span class="hljs-comment">// 3. Power Function</span>
<span class="hljs-comment">// Time: O(log n), Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">power</span>(<span class="hljs-params">base, exponent</span>) </span>{
  <span class="hljs-comment">// Base case</span>
  <span class="hljs-keyword">if</span> (exponent === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// Handle negative exponents</span>
  <span class="hljs-keyword">if</span> (exponent &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / power(base, -exponent);
  }

  <span class="hljs-comment">// Optimize using divide and conquer</span>
  <span class="hljs-keyword">if</span> (exponent % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> half = power(base, exponent / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> half * half;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> base * power(base, exponent - <span class="hljs-number">1</span>);
  }
}

<span class="hljs-comment">// 4. Sum of Array</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arraySum</span>(<span class="hljs-params">arr, index = <span class="hljs-number">0</span></span>) </span>{
  <span class="hljs-comment">// Base case: reached end of array</span>
  <span class="hljs-keyword">if</span> (index &gt;= arr.length) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Recursive case: current element + sum of rest</span>
  <span class="hljs-keyword">return</span> arr[index] + arraySum(arr, index + <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 5. Reverse String</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseString</span>(<span class="hljs-params">str</span>) </span>{
  <span class="hljs-comment">// Base case: empty or single character</span>
  <span class="hljs-keyword">if</span> (str.length &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> str;
  }

  <span class="hljs-comment">// Recursive case: last char + reverse of rest</span>
  <span class="hljs-keyword">return</span> str[str.length - <span class="hljs-number">1</span>] + reverseString(str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>));
}

<span class="hljs-comment">// 6. Check if String is Palindrome</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPalindrome</span>(<span class="hljs-params">str, start = <span class="hljs-number">0</span>, end = str.length - <span class="hljs-number">1</span></span>) </span>{
  <span class="hljs-comment">// Base case: single character or empty</span>
  <span class="hljs-keyword">if</span> (start &gt;= end) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Check if characters match</span>
  <span class="hljs-keyword">if</span> (str[start] !== str[end]) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Recursive case: check inner substring</span>
  <span class="hljs-keyword">return</span> isPalindrome(str, start + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 7. Binary Search (Recursive)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearch</span>(<span class="hljs-params">arr, target, left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span></span>) </span>{
  <span class="hljs-comment">// Base case: element not found</span>
  <span class="hljs-keyword">if</span> (left &gt; right) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((left + right) / <span class="hljs-number">2</span>);

  <span class="hljs-comment">// Base case: element found</span>
  <span class="hljs-keyword">if</span> (arr[mid] === target) {
    <span class="hljs-keyword">return</span> mid;
  }

  <span class="hljs-comment">// Recursive cases</span>
  <span class="hljs-keyword">if</span> (target &lt; arr[mid]) {
    <span class="hljs-keyword">return</span> binarySearch(arr, target, left, mid - <span class="hljs-number">1</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> binarySearch(arr, target, mid + <span class="hljs-number">1</span>, right);
  }
}

<span class="hljs-comment">// 8. Generate All Subsets</span>
<span class="hljs-comment">// Time: O(2^n), Space: O(2^n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateSubsets</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">index, currentSubset</span>) </span>{
    <span class="hljs-comment">// Base case: processed all elements</span>
    <span class="hljs-keyword">if</span> (index === nums.length) {
      result.push([...currentSubset]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Include current element</span>
    currentSubset.push(nums[index]);
    backtrack(index + <span class="hljs-number">1</span>, currentSubset);

    <span class="hljs-comment">// Exclude current element (backtrack)</span>
    currentSubset.pop();
    backtrack(index + <span class="hljs-number">1</span>, currentSubset);
  }

  backtrack(<span class="hljs-number">0</span>, []);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 9. Tower of Hanoi</span>
<span class="hljs-comment">// Time: O(2^n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">towerOfHanoi</span>(<span class="hljs-params">n, source, destination, auxiliary</span>) </span>{
  <span class="hljs-keyword">const</span> moves = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solve</span>(<span class="hljs-params">disks, src, dest, aux</span>) </span>{
    <span class="hljs-comment">// Base case: only one disk</span>
    <span class="hljs-keyword">if</span> (disks === <span class="hljs-number">1</span>) {
      moves.push(<span class="hljs-string">`Move disk 1 from <span class="hljs-subst">${src}</span> to <span class="hljs-subst">${dest}</span>`</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Move n-1 disks from source to auxiliary</span>
    solve(disks - <span class="hljs-number">1</span>, src, aux, dest);

    <span class="hljs-comment">// Move the largest disk from source to destination</span>
    moves.push(<span class="hljs-string">`Move disk <span class="hljs-subst">${disks}</span> from <span class="hljs-subst">${src}</span> to <span class="hljs-subst">${dest}</span>`</span>);

    <span class="hljs-comment">// Move n-1 disks from auxiliary to destination</span>
    solve(disks - <span class="hljs-number">1</span>, aux, dest, src);
  }

  solve(n, source, destination, auxiliary);
  <span class="hljs-keyword">return</span> moves;
}

<span class="hljs-comment">// 10. Count Paths in Grid</span>
<span class="hljs-comment">// Time: O(2^(m+n)), Space: O(m+n) - naive</span>
<span class="hljs-comment">// Time: O(m*n), Space: O(m*n) - with memoization</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countPaths</span>(<span class="hljs-params">m, n, memo = {}</span>) </span>{
  <span class="hljs-keyword">const</span> key = <span class="hljs-string">`<span class="hljs-subst">${m}</span>,<span class="hljs-subst">${n}</span>`</span>;

  <span class="hljs-comment">// Check memo</span>
  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> memo) {
    <span class="hljs-keyword">return</span> memo[key];
  }

  <span class="hljs-comment">// Base cases</span>
  <span class="hljs-keyword">if</span> (m === <span class="hljs-number">1</span> || n === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// Recursive case: paths from top + paths from left</span>
  memo[key] = countPaths(m - <span class="hljs-number">1</span>, n, memo) + countPaths(m, n - <span class="hljs-number">1</span>, memo);
  <span class="hljs-keyword">return</span> memo[key];
}

<span class="hljs-comment">// 11. Merge Sort (Recursive)</span>
<span class="hljs-comment">// Time: O(n log n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-comment">// Base case: array with 0 or 1 element</span>
  <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> arr;
  }

  <span class="hljs-comment">// Divide</span>
  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);
  <span class="hljs-keyword">const</span> left = mergeSort(arr.slice(<span class="hljs-number">0</span>, mid));
  <span class="hljs-keyword">const</span> right = mergeSort(arr.slice(mid));

  <span class="hljs-comment">// Conquer (merge)</span>
  <span class="hljs-keyword">return</span> merge(left, right);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left, right</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,
    j = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) {
    <span class="hljs-keyword">if</span> (left[i] &lt;= right[j]) {
      result.push(left[i]);
      i++;
    } <span class="hljs-keyword">else</span> {
      result.push(right[j]);
      j++;
    }
  }

  <span class="hljs-comment">// Add remaining elements</span>
  <span class="hljs-keyword">return</span> result.concat(left.slice(i)).concat(right.slice(j));
}

<span class="hljs-comment">// 12. Quick Sort (Recursive)</span>
<span class="hljs-comment">// Time: O(n log n) average, O(n^2) worst, Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr, low = <span class="hljs-number">0</span>, high = arr.length - <span class="hljs-number">1</span></span>) </span>{
  <span class="hljs-keyword">if</span> (low &lt; high) {
    <span class="hljs-comment">// Partition and get pivot index</span>
    <span class="hljs-keyword">const</span> pivotIndex = partition(arr, low, high);

    <span class="hljs-comment">// Recursively sort elements before and after partition</span>
    quickSort(arr, low, pivotIndex - <span class="hljs-number">1</span>);
    quickSort(arr, pivotIndex + <span class="hljs-number">1</span>, high);
  }

  <span class="hljs-keyword">return</span> arr;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, low, high</span>) </span>{
  <span class="hljs-keyword">const</span> pivot = arr[high];
  <span class="hljs-keyword">let</span> i = low - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = low; j &lt; high; j++) {
    <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i + <span class="hljs-number">1</span>], arr[high]] = [arr[high], arr[i + <span class="hljs-number">1</span>]];
  <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;
}

<span class="hljs-comment">// Recursion Helper Functions</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecursionHelpers</span> </span>{
  <span class="hljs-comment">// Convert recursion to iteration using explicit stack</span>
  <span class="hljs-keyword">static</span> factorialIterative(n) {
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
      result *= i;
    }
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Tail recursion optimization (JavaScript doesn't optimize, but concept)</span>
  <span class="hljs-keyword">static</span> factorialTailRecursive(n, accumulator = <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> accumulator;
    }
    <span class="hljs-keyword">return</span> RecursionHelpers.factorialTailRecursive(n - <span class="hljs-number">1</span>, n * accumulator);
  }

  <span class="hljs-comment">// Mutual recursion example</span>
  <span class="hljs-keyword">static</span> isEven(n) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> RecursionHelpers.isOdd(n - <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">static</span> isOdd(n) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> RecursionHelpers.isEven(n - <span class="hljs-number">1</span>);
  }

  <span class="hljs-comment">// Recursion with multiple base cases</span>
  <span class="hljs-keyword">static</span> tribonacci(n) {
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span> || n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">return</span> (
      RecursionHelpers.tribonacci(n - <span class="hljs-number">1</span>) +
      RecursionHelpers.tribonacci(n - <span class="hljs-number">2</span>) +
      RecursionHelpers.tribonacci(n - <span class="hljs-number">3</span>)
    );
  }
}

<span class="hljs-comment">// Example Usage and Testing</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Basic Recursion Examples ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Factorial of 5:"</span>, factorial(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 120</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Fibonacci of 10:"</span>, fibonacci(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 55</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Fibonacci of 10 (memoized):"</span>, fibonacciMemo(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 55</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"2^10:"</span>, power(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 1024</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Sum of [1,2,3,4,5]:"</span>, arraySum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])); <span class="hljs-comment">// 15</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Reverse "hello":'</span>, reverseString(<span class="hljs-string">"hello"</span>)); <span class="hljs-comment">// "olleh"</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Is "racecar" palindrome?'</span>, isPalindrome(<span class="hljs-string">"racecar"</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Advanced Recursion Examples ==="</span>);
<span class="hljs-keyword">const</span> sortedArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Binary search for 7:"</span>, binarySearch(sortedArray, <span class="hljs-number">7</span>)); <span class="hljs-comment">// 3</span>

<span class="hljs-keyword">const</span> subsets = generateSubsets([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Subsets of [1,2,3]:"</span>, subsets);

<span class="hljs-keyword">const</span> hanoi = towerOfHanoi(<span class="hljs-number">3</span>, <span class="hljs-string">"A"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"B"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Tower of Hanoi (3 disks):"</span>);
hanoi.forEach(<span class="hljs-function">(<span class="hljs-params">move</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(move));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Paths in 3x3 grid:"</span>, countPaths(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span>

<span class="hljs-keyword">const</span> unsortedArray = [<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Original array:"</span>, unsortedArray);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Merge sorted:"</span>, mergeSort([...unsortedArray]));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Quick sorted:"</span>, quickSort([...unsortedArray]));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Helper Functions ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Factorial iterative:"</span>, RecursionHelpers.factorialIterative(<span class="hljs-number">5</span>));
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Factorial tail recursive:"</span>,
  RecursionHelpers.factorialTailRecursive(<span class="hljs-number">5</span>)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Is 4 even?"</span>, RecursionHelpers.isEven(<span class="hljs-number">4</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Is 5 odd?"</span>, RecursionHelpers.isOdd(<span class="hljs-number">5</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Tribonacci of 7:"</span>, RecursionHelpers.tribonacci(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 24</span>
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// Basic Recursion Examples</span>

<span class="hljs-comment">// 1. Factorial</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">// Base case</span>
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// Recursive case</span>
    <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 2. Fibonacci (naive)</span>
<span class="hljs-comment">// Time: O(2^n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">// Base cases</span>
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> n;
    }

    <span class="hljs-comment">// Recursive case</span>
    <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>);
}

<span class="hljs-comment">// Fibonacci with memoization</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; fiboMemo;

<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fibonacciMemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">// Check if already computed</span>
    <span class="hljs-keyword">if</span> (fiboMemo.find(n) != fiboMemo.end()) {
        <span class="hljs-keyword">return</span> fiboMemo[n];
    }

    <span class="hljs-comment">// Base cases</span>
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> n;
    }

    <span class="hljs-comment">// Compute and store</span>
    fiboMemo[n] = fibonacciMemo(n - <span class="hljs-number">1</span>) + fibonacciMemo(n - <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> fiboMemo[n];
}

<span class="hljs-comment">// 3. Power function</span>
<span class="hljs-comment">// Time: O(log n), Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>{
    <span class="hljs-comment">// Base case</span>
    <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;
    }

    <span class="hljs-comment">// Handle negative exponents</span>
    <span class="hljs-keyword">if</span> (exponent &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / power(base, -exponent);
    }

    <span class="hljs-comment">// Optimize using divide and conquer</span>
    <span class="hljs-keyword">if</span> (exponent % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">double</span> half = power(base, exponent / <span class="hljs-number">2</span>);
        <span class="hljs-keyword">return</span> half * half;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> base * power(base, exponent - <span class="hljs-number">1</span>);
    }
}

<span class="hljs-comment">// 4. Sum of array</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">arraySum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>)</span> </span>{
    <span class="hljs-comment">// Base case</span>
    <span class="hljs-keyword">if</span> (index &gt;= arr.size()) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// Recursive case</span>
    <span class="hljs-keyword">return</span> arr[index] + arraySum(arr, index + <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 5. Reverse string</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str)</span> </span>{
    <span class="hljs-comment">// Base case</span>
    <span class="hljs-keyword">if</span> (str.length() &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> str;
    }

    <span class="hljs-comment">// Recursive case</span>
    <span class="hljs-keyword">return</span> str.back() + reverseString(str.substr(<span class="hljs-number">0</span>, str.length() - <span class="hljs-number">1</span>));
}

<span class="hljs-comment">// 6. Check palindrome</span>
<span class="hljs-comment">// Time: O(n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> end = <span class="hljs-number">-1</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (end == <span class="hljs-number">-1</span>) end = str.length() - <span class="hljs-number">1</span>;

    <span class="hljs-comment">// Base case</span>
    <span class="hljs-keyword">if</span> (start &gt;= end) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Check characters</span>
    <span class="hljs-keyword">if</span> (str[start] != str[end]) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Recursive case</span>
    <span class="hljs-keyword">return</span> isPalindrome(str, start + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 7. Binary search</span>
<span class="hljs-comment">// Time: O(log n), Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> right = <span class="hljs-number">-1</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (right == <span class="hljs-number">-1</span>) right = arr.size() - <span class="hljs-number">1</span>;

    <span class="hljs-comment">// Base case: not found</span>
    <span class="hljs-keyword">if</span> (left &gt; right) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

    <span class="hljs-comment">// Base case: found</span>
    <span class="hljs-keyword">if</span> (arr[mid] == target) {
        <span class="hljs-keyword">return</span> mid;
    }

    <span class="hljs-comment">// Recursive cases</span>
    <span class="hljs-keyword">if</span> (target &lt; arr[mid]) {
        <span class="hljs-keyword">return</span> binarySearch(arr, target, left, mid - <span class="hljs-number">1</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> binarySearch(arr, target, mid + <span class="hljs-number">1</span>, right);
    }
}

<span class="hljs-comment">// 8. Generate subsets</span>
<span class="hljs-comment">// Time: O(2^n), Space: O(2^n)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateSubsets</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> index, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; current, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; result)</span> </span>{
    <span class="hljs-comment">// Base case: processed all elements</span>
    <span class="hljs-keyword">if</span> (index == nums.size()) {
        result.push_back(current);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Include current element</span>
    current.push_back(nums[index]);
    generateSubsets(nums, index + <span class="hljs-number">1</span>, current, result);

    <span class="hljs-comment">// Exclude current element (backtrack)</span>
    current.pop_back();
    generateSubsets(nums, index + <span class="hljs-number">1</span>, current, result);
}

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">getAllSubsets</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; current;
    generateSubsets(nums, <span class="hljs-number">0</span>, current, result);
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 9. Tower of Hanoi</span>
<span class="hljs-comment">// Time: O(2^n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">towerOfHanoi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> source, <span class="hljs-keyword">char</span> destination, <span class="hljs-keyword">char</span> auxiliary, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; moves)</span> </span>{
    <span class="hljs-comment">// Base case</span>
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
        moves.push_back(<span class="hljs-string">"Move disk 1 from "</span> + <span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, source) + <span class="hljs-string">" to "</span> + <span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, destination));
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Move n-1 disks from source to auxiliary</span>
    towerOfHanoi(n - <span class="hljs-number">1</span>, source, auxiliary, destination, moves);

    <span class="hljs-comment">// Move the largest disk</span>
    moves.push_back(<span class="hljs-string">"Move disk "</span> + to_string(n) + <span class="hljs-string">" from "</span> + <span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, source) + <span class="hljs-string">" to "</span> + <span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, destination));

    <span class="hljs-comment">// Move n-1 disks from auxiliary to destination</span>
    towerOfHanoi(n - <span class="hljs-number">1</span>, auxiliary, destination, source, moves);
}

<span class="hljs-comment">// 10. Count paths in grid</span>
<span class="hljs-comment">// Time: O(m*n) with memoization, Space: O(m*n)</span>
<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; pathMemo;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-built_in">string</span> key = to_string(m) + <span class="hljs-string">","</span> + to_string(n);

    <span class="hljs-comment">// Check memo</span>
    <span class="hljs-keyword">if</span> (pathMemo.find(key) != pathMemo.end()) {
        <span class="hljs-keyword">return</span> pathMemo[key];
    }

    <span class="hljs-comment">// Base cases</span>
    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// Recursive case</span>
    pathMemo[key] = countPaths(m - <span class="hljs-number">1</span>, n) + countPaths(m, n - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> pathMemo[key];
}

<span class="hljs-comment">// 11. Merge Sort</span>
<span class="hljs-comment">// Time: O(n log n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; left, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; right)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (i &lt; left.size() &amp;&amp; j &lt; right.size()) {
        <span class="hljs-keyword">if</span> (left[i] &lt;= right[j]) {
            result.push_back(left[i]);
            i++;
        } <span class="hljs-keyword">else</span> {
            result.push_back(right[j]);
            j++;
        }
    }

    <span class="hljs-comment">// Add remaining elements</span>
    <span class="hljs-keyword">while</span> (i &lt; left.size()) {
        result.push_back(left[i]);
        i++;
    }
    <span class="hljs-keyword">while</span> (j &lt; right.size()) {
        result.push_back(right[j]);
        j++;
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
    <span class="hljs-comment">// Base case</span>
    <span class="hljs-keyword">if</span> (arr.size() &lt;= <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> arr;
    }

    <span class="hljs-comment">// Divide</span>
    <span class="hljs-keyword">int</span> mid = arr.size() / <span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(arr.begin(), arr.begin() + mid)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(arr.begin() + mid, arr.end())</span></span>;

    <span class="hljs-comment">// Conquer</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sortedLeft = mergeSort(left);
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sortedRight = mergeSort(right);

    <span class="hljs-comment">// Merge</span>
    <span class="hljs-keyword">return</span> merge(sortedLeft, sortedRight);
}

<span class="hljs-comment">// 12. Quick Sort</span>
<span class="hljs-comment">// Time: O(n log n) average, O(n^2) worst, Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>{
    <span class="hljs-keyword">int</span> pivot = arr[high];
    <span class="hljs-keyword">int</span> i = low - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = low; j &lt; high; j++) {
        <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }

    swap(arr[i + <span class="hljs-number">1</span>], arr[high]);
    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>{
    <span class="hljs-keyword">if</span> (low &lt; high) {
        <span class="hljs-keyword">int</span> pivotIndex = partition(arr, low, high);

        quickSort(arr, low, pivotIndex - <span class="hljs-number">1</span>);
        quickSort(arr, pivotIndex + <span class="hljs-number">1</span>, high);
    }
}

<span class="hljs-comment">// Helper Functions</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecursionHelpers</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Tail recursion (C++ may optimize)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">factorialTailRecursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> accumulator = <span class="hljs-number">1</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> accumulator;
        }
        <span class="hljs-keyword">return</span> factorialTailRecursive(n - <span class="hljs-number">1</span>, n * accumulator);
    }

    <span class="hljs-comment">// Mutual recursion</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isEven</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> isOdd(n - <span class="hljs-number">1</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isOdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> isEven(n - <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// Greatest Common Divisor (Euclidean algorithm)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;
        <span class="hljs-keyword">return</span> gcd(b, a % b);
    }

    <span class="hljs-comment">// Convert decimal to binary</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">decimalToBinary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"0"</span>;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">"1"</span>;

        <span class="hljs-keyword">return</span> decimalToBinary(n / <span class="hljs-number">2</span>) + to_string(n % <span class="hljs-number">2</span>);
    }
};

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Basic Recursion Examples ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Factorial of 5: "</span> &lt;&lt; factorial(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Fibonacci of 10: "</span> &lt;&lt; fibonacci(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Fibonacci of 10 (memoized): "</span> &lt;&lt; fibonacciMemo(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2^10: "</span> &lt;&lt; power(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sum of array: "</span> &lt;&lt; arraySum(arr) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">string</span> str = <span class="hljs-string">"hello"</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Reverse of \""</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">"\": "</span> &lt;&lt; reverseString(str) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">string</span> palindrome = <span class="hljs-string">"racecar"</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is \""</span> &lt;&lt; palindrome &lt;&lt; <span class="hljs-string">"\" palindrome? "</span> &lt;&lt; (isPalindrome(palindrome) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Advanced Recursion Examples ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sortedArr = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Binary search for 7: "</span> &lt;&lt; binarySearch(sortedArr, <span class="hljs-number">7</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; subsets = getAllSubsets(nums);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Subsets of [1,2,3]: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; subset : subsets) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"["</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; subset.size(); i++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; subset[i];
            <span class="hljs-keyword">if</span> (i &lt; subset.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">","</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"] "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; hanoiMoves;
    towerOfHanoi(<span class="hljs-number">3</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'B'</span>, hanoiMoves);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Tower of Hanoi (3 disks):"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; move : hanoiMoves) {
        <span class="hljs-built_in">cout</span> &lt;&lt; move &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Paths in 3x3 grid: "</span> &lt;&lt; countPaths(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; unsorted = {<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Original array: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : unsorted) <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; mergeSorted = mergeSort(unsorted);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Merge sorted: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : mergeSorted) <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; quickSorted = unsorted;
    quickSort(quickSorted, <span class="hljs-number">0</span>, quickSorted.size() - <span class="hljs-number">1</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Quick sorted: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : quickSorted) <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Helper Functions ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Factorial tail recursive: "</span> &lt;&lt; RecursionHelpers::factorialTailRecursive(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is 4 even? "</span> &lt;&lt; (RecursionHelpers::isEven(<span class="hljs-number">4</span>) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is 5 odd? "</span> &lt;&lt; (RecursionHelpers::isOdd(<span class="hljs-number">5</span>) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"GCD of 48 and 18: "</span> &lt;&lt; RecursionHelpers::gcd(<span class="hljs-number">48</span>, <span class="hljs-number">18</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Binary of 10: "</span> &lt;&lt; RecursionHelpers::decimalToBinary(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity-patterns">Time Complexity Patterns:</h3>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>Example</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Linear Recursion</strong></td>
<td>Factorial, Sum</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>Binary Recursion</strong></td>
<td>Fibonacci (naive)</td>
<td>O(2^n)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>Logarithmic</strong></td>
<td>Binary Search, Power</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td><strong>Divide &amp; Conquer</strong></td>
<td>Merge Sort</td>
<td>O(n log n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<h3 id="common-pitfalls">Common Pitfalls:</h3>
<ol>
<li>
<p><strong>Stack Overflow</strong>: Deep recursion can exhaust call stack</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bad: Will cause stack overflow for large n</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">badFactorial</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> n * badFactorial(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// No tail call optimization</span>
}
</div></code></pre>
</li>
<li>
<p><strong>Exponential Time</strong>: Naive recursive solutions</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bad: O(2^n) time complexity</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slowFibonacci</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;
  <span class="hljs-keyword">return</span> slowFibonacci(n - <span class="hljs-number">1</span>) + slowFibonacci(n - <span class="hljs-number">2</span>); <span class="hljs-comment">// Recalculates same values</span>
}
</div></code></pre>
</li>
<li>
<p><strong>Missing Base Case</strong>: Infinite recursion</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bad: No base case</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">infiniteRecursion</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> infiniteRecursion(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// Will never stop</span>
}
</div></code></pre>
</li>
<li>
<p><strong>Incorrect Progress</strong>: Not moving toward base case</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bad: n never decreases</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noProgress</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> noProgress(n); <span class="hljs-comment">// Same value passed</span>
}
</div></code></pre>
</li>
</ol>
<h3 id="optimization-techniques">Optimization Techniques:</h3>
<ol>
<li><strong>Memoization</strong>: Store computed results</li>
<li><strong>Tail Recursion</strong>: Last operation is recursive call</li>
<li><strong>Iterative Conversion</strong>: Convert to loops when possible</li>
<li><strong>Dynamic Programming</strong>: Bottom-up approach</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-sum-of-digits">Problem 1: Sum of Digits</h3>
<p><strong>Question</strong>: Write a recursive function to find the sum of digits of a number.</p>
<p><strong>Example</strong>: <code>sumDigits(1234)</code> should return <code>10</code></p>
<p><strong>Solution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumDigits</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> (n % <span class="hljs-number">10</span>) + sumDigits(<span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">10</span>));
}
</div></code></pre>
<h3 id="problem-2-count-occurrences">Problem 2: Count Occurrences</h3>
<p><strong>Question</strong>: Count occurrences of a character in a string recursively.</p>
<p><strong>Hint</strong>: Process one character at a time.</p>
<h3 id="problem-3-flatten-nested-array">Problem 3: Flatten Nested Array</h3>
<p><strong>Question</strong>: Flatten a nested array using recursion.</p>
<p><strong>Example</strong>: <code>[1, [2, 3], [4, [5, 6]]]</code> → <code>[1, 2, 3, 4, 5, 6]</code></p>
<p><strong>Hint</strong>: Check if element is array, recurse if true.</p>
<h3 id="problem-4-generate-permutations">Problem 4: Generate Permutations</h3>
<p><strong>Question</strong>: Generate all permutations of a string.</p>
<p><strong>Hint</strong>: Fix first character, permute rest, then swap.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Base case identification</strong>: Can you identify when to stop?</li>
<li><strong>Recursive case logic</strong>: Do you break down the problem correctly?</li>
<li><strong>Complexity analysis</strong>: Can you analyze time/space complexity?</li>
<li><strong>Optimization awareness</strong>: Do you know when recursion isn't optimal?</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Tree traversals</strong>: Inorder, preorder, postorder</li>
<li><strong>Divide and conquer</strong>: Merge sort, quick sort, binary search</li>
<li><strong>Backtracking</strong>: Permutations, combinations, N-Queens</li>
<li><strong>Dynamic programming</strong>: Fibonacci, coin change, longest subsequence</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Forgetting base cases</li>
<li>Not making progress toward base case</li>
<li>Ignoring stack overflow for large inputs</li>
<li>Not considering iterative alternatives</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Start with base case</strong>: Always identify stopping condition first</li>
<li><strong>Trust the recursion</strong>: Assume recursive calls work correctly</li>
<li><strong>Draw the call stack</strong>: Visualize for complex problems</li>
<li><strong>Consider memoization</strong>: For overlapping subproblems</li>
<li><strong>Think iteratively too</strong>: Sometimes loops are better</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Recursion is powerful</strong> - Elegant solutions for many problems</li>
<li><strong>Base cases are crucial</strong> - Always define stopping conditions</li>
<li><strong>Watch the complexity</strong> - Naive recursion can be exponential</li>
<li><strong>Memoization helps</strong> - Cache results for overlapping subproblems</li>
<li><strong>Not always optimal</strong> - Sometimes iteration is better</li>
<li><strong>Practice makes perfect</strong> - Start simple, build complexity</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Sorting Algorithms and see how recursion powers divide-and-conquer sorting methods like merge sort and quick sort.</p>
<h1 id="chapter-7-sorting-algorithms---organizing-data-efficiently">Chapter 7: Sorting Algorithms - Organizing Data Efficiently</h1>
<h2 id="%F0%9F%8E%AF-what-is-sorting">🎯 What is Sorting?</h2>
<p><strong>Sorting</strong> is the process of arranging data in a particular order (ascending or descending). It's one of the most fundamental operations in computer science and forms the basis for many other algorithms.</p>
<h3 id="why-sorting-matters">Why Sorting Matters:</h3>
<ul>
<li><strong>Search optimization</strong>: Sorted data enables binary search (O(log n))</li>
<li><strong>Data organization</strong>: Makes data easier to understand and process</li>
<li><strong>Algorithm foundation</strong>: Many algorithms require sorted input</li>
<li><strong>Database operations</strong>: Crucial for joins, indexing, and queries</li>
<li><strong>User experience</strong>: Organized data is more user-friendly</li>
</ul>
<h3 id="sorting-categories">Sorting Categories:</h3>
<ol>
<li><strong>Comparison-based</strong>: Compare elements to determine order</li>
<li><strong>Non-comparison</strong>: Use element properties (counting, radix)</li>
<li><strong>Stable</strong>: Preserve relative order of equal elements</li>
<li><strong>In-place</strong>: Sort with O(1) extra space</li>
<li><strong>Adaptive</strong>: Perform better on partially sorted data</li>
</ol>
<hr>
<h2 id="%F0%9F%94%8D-sorting-algorithm-overview">🔍 Sorting Algorithm Overview</h2>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Time (Best)</th>
<th>Time (Average)</th>
<th>Time (Worst)</th>
<th>Space</th>
<th>Stable</th>
<th>In-place</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bubble Sort</strong></td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><strong>Selection Sort</strong></td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><strong>Insertion Sort</strong></td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><strong>Merge Sort</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><strong>Quick Sort</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><strong>Heap Sort</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Sorting Algorithms Implementation</span>

<span class="hljs-comment">// 1. Bubble Sort</span>
<span class="hljs-comment">// Time: O(n²), Space: O(1)</span>
<span class="hljs-comment">// Stable: Yes, In-place: Yes</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">const</span> n = arr.length;
  <span class="hljs-keyword">const</span> result = [...arr]; <span class="hljs-comment">// Create copy to avoid mutation</span>

  <span class="hljs-comment">// Outer loop for number of passes</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
    <span class="hljs-keyword">let</span> swapped = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Optimization: track if any swaps occurred</span>

    <span class="hljs-comment">// Inner loop for comparisons in current pass</span>
    <span class="hljs-comment">// Last i elements are already sorted</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) {
      <span class="hljs-comment">// Compare adjacent elements</span>
      <span class="hljs-keyword">if</span> (result[j] &gt; result[j + <span class="hljs-number">1</span>]) {
        <span class="hljs-comment">// Swap if they're in wrong order</span>
        [result[j], result[j + <span class="hljs-number">1</span>]] = [result[j + <span class="hljs-number">1</span>], result[j]];
        swapped = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-comment">// If no swaps occurred, array is sorted</span>
    <span class="hljs-keyword">if</span> (!swapped) {
      <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 2. Selection Sort</span>
<span class="hljs-comment">// Time: O(n²), Space: O(1)</span>
<span class="hljs-comment">// Stable: No, In-place: Yes</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">const</span> n = arr.length;
  <span class="hljs-keyword">const</span> result = [...arr];

  <span class="hljs-comment">// Move boundary of unsorted subarray</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
    <span class="hljs-comment">// Find minimum element in unsorted array</span>
    <span class="hljs-keyword">let</span> minIndex = i;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) {
      <span class="hljs-keyword">if</span> (result[j] &lt; result[minIndex]) {
        minIndex = j;
      }
    }

    <span class="hljs-comment">// Swap found minimum with first element</span>
    <span class="hljs-keyword">if</span> (minIndex !== i) {
      [result[i], result[minIndex]] = [result[minIndex], result[i]];
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 3. Insertion Sort</span>
<span class="hljs-comment">// Time: O(n²), Space: O(1)</span>
<span class="hljs-comment">// Stable: Yes, In-place: Yes</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertionSort</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">const</span> n = arr.length;
  <span class="hljs-keyword">const</span> result = [...arr];

  <span class="hljs-comment">// Start from second element (first is considered sorted)</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
    <span class="hljs-keyword">const</span> key = result[i]; <span class="hljs-comment">// Current element to be positioned</span>
    <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;

    <span class="hljs-comment">// Move elements greater than key one position ahead</span>
    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; result[j] &gt; key) {
      result[j + <span class="hljs-number">1</span>] = result[j];
      j--;
    }

    <span class="hljs-comment">// Place key at its correct position</span>
    result[j + <span class="hljs-number">1</span>] = key;
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 4. Merge Sort</span>
<span class="hljs-comment">// Time: O(n log n), Space: O(n)</span>
<span class="hljs-comment">// Stable: Yes, In-place: No</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-comment">// Base case: arrays with 0 or 1 element are already sorted</span>
  <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> arr;
  }

  <span class="hljs-comment">// Divide: split array into two halves</span>
  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);
  <span class="hljs-keyword">const</span> left = mergeSort(arr.slice(<span class="hljs-number">0</span>, mid));
  <span class="hljs-keyword">const</span> right = mergeSort(arr.slice(mid));

  <span class="hljs-comment">// Conquer: merge sorted halves</span>
  <span class="hljs-keyword">return</span> merge(left, right);
}

<span class="hljs-comment">// Helper function to merge two sorted arrays</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left, right</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,
    j = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Compare elements from both arrays and merge in sorted order</span>
  <span class="hljs-keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) {
    <span class="hljs-keyword">if</span> (left[i] &lt;= right[j]) {
      result.push(left[i]);
      i++;
    } <span class="hljs-keyword">else</span> {
      result.push(right[j]);
      j++;
    }
  }

  <span class="hljs-comment">// Add remaining elements (if any)</span>
  <span class="hljs-keyword">while</span> (i &lt; left.length) {
    result.push(left[i]);
    i++;
  }

  <span class="hljs-keyword">while</span> (j &lt; right.length) {
    result.push(right[j]);
    j++;
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 5. Quick Sort</span>
<span class="hljs-comment">// Time: O(n log n) average, O(n²) worst, Space: O(log n)</span>
<span class="hljs-comment">// Stable: No, In-place: Yes</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr, low = <span class="hljs-number">0</span>, high = arr.length - <span class="hljs-number">1</span></span>) </span>{
  <span class="hljs-keyword">const</span> result = [...arr]; <span class="hljs-comment">// Create copy for non-destructive sorting</span>
  quickSortHelper(result, low, high);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSortHelper</span>(<span class="hljs-params">arr, low, high</span>) </span>{
  <span class="hljs-keyword">if</span> (low &lt; high) {
    <span class="hljs-comment">// Partition array and get pivot index</span>
    <span class="hljs-keyword">const</span> pivotIndex = partition(arr, low, high);

    <span class="hljs-comment">// Recursively sort elements before and after partition</span>
    quickSortHelper(arr, low, pivotIndex - <span class="hljs-number">1</span>);
    quickSortHelper(arr, pivotIndex + <span class="hljs-number">1</span>, high);
  }
}

<span class="hljs-comment">// Partition function for Quick Sort</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, low, high</span>) </span>{
  <span class="hljs-comment">// Choose rightmost element as pivot</span>
  <span class="hljs-keyword">const</span> pivot = arr[high];
  <span class="hljs-keyword">let</span> i = low - <span class="hljs-number">1</span>; <span class="hljs-comment">// Index of smaller element</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = low; j &lt; high; j++) {
    <span class="hljs-comment">// If current element is smaller than or equal to pivot</span>
    <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  <span class="hljs-comment">// Place pivot in correct position</span>
  [arr[i + <span class="hljs-number">1</span>], arr[high]] = [arr[high], arr[i + <span class="hljs-number">1</span>]];
  <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;
}

<span class="hljs-comment">// 6. Heap Sort</span>
<span class="hljs-comment">// Time: O(n log n), Space: O(1)</span>
<span class="hljs-comment">// Stable: No, In-place: Yes</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">const</span> result = [...arr];
  <span class="hljs-keyword">const</span> n = result.length;

  <span class="hljs-comment">// Build max heap</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    heapify(result, n, i);
  }

  <span class="hljs-comment">// Extract elements from heap one by one</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
    <span class="hljs-comment">// Move current root to end</span>
    [result[<span class="hljs-number">0</span>], result[i]] = [result[i], result[<span class="hljs-number">0</span>]];

    <span class="hljs-comment">// Call heapify on reduced heap</span>
    heapify(result, i, <span class="hljs-number">0</span>);
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Heapify a subtree rooted at index i</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">arr, n, i</span>) </span>{
  <span class="hljs-keyword">let</span> largest = i; <span class="hljs-comment">// Initialize largest as root</span>
  <span class="hljs-keyword">const</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">const</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;

  <span class="hljs-comment">// If left child is larger than root</span>
  <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {
    largest = left;
  }

  <span class="hljs-comment">// If right child is larger than largest so far</span>
  <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {
    largest = right;
  }

  <span class="hljs-comment">// If largest is not root</span>
  <span class="hljs-keyword">if</span> (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];

    <span class="hljs-comment">// Recursively heapify the affected sub-tree</span>
    heapify(arr, n, largest);
  }
}

<span class="hljs-comment">// Advanced Sorting Algorithms</span>

<span class="hljs-comment">// 7. Counting Sort (for integers in limited range)</span>
<span class="hljs-comment">// Time: O(n + k), Space: O(k) where k is range</span>
<span class="hljs-comment">// Stable: Yes, In-place: No</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countingSort</span>(<span class="hljs-params">arr, maxValue = null</span>) </span>{
  <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> arr;

  <span class="hljs-comment">// Find maximum value if not provided</span>
  <span class="hljs-keyword">if</span> (maxValue === <span class="hljs-literal">null</span>) {
    maxValue = <span class="hljs-built_in">Math</span>.max(...arr);
  }

  <span class="hljs-comment">// Create count array</span>
  <span class="hljs-keyword">const</span> count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(maxValue + <span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// Count occurrences of each element</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> arr) {
    count[num]++;
  }

  <span class="hljs-comment">// Build result array</span>
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= maxValue; i++) {
    <span class="hljs-keyword">while</span> (count[i] &gt; <span class="hljs-number">0</span>) {
      result.push(i);
      count[i]--;
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 8. Radix Sort (for non-negative integers)</span>
<span class="hljs-comment">// Time: O(d * (n + k)), Space: O(n + k)</span>
<span class="hljs-comment">// where d is number of digits, k is range of digits (0-9)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">radixSort</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> arr;

  <span class="hljs-comment">// Find maximum number to know number of digits</span>
  <span class="hljs-keyword">const</span> max = <span class="hljs-built_in">Math</span>.max(...arr);

  <span class="hljs-comment">// Do counting sort for every digit</span>
  <span class="hljs-keyword">let</span> result = [...arr];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> exp = <span class="hljs-number">1</span>; <span class="hljs-built_in">Math</span>.floor(max / exp) &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>) {
    result = countingSortByDigit(result, exp);
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Counting sort for radix sort</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countingSortByDigit</span>(<span class="hljs-params">arr, exp</span>) </span>{
  <span class="hljs-keyword">const</span> n = arr.length;
  <span class="hljs-keyword">const</span> output = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);
  <span class="hljs-keyword">const</span> count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>).fill(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// Count occurrences of each digit</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-keyword">const</span> digit = <span class="hljs-built_in">Math</span>.floor(arr[i] / exp) % <span class="hljs-number">10</span>;
    count[digit]++;
  }

  <span class="hljs-comment">// Change count[i] to actual position</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    count[i] += count[i - <span class="hljs-number">1</span>];
  }

  <span class="hljs-comment">// Build output array</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">const</span> digit = <span class="hljs-built_in">Math</span>.floor(arr[i] / exp) % <span class="hljs-number">10</span>;
    output[count[digit] - <span class="hljs-number">1</span>] = arr[i];
    count[digit]--;
  }

  <span class="hljs-keyword">return</span> output;
}

<span class="hljs-comment">// Sorting Utilities</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortingUtils</span> </span>{
  <span class="hljs-comment">// Check if array is sorted</span>
  <span class="hljs-keyword">static</span> isSorted(arr, ascending = <span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) {
      <span class="hljs-keyword">if</span> (ascending &amp;&amp; arr[i] &lt; arr[i - <span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">if</span> (!ascending &amp;&amp; arr[i] &gt; arr[i - <span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Generate random array for testing</span>
  <span class="hljs-keyword">static</span> generateRandomArray(size, min = <span class="hljs-number">0</span>, max = <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(
      { <span class="hljs-attr">length</span>: size },
      () =&gt; <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min
    );
  }

  <span class="hljs-comment">// Measure sorting performance</span>
  <span class="hljs-keyword">static</span> measurePerformance(sortFunction, arr, name) {
    <span class="hljs-keyword">const</span> start = performance.now();
    <span class="hljs-keyword">const</span> sorted = sortFunction([...arr]);
    <span class="hljs-keyword">const</span> end = performance.now();

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${name}</span>: <span class="hljs-subst">${(end - start).toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Sorted correctly: <span class="hljs-subst">${SortingUtils.isSorted(sorted)}</span>`</span>);
    <span class="hljs-keyword">return</span> sorted;
  }

  <span class="hljs-comment">// Sort with custom comparator</span>
  <span class="hljs-keyword">static</span> customSort(arr, compareFn) {
    <span class="hljs-keyword">return</span> [...arr].sort(compareFn);
  }

  <span class="hljs-comment">// Stable sort check</span>
  <span class="hljs-keyword">static</span> isStableSort(sortFunction) {
    <span class="hljs-comment">// Test with objects having same keys</span>
    <span class="hljs-keyword">const</span> testData = [
      { <span class="hljs-attr">key</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"a"</span> },
      { <span class="hljs-attr">key</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"b"</span> },
      { <span class="hljs-attr">key</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"c"</span> },
      { <span class="hljs-attr">key</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"d"</span> },
      { <span class="hljs-attr">key</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">"e"</span> },
    ];

    <span class="hljs-keyword">const</span> sorted = sortFunction(testData, (a, b) =&gt; a.key - b.key);

    <span class="hljs-comment">// Check if relative order of equal elements is preserved</span>
    <span class="hljs-keyword">const</span> threes = sorted.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.key === <span class="hljs-number">3</span>);
    <span class="hljs-keyword">return</span> threes[<span class="hljs-number">0</span>].id === <span class="hljs-string">"a"</span> &amp;&amp; threes[<span class="hljs-number">1</span>].id === <span class="hljs-string">"c"</span> &amp;&amp; threes[<span class="hljs-number">2</span>].id === <span class="hljs-string">"e"</span>;
  }

  <span class="hljs-comment">// Find kth smallest element (QuickSelect)</span>
  <span class="hljs-keyword">static</span> quickSelect(arr, k) {
    <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">1</span> || k &gt; arr.length) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"k is out of bounds"</span>);
    }

    <span class="hljs-keyword">const</span> result = [...arr];
    <span class="hljs-keyword">return</span> quickSelectHelper(result, <span class="hljs-number">0</span>, result.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);
  }
}

<span class="hljs-comment">// QuickSelect helper function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSelectHelper</span>(<span class="hljs-params">arr, low, high, k</span>) </span>{
  <span class="hljs-keyword">if</span> (low === high) {
    <span class="hljs-keyword">return</span> arr[low];
  }

  <span class="hljs-keyword">const</span> pivotIndex = partition(arr, low, high);

  <span class="hljs-keyword">if</span> (k === pivotIndex) {
    <span class="hljs-keyword">return</span> arr[k];
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; pivotIndex) {
    <span class="hljs-keyword">return</span> quickSelectHelper(arr, low, pivotIndex - <span class="hljs-number">1</span>, k);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> quickSelectHelper(arr, pivotIndex + <span class="hljs-number">1</span>, high, k);
  }
}

<span class="hljs-comment">// Hybrid Sorting Algorithm (Introsort-like)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hybridSort</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">10</span>) {
    <span class="hljs-comment">// Use insertion sort for small arrays</span>
    <span class="hljs-keyword">return</span> insertionSort(arr);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1000</span>) {
    <span class="hljs-comment">// Use quick sort for medium arrays</span>
    <span class="hljs-keyword">return</span> quickSort(arr);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Use merge sort for large arrays</span>
    <span class="hljs-keyword">return</span> mergeSort(arr);
  }
}

<span class="hljs-comment">// Example Usage and Performance Testing</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Sorting Algorithms Demo ==="</span>);

<span class="hljs-comment">// Test data</span>
<span class="hljs-keyword">const</span> testArray = [<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>, <span class="hljs-number">5</span>, <span class="hljs-number">77</span>, <span class="hljs-number">30</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Original array:"</span>, testArray);

<span class="hljs-comment">// Test all sorting algorithms</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Basic Sorting Algorithms ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bubble Sort:"</span>, bubbleSort(testArray));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Selection Sort:"</span>, selectionSort(testArray));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Insertion Sort:"</span>, insertionSort(testArray));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Advanced Sorting Algorithms ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Merge Sort:"</span>, mergeSort(testArray));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Quick Sort:"</span>, quickSort(testArray));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap Sort:"</span>, heapSort(testArray));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Specialized Sorting Algorithms ==="</span>);
<span class="hljs-keyword">const</span> integerArray = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Original integers:"</span>, integerArray);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Counting Sort:"</span>, countingSort(integerArray));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Radix Sort:"</span>, radixSort(integerArray));

<span class="hljs-comment">// Performance comparison</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Performance Comparison ==="</span>);
<span class="hljs-keyword">const</span> largeArray = SortingUtils.generateRandomArray(<span class="hljs-number">1000</span>);

SortingUtils.measurePerformance(bubbleSort, largeArray, <span class="hljs-string">"Bubble Sort"</span>);
SortingUtils.measurePerformance(selectionSort, largeArray, <span class="hljs-string">"Selection Sort"</span>);
SortingUtils.measurePerformance(insertionSort, largeArray, <span class="hljs-string">"Insertion Sort"</span>);
SortingUtils.measurePerformance(mergeSort, largeArray, <span class="hljs-string">"Merge Sort"</span>);
SortingUtils.measurePerformance(quickSort, largeArray, <span class="hljs-string">"Quick Sort"</span>);
SortingUtils.measurePerformance(heapSort, largeArray, <span class="hljs-string">"Heap Sort"</span>);

<span class="hljs-comment">// Utility demonstrations</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Utility Functions ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Is [1,2,3,4,5] sorted?"</span>, SortingUtils.isSorted([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]));
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"3rd smallest in [3,1,4,1,5,9,2,6]:"</span>,
  SortingUtils.quickSelect([<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>], <span class="hljs-number">3</span>)
);

<span class="hljs-comment">// Custom sorting</span>
<span class="hljs-keyword">const</span> people = [
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"Alice"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"Bob"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"Charlie"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">35</span> },
];
<span class="hljs-keyword">const</span> sortedByAge = SortingUtils.customSort(people, (a, b) =&gt; a.age - b.age);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"People sorted by age:"</span>, sortedByAge);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Hybrid Sort Demo ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Hybrid Sort result:"</span>, hybridSort(testArray));
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::chrono;

<span class="hljs-comment">// Sorting Algorithms Implementation</span>

<span class="hljs-comment">// 1. Bubble Sort</span>
<span class="hljs-comment">// Time: O(n²), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
    <span class="hljs-keyword">int</span> n = arr.size();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
        <span class="hljs-keyword">bool</span> swapped = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) {
            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {
                swap(arr[j], arr[j + <span class="hljs-number">1</span>]);
                swapped = <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-comment">// If no swapping occurred, array is sorted</span>
        <span class="hljs-keyword">if</span> (!swapped) {
            <span class="hljs-keyword">break</span>;
        }
    }
}

<span class="hljs-comment">// 2. Selection Sort</span>
<span class="hljs-comment">// Time: O(n²), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
    <span class="hljs-keyword">int</span> n = arr.size();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
        <span class="hljs-keyword">int</span> minIndex = i;

        <span class="hljs-comment">// Find minimum element in unsorted portion</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) {
            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) {
                minIndex = j;
            }
        }

        <span class="hljs-comment">// Swap minimum with first element</span>
        <span class="hljs-keyword">if</span> (minIndex != i) {
            swap(arr[i], arr[minIndex]);
        }
    }
}

<span class="hljs-comment">// 3. Insertion Sort</span>
<span class="hljs-comment">// Time: O(n²), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
    <span class="hljs-keyword">int</span> n = arr.size();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">int</span> key = arr[i];
        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;

        <span class="hljs-comment">// Move elements greater than key one position ahead</span>
        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) {
            arr[j + <span class="hljs-number">1</span>] = arr[j];
            j--;
        }

        arr[j + <span class="hljs-number">1</span>] = key;
    }
}

<span class="hljs-comment">// 4. Merge Sort</span>
<span class="hljs-comment">// Time: O(n log n), Space: O(n)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>{
    <span class="hljs-keyword">int</span> n1 = mid - left + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> n2 = right - mid;

    <span class="hljs-comment">// Create temporary arrays</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">leftArr</span><span class="hljs-params">(n1)</span>, <span class="hljs-title">rightArr</span><span class="hljs-params">(n2)</span></span>;

    <span class="hljs-comment">// Copy data to temporary arrays</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++) {
        leftArr[i] = arr[left + i];
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n2; j++) {
        rightArr[j] = arr[mid + <span class="hljs-number">1</span> + j];
    }

    <span class="hljs-comment">// Merge temporary arrays back</span>
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = left;

    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) {
        <span class="hljs-keyword">if</span> (leftArr[i] &lt;= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } <span class="hljs-keyword">else</span> {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }

    <span class="hljs-comment">// Copy remaining elements</span>
    <span class="hljs-keyword">while</span> (i &lt; n1) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }

    <span class="hljs-keyword">while</span> (j &lt; n2) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
    <span class="hljs-keyword">if</span> (left &lt; right) {
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

        mergeSort(arr, left, mid);
        mergeSort(arr, mid + <span class="hljs-number">1</span>, right);
        merge(arr, left, mid, right);
    }
}

<span class="hljs-comment">// 5. Quick Sort</span>
<span class="hljs-comment">// Time: O(n log n) average, O(n²) worst, Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>{
    <span class="hljs-keyword">int</span> pivot = arr[high];
    <span class="hljs-keyword">int</span> i = low - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = low; j &lt; high; j++) {
        <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }

    swap(arr[i + <span class="hljs-number">1</span>], arr[high]);
    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>{
    <span class="hljs-keyword">if</span> (low &lt; high) {
        <span class="hljs-keyword">int</span> pivotIndex = partition(arr, low, high);

        quickSort(arr, low, pivotIndex - <span class="hljs-number">1</span>);
        quickSort(arr, pivotIndex + <span class="hljs-number">1</span>, high);
    }
}

<span class="hljs-comment">// 6. Heap Sort</span>
<span class="hljs-comment">// Time: O(n log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span> </span>{
    <span class="hljs-keyword">int</span> largest = i;
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;

    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    <span class="hljs-keyword">if</span> (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
    <span class="hljs-keyword">int</span> n = arr.size();

    <span class="hljs-comment">// Build max heap</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        heapify(arr, n, i);
    }

    <span class="hljs-comment">// Extract elements from heap</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
        swap(arr[<span class="hljs-number">0</span>], arr[i]);
        heapify(arr, i, <span class="hljs-number">0</span>);
    }
}

<span class="hljs-comment">// 7. Counting Sort</span>
<span class="hljs-comment">// Time: O(n + k), Space: O(k)</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> maxVal)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(maxVal + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;

    <span class="hljs-comment">// Count occurrences</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr) {
        count[num]++;
    }

    <span class="hljs-comment">// Build result</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= maxVal; i++) {
        <span class="hljs-keyword">while</span> (count[i] &gt; <span class="hljs-number">0</span>) {
            result.push_back(i);
            count[i]--;
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 8. Radix Sort</span>
<span class="hljs-comment">// Time: O(d * (n + k)), Space: O(n + k)</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countingSortForRadix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr, <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>)</span> </span>{
    <span class="hljs-keyword">int</span> n = arr.size();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">output</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)</span></span>;

    <span class="hljs-comment">// Count occurrences of each digit</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        count[(arr[i] / <span class="hljs-built_in">exp</span>) % <span class="hljs-number">10</span>]++;
    }

    <span class="hljs-comment">// Change count[i] to actual position</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) {
        count[i] += count[i - <span class="hljs-number">1</span>];
    }

    <span class="hljs-comment">// Build output array</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        output[count[(arr[i] / <span class="hljs-built_in">exp</span>) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = arr[i];
        count[(arr[i] / <span class="hljs-built_in">exp</span>) % <span class="hljs-number">10</span>]--;
    }

    <span class="hljs-keyword">return</span> output;
}

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr)</span> </span>{
    <span class="hljs-keyword">int</span> maxVal = *max_element(arr.begin(), arr.end());

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>; maxVal / <span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>; <span class="hljs-built_in">exp</span> *= <span class="hljs-number">10</span>) {
        arr = countingSortForRadix(arr, <span class="hljs-built_in">exp</span>);
    }

    <span class="hljs-keyword">return</span> arr;
}

<span class="hljs-comment">// Utility Functions</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortingUtils</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Check if array is sorted</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isSorted</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.size(); i++) {
            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - <span class="hljs-number">1</span>]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Generate random array</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">generateRandomArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> minVal = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">100</span>)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(size)</span></span>;
        random_device rd;
        <span class="hljs-function">mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>;
        <span class="hljs-function">uniform_int_distribution&lt;&gt; <span class="hljs-title">dis</span><span class="hljs-params">(minVal, maxVal)</span></span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
            arr[i] = dis(gen);
        }

        <span class="hljs-keyword">return</span> arr;
    }

    <span class="hljs-comment">// Measure performance</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurePerformance</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*sortFunc)(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name)</span> </span>{
        <span class="hljs-keyword">auto</span> start = high_resolution_clock::now();
        sortFunc(arr);
        <span class="hljs-keyword">auto</span> end = high_resolution_clock::now();

        <span class="hljs-keyword">auto</span> duration = duration_cast&lt;microseconds&gt;(end - start);
        <span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; duration.count() &lt;&lt; <span class="hljs-string">" microseconds"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sorted correctly: "</span> &lt;&lt; (isSorted(arr) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// QuickSelect for kth smallest element</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">1</span> || k &gt; arr.size()) {
            <span class="hljs-keyword">throw</span> invalid_argument(<span class="hljs-string">"k is out of bounds"</span>);
        }

        <span class="hljs-keyword">return</span> quickSelectHelper(arr, <span class="hljs-number">0</span>, arr.size() - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSelectHelper</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">if</span> (low == high) {
            <span class="hljs-keyword">return</span> arr[low];
        }

        <span class="hljs-keyword">int</span> pivotIndex = partition(arr, low, high);

        <span class="hljs-keyword">if</span> (k == pivotIndex) {
            <span class="hljs-keyword">return</span> arr[k];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; pivotIndex) {
            <span class="hljs-keyword">return</span> quickSelectHelper(arr, low, pivotIndex - <span class="hljs-number">1</span>, k);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> quickSelectHelper(arr, pivotIndex + <span class="hljs-number">1</span>, high, k);
        }
    }
};

<span class="hljs-comment">// Print array utility</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : arr) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Sorting Algorithms Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test data</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; testArray = {<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>, <span class="hljs-number">5</span>, <span class="hljs-number">77</span>, <span class="hljs-number">30</span>};
    printArray(testArray, <span class="hljs-string">"Original array"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Basic Sorting Algorithms ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; bubbleArr = testArray;
    bubbleSort(bubbleArr);
    printArray(bubbleArr, <span class="hljs-string">"Bubble Sort"</span>);

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; selectionArr = testArray;
    selectionSort(selectionArr);
    printArray(selectionArr, <span class="hljs-string">"Selection Sort"</span>);

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; insertionArr = testArray;
    insertionSort(insertionArr);
    printArray(insertionArr, <span class="hljs-string">"Insertion Sort"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Advanced Sorting Algorithms ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; mergeArr = testArray;
    mergeSort(mergeArr, <span class="hljs-number">0</span>, mergeArr.size() - <span class="hljs-number">1</span>);
    printArray(mergeArr, <span class="hljs-string">"Merge Sort"</span>);

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; quickArr = testArray;
    quickSort(quickArr, <span class="hljs-number">0</span>, quickArr.size() - <span class="hljs-number">1</span>);
    printArray(quickArr, <span class="hljs-string">"Quick Sort"</span>);

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; heapArr = testArray;
    heapSort(heapArr);
    printArray(heapArr, <span class="hljs-string">"Heap Sort"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Specialized Sorting Algorithms ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; integerArray = {<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>};
    printArray(integerArray, <span class="hljs-string">"Original integers"</span>);

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; countingSorted = countingSort(integerArray, <span class="hljs-number">8</span>);
    printArray(countingSorted, <span class="hljs-string">"Counting Sort"</span>);

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; radixSorted = radixSort(integerArray);
    printArray(radixSorted, <span class="hljs-string">"Radix Sort"</span>);

    <span class="hljs-comment">// Performance comparison</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Performance Comparison (1000 elements) ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; largeArray = SortingUtils::generateRandomArray(<span class="hljs-number">1000</span>);

    SortingUtils::measurePerformance(bubbleSort, largeArray, <span class="hljs-string">"Bubble Sort"</span>);
    SortingUtils::measurePerformance(selectionSort, largeArray, <span class="hljs-string">"Selection Sort"</span>);
    SortingUtils::measurePerformance(insertionSort, largeArray, <span class="hljs-string">"Insertion Sort"</span>);

    <span class="hljs-comment">// For merge and quick sort, we need wrapper functions</span>
    <span class="hljs-keyword">auto</span> mergeSortWrapper = [](<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr) {
        mergeSort(arr, <span class="hljs-number">0</span>, arr.size() - <span class="hljs-number">1</span>);
    };

    <span class="hljs-keyword">auto</span> quickSortWrapper = [](<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr) {
        quickSort(arr, <span class="hljs-number">0</span>, arr.size() - <span class="hljs-number">1</span>);
    };

    SortingUtils::measurePerformance(mergeSortWrapper, largeArray, <span class="hljs-string">"Merge Sort"</span>);
    SortingUtils::measurePerformance(quickSortWrapper, largeArray, <span class="hljs-string">"Quick Sort"</span>);
    SortingUtils::measurePerformance(heapSort, largeArray, <span class="hljs-string">"Heap Sort"</span>);

    <span class="hljs-comment">// Utility demonstrations</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Utility Functions ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sortedTest = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is [1,2,3,4,5] sorted? "</span> &lt;&lt; (SortingUtils::isSorted(sortedTest) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; selectTest = {<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"3rd smallest in [3,1,4,1,5,9,2,6]: "</span> &lt;&lt; SortingUtils::quickSelect(selectTest, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="when-to-use-each-algorithm">When to Use Each Algorithm:</h3>
<ol>
<li>
<p><strong>Bubble Sort</strong>:</p>
<ul>
<li>✅ Educational purposes, very small datasets</li>
<li>❌ Never for production code</li>
</ul>
</li>
<li>
<p><strong>Selection Sort</strong>:</p>
<ul>
<li>✅ When memory writes are expensive</li>
<li>❌ Generally poor performance</li>
</ul>
</li>
<li>
<p><strong>Insertion Sort</strong>:</p>
<ul>
<li>✅ Small arrays (&lt; 50 elements)</li>
<li>✅ Nearly sorted data</li>
<li>✅ Online algorithm (can sort as data arrives)</li>
</ul>
</li>
<li>
<p><strong>Merge Sort</strong>:</p>
<ul>
<li>✅ Stable sorting required</li>
<li>✅ Guaranteed O(n log n) performance</li>
<li>✅ External sorting (large datasets)</li>
<li>❌ Extra memory required</li>
</ul>
</li>
<li>
<p><strong>Quick Sort</strong>:</p>
<ul>
<li>✅ Average case performance</li>
<li>✅ In-place sorting</li>
<li>❌ Worst case O(n²)</li>
<li>❌ Not stable</li>
</ul>
</li>
<li>
<p><strong>Heap Sort</strong>:</p>
<ul>
<li>✅ Guaranteed O(n log n)</li>
<li>✅ In-place sorting</li>
<li>❌ Not stable</li>
<li>❌ Poor cache performance</li>
</ul>
</li>
</ol>
<h3 id="common-pitfalls">Common Pitfalls:</h3>
<ol>
<li><strong>Choosing wrong algorithm</strong>: Using bubble sort for large data</li>
<li><strong>Ignoring stability</strong>: When relative order matters</li>
<li><strong>Memory constraints</strong>: Not considering space complexity</li>
<li><strong>Worst-case scenarios</strong>: Quick sort on already sorted data</li>
<li><strong>Integer overflow</strong>: In partition calculations</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-sort-colors-dutch-flag">Problem 1: Sort Colors (Dutch Flag)</h3>
<p><strong>Question</strong>: Sort an array containing only 0s, 1s, and 2s.</p>
<p><strong>Example</strong>: <code>[2,0,2,1,1,0]</code> → <code>[0,0,1,1,2,2]</code></p>
<p><strong>Solution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortColors</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>,
    mid = <span class="hljs-number">0</span>,
    high = nums.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (mid &lt;= high) {
    <span class="hljs-keyword">if</span> (nums[mid] === <span class="hljs-number">0</span>) {
      [nums[low], nums[mid]] = [nums[mid], nums[low]];
      low++;
      mid++;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] === <span class="hljs-number">1</span>) {
      mid++;
    } <span class="hljs-keyword">else</span> {
      [nums[mid], nums[high]] = [nums[high], nums[mid]];
      high--;
    }
  }
}
</div></code></pre>
<h3 id="problem-2-merge-sorted-arrays">Problem 2: Merge Sorted Arrays</h3>
<p><strong>Question</strong>: Merge two sorted arrays into one sorted array.</p>
<p><strong>Hint</strong>: Use two pointers approach.</p>
<h3 id="problem-3-find-kth-largest-element">Problem 3: Find Kth Largest Element</h3>
<p><strong>Question</strong>: Find the kth largest element in an unsorted array.</p>
<p><strong>Hint</strong>: Use QuickSelect algorithm.</p>
<h3 id="problem-4-sort-array-by-frequency">Problem 4: Sort Array by Frequency</h3>
<p><strong>Question</strong>: Sort array elements by their frequency of occurrence.</p>
<p><strong>Hint</strong>: Use hash map to count frequencies, then custom sort.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Algorithm selection</strong>: Can you choose the right sorting algorithm?</li>
<li><strong>Implementation skills</strong>: Can you code the algorithm correctly?</li>
<li><strong>Complexity analysis</strong>: Do you understand time/space trade-offs?</li>
<li><strong>Edge cases</strong>: Empty arrays, single elements, duplicates</li>
</ol>
<h3 id="common-interview-questions">Common Interview Questions:</h3>
<ul>
<li>&quot;Sort an array of 0s, 1s, and 2s&quot;</li>
<li>&quot;Merge k sorted arrays&quot;</li>
<li>&quot;Find the kth largest element&quot;</li>
<li>&quot;Sort array with custom comparator&quot;</li>
<li>&quot;Implement merge sort/quick sort&quot;</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Using bubble sort for large datasets</li>
<li>Not handling edge cases (empty arrays)</li>
<li>Incorrect complexity analysis</li>
<li>Not considering stability when required</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Know the classics</strong>: Master merge sort and quick sort</li>
<li><strong>Understand trade-offs</strong>: Time vs space, stable vs unstable</li>
<li><strong>Practice implementation</strong>: Code without looking up</li>
<li><strong>Consider constraints</strong>: Array size, memory limits, stability</li>
<li><strong>Optimize for the problem</strong>: Sometimes counting sort is better</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>No universal best algorithm</strong> - Choice depends on constraints</li>
<li><strong>Merge sort for stability</strong> - When relative order matters</li>
<li><strong>Quick sort for average performance</strong> - Good general-purpose choice</li>
<li><strong>Insertion sort for small arrays</strong> - Simple and efficient</li>
<li><strong>Specialized algorithms exist</strong> - Counting/radix for specific data</li>
<li><strong>Practice makes perfect</strong> - Implement algorithms from scratch</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Searching Algorithms and see how sorted data enables efficient search techniques like binary search.</p>
<h1 id="chapter-8-searching-algorithms---finding-data-efficiently">Chapter 8: Searching Algorithms - Finding Data Efficiently</h1>
<h2 id="%F0%9F%8E%AF-what-is-searching">🎯 What is Searching?</h2>
<p><strong>Searching</strong> is the process of finding a specific element or determining if it exists in a collection of data. It's one of the most fundamental operations in computer science and forms the backbone of many applications.</p>
<h3 id="why-searching-matters">Why Searching Matters:</h3>
<ul>
<li><strong>Data retrieval</strong>: Core operation in databases and file systems</li>
<li><strong>User experience</strong>: Fast search improves application responsiveness</li>
<li><strong>Algorithm foundation</strong>: Many algorithms rely on efficient searching</li>
<li><strong>Real-world applications</strong>: Web search, autocomplete, recommendation systems</li>
<li><strong>Problem solving</strong>: Essential for many coding interview questions</li>
</ul>
<h3 id="search-categories">Search Categories:</h3>
<ol>
<li><strong>Linear vs Binary</strong>: Sequential vs divide-and-conquer approaches</li>
<li><strong>Exact vs Approximate</strong>: Finding exact matches vs similar items</li>
<li><strong>Single vs Multiple</strong>: Finding one occurrence vs all occurrences</li>
<li><strong>Static vs Dynamic</strong>: Searching in fixed vs changing datasets</li>
</ol>
<hr>
<h2 id="%F0%9F%94%8D-search-algorithm-overview">🔍 Search Algorithm Overview</h2>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Data Structure</th>
<th>Time (Best)</th>
<th>Time (Average)</th>
<th>Time (Worst)</th>
<th>Space</th>
<th>Prerequisites</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Linear Search</strong></td>
<td>Any</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>None</td>
</tr>
<tr>
<td><strong>Binary Search</strong></td>
<td>Sorted Array</td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(1)</td>
<td>Sorted data</td>
</tr>
<tr>
<td><strong>Jump Search</strong></td>
<td>Sorted Array</td>
<td>O(1)</td>
<td>O(√n)</td>
<td>O(√n)</td>
<td>O(1)</td>
<td>Sorted data</td>
</tr>
<tr>
<td><strong>Interpolation Search</strong></td>
<td>Uniformly Distributed</td>
<td>O(1)</td>
<td>O(log log n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>Sorted, uniform</td>
</tr>
<tr>
<td><strong>Exponential Search</strong></td>
<td>Sorted Array</td>
<td>O(1)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(1)</td>
<td>Sorted data</td>
</tr>
<tr>
<td><strong>Ternary Search</strong></td>
<td>Sorted Array</td>
<td>O(1)</td>
<td>O(log₃ n)</td>
<td>O(log₃ n)</td>
<td>O(1)</td>
<td>Sorted data</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Searching Algorithms Implementation</span>

<span class="hljs-comment">// 1. Linear Search (Sequential Search)</span>
<span class="hljs-comment">// Time: O(n), Space: O(1)</span>
<span class="hljs-comment">// Works on: Any data structure</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">linearSearch</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-comment">// Search through each element sequentially</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    <span class="hljs-keyword">if</span> (arr[i] === target) {
      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// Return index if found</span>
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Return -1 if not found</span>
}

<span class="hljs-comment">// Linear Search - Find All Occurrences</span>
<span class="hljs-comment">// Time: O(n), Space: O(k) where k is number of occurrences</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">linearSearchAll</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">const</span> indices = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    <span class="hljs-keyword">if</span> (arr[i] === target) {
      indices.push(i);
    }
  }

  <span class="hljs-keyword">return</span> indices;
}

<span class="hljs-comment">// 2. Binary Search (Iterative)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-comment">// Prerequisite: Array must be sorted</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearch</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-comment">// Calculate middle index (avoid overflow)</span>
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-comment">// Check if target is at middle</span>
    <span class="hljs-keyword">if</span> (arr[mid] === target) {
      <span class="hljs-keyword">return</span> mid;
    }

    <span class="hljs-comment">// If target is smaller, search left half</span>
    <span class="hljs-keyword">if</span> (arr[mid] &gt; target) {
      right = mid - <span class="hljs-number">1</span>;
    }
    <span class="hljs-comment">// If target is larger, search right half</span>
    <span class="hljs-keyword">else</span> {
      left = mid + <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Target not found</span>
}

<span class="hljs-comment">// Binary Search (Recursive)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearchRecursive</span>(<span class="hljs-params">arr, target, left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span></span>) </span>{
  <span class="hljs-comment">// Base case: element not found</span>
  <span class="hljs-keyword">if</span> (left &gt; right) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

  <span class="hljs-comment">// Base case: element found</span>
  <span class="hljs-keyword">if</span> (arr[mid] === target) {
    <span class="hljs-keyword">return</span> mid;
  }

  <span class="hljs-comment">// Recursive cases</span>
  <span class="hljs-keyword">if</span> (arr[mid] &gt; target) {
    <span class="hljs-keyword">return</span> binarySearchRecursive(arr, target, left, mid - <span class="hljs-number">1</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> binarySearchRecursive(arr, target, mid + <span class="hljs-number">1</span>, right);
  }
}

<span class="hljs-comment">// Binary Search Variations</span>

<span class="hljs-comment">// Find First Occurrence (Leftmost)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findFirstOccurrence</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">-1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (arr[mid] === target) {
      result = mid;
      right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// Continue searching in left half</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
      left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      right = mid - <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Find Last Occurrence (Rightmost)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLastOccurrence</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">-1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (arr[mid] === target) {
      result = mid;
      left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// Continue searching in right half</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
      left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      right = mid - <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Find Range of Target (First and Last Occurrence)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findRange</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">const</span> first = findFirstOccurrence(arr, target);
  <span class="hljs-keyword">if</span> (first === <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">return</span> [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>];
  }

  <span class="hljs-keyword">const</span> last = findLastOccurrence(arr, target);
  <span class="hljs-keyword">return</span> [first, last];
}

<span class="hljs-comment">// Find Insert Position</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findInsertPosition</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
      left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      right = mid - <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> left;
}

<span class="hljs-comment">// 3. Jump Search (Block Search)</span>
<span class="hljs-comment">// Time: O(√n), Space: O(1)</span>
<span class="hljs-comment">// Prerequisite: Array must be sorted</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jumpSearch</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">const</span> n = arr.length;
  <span class="hljs-keyword">const</span> step = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.sqrt(n));
  <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Find the block where element is present</span>
  <span class="hljs-keyword">while</span> (arr[<span class="hljs-built_in">Math</span>.min(step, n) - <span class="hljs-number">1</span>] &lt; target) {
    prev = step;
    step += <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.sqrt(n));

    <span class="hljs-comment">// If we reached end of array</span>
    <span class="hljs-keyword">if</span> (prev &gt;= n) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
  }

  <span class="hljs-comment">// Linear search in the identified block</span>
  <span class="hljs-keyword">while</span> (arr[prev] &lt; target) {
    prev++;

    <span class="hljs-comment">// If we reached next block or end of array</span>
    <span class="hljs-keyword">if</span> (prev === <span class="hljs-built_in">Math</span>.min(step, n)) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
  }

  <span class="hljs-comment">// If element is found</span>
  <span class="hljs-keyword">if</span> (arr[prev] === target) {
    <span class="hljs-keyword">return</span> prev;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// 4. Interpolation Search</span>
<span class="hljs-comment">// Time: O(log log n) average, O(n) worst, Space: O(1)</span>
<span class="hljs-comment">// Prerequisite: Array must be sorted and uniformly distributed</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interpolationSearch</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; target &gt;= arr[left] &amp;&amp; target &lt;= arr[right]) {
    <span class="hljs-comment">// If array has only one element</span>
    <span class="hljs-keyword">if</span> (left === right) {
      <span class="hljs-keyword">return</span> arr[left] === target ? left : <span class="hljs-number">-1</span>;
    }

    <span class="hljs-comment">// Calculate position using interpolation formula</span>
    <span class="hljs-keyword">const</span> pos =
      left +
      <span class="hljs-built_in">Math</span>.floor(
        ((target - arr[left]) * (right - left)) / (arr[right] - arr[left])
      );

    <span class="hljs-comment">// Target found</span>
    <span class="hljs-keyword">if</span> (arr[pos] === target) {
      <span class="hljs-keyword">return</span> pos;
    }

    <span class="hljs-comment">// If target is larger, search right subarray</span>
    <span class="hljs-keyword">if</span> (arr[pos] &lt; target) {
      left = pos + <span class="hljs-number">1</span>;
    }
    <span class="hljs-comment">// If target is smaller, search left subarray</span>
    <span class="hljs-keyword">else</span> {
      right = pos - <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// 5. Exponential Search (Doubling Search)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-comment">// Prerequisite: Array must be sorted</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exponentialSearch</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">const</span> n = arr.length;

  <span class="hljs-comment">// If target is at first position</span>
  <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] === target) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Find range for binary search by repeated doubling</span>
  <span class="hljs-keyword">let</span> bound = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (bound &lt; n &amp;&amp; arr[bound] &lt;= target) {
    bound *= <span class="hljs-number">2</span>;
  }

  <span class="hljs-comment">// Perform binary search in the found range</span>
  <span class="hljs-keyword">return</span> binarySearchRange(arr, target, bound / <span class="hljs-number">2</span>, <span class="hljs-built_in">Math</span>.min(bound, n - <span class="hljs-number">1</span>));
}

<span class="hljs-comment">// Helper function for exponential search</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearchRange</span>(<span class="hljs-params">arr, target, left, right</span>) </span>{
  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (arr[mid] === target) {
      <span class="hljs-keyword">return</span> mid;
    }

    <span class="hljs-keyword">if</span> (arr[mid] &gt; target) {
      right = mid - <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      left = mid + <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// 6. Ternary Search</span>
<span class="hljs-comment">// Time: O(log₃ n), Space: O(1)</span>
<span class="hljs-comment">// Prerequisite: Array must be sorted</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ternarySearch</span>(<span class="hljs-params">arr, target, left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span></span>) </span>{
  <span class="hljs-keyword">if</span> (left &gt; right) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// Divide array into three parts</span>
  <span class="hljs-keyword">const</span> mid1 = left + <span class="hljs-built_in">Math</span>.floor((right - left) / <span class="hljs-number">3</span>);
  <span class="hljs-keyword">const</span> mid2 = right - <span class="hljs-built_in">Math</span>.floor((right - left) / <span class="hljs-number">3</span>);

  <span class="hljs-comment">// Check if target is at either midpoint</span>
  <span class="hljs-keyword">if</span> (arr[mid1] === target) {
    <span class="hljs-keyword">return</span> mid1;
  }
  <span class="hljs-keyword">if</span> (arr[mid2] === target) {
    <span class="hljs-keyword">return</span> mid2;
  }

  <span class="hljs-comment">// Determine which third to search</span>
  <span class="hljs-keyword">if</span> (target &lt; arr[mid1]) {
    <span class="hljs-keyword">return</span> ternarySearch(arr, target, left, mid1 - <span class="hljs-number">1</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid2]) {
    <span class="hljs-keyword">return</span> ternarySearch(arr, target, mid2 + <span class="hljs-number">1</span>, right);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> ternarySearch(arr, target, mid1 + <span class="hljs-number">1</span>, mid2 - <span class="hljs-number">1</span>);
  }
}

<span class="hljs-comment">// Advanced Search Algorithms</span>

<span class="hljs-comment">// 7. Search in Rotated Sorted Array</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">searchRotatedArray</span>(<span class="hljs-params">arr, target</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (arr[mid] === target) {
      <span class="hljs-keyword">return</span> mid;
    }

    <span class="hljs-comment">// Check which half is sorted</span>
    <span class="hljs-keyword">if</span> (arr[left] &lt;= arr[mid]) {
      <span class="hljs-comment">// Left half is sorted</span>
      <span class="hljs-keyword">if</span> (target &gt;= arr[left] &amp;&amp; target &lt; arr[mid]) {
        right = mid - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        left = mid + <span class="hljs-number">1</span>;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Right half is sorted</span>
      <span class="hljs-keyword">if</span> (target &gt; arr[mid] &amp;&amp; target &lt;= arr[right]) {
        left = mid + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        right = mid - <span class="hljs-number">1</span>;
      }
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// 8. Search in 2D Matrix</span>
<span class="hljs-comment">// Time: O(log(m*n)), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">searchMatrix</span>(<span class="hljs-params">matrix, target</span>) </span>{
  <span class="hljs-keyword">if</span> (!matrix || matrix.length === <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">const</span> m = matrix.length;
  <span class="hljs-keyword">const</span> n = matrix[<span class="hljs-number">0</span>].length;
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = m * n - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">const</span> midValue = matrix[<span class="hljs-built_in">Math</span>.floor(mid / n)][mid % n];

    <span class="hljs-keyword">if</span> (midValue === target) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midValue &lt; target) {
      left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      right = mid - <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">// 9. Find Peak Element</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findPeakElement</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt; right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) {
      <span class="hljs-comment">// Peak is in left half (including mid)</span>
      right = mid;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Peak is in right half</span>
      left = mid + <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> left;
}

<span class="hljs-comment">// 10. Find Minimum in Rotated Sorted Array</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findMinRotated</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt; right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[right]) {
      <span class="hljs-comment">// Minimum is in right half</span>
      left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Minimum is in left half (including mid)</span>
      right = mid;
    }
  }

  <span class="hljs-keyword">return</span> arr[left];
}

<span class="hljs-comment">// Search Utilities</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchUtils</span> </span>{
  <span class="hljs-comment">// Binary search for closest element</span>
  <span class="hljs-keyword">static</span> findClosest(arr, target) {
    <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> closest = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (left &lt;= right) {
      <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

      <span class="hljs-comment">// Update closest if current element is closer</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(arr[mid] - target) &lt; <span class="hljs-built_in">Math</span>.abs(arr[closest] - target)) {
        closest = mid;
      }

      <span class="hljs-keyword">if</span> (arr[mid] === target) {
        <span class="hljs-keyword">return</span> mid;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
        left = mid + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        right = mid - <span class="hljs-number">1</span>;
      }
    }

    <span class="hljs-keyword">return</span> closest;
  }

  <span class="hljs-comment">// Count occurrences using binary search</span>
  <span class="hljs-keyword">static</span> countOccurrences(arr, target) {
    <span class="hljs-keyword">const</span> range = findRange(arr, target);
    <span class="hljs-keyword">if</span> (range[<span class="hljs-number">0</span>] === <span class="hljs-number">-1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> range[<span class="hljs-number">1</span>] - range[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// Search in infinite array (simulated with large array)</span>
  <span class="hljs-keyword">static</span> searchInfinite(arr, target) {
    <span class="hljs-keyword">let</span> bound = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// Find upper bound</span>
    <span class="hljs-keyword">while</span> (bound &lt; arr.length &amp;&amp; arr[bound] &lt; target) {
      bound *= <span class="hljs-number">2</span>;
    }

    <span class="hljs-comment">// Binary search in the range</span>
    <span class="hljs-keyword">return</span> binarySearchRange(
      arr,
      target,
      bound / <span class="hljs-number">2</span>,
      <span class="hljs-built_in">Math</span>.min(bound, arr.length - <span class="hljs-number">1</span>)
    );
  }

  <span class="hljs-comment">// Find floor and ceiling</span>
  <span class="hljs-keyword">static</span> findFloorCeiling(arr, target) {
    <span class="hljs-keyword">let</span> floor = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">let</span> ceiling = <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
      <span class="hljs-keyword">if</span> (arr[i] &lt;= target) {
        floor = arr[i];
      }
      <span class="hljs-keyword">if</span> (arr[i] &gt;= target &amp;&amp; ceiling === <span class="hljs-number">-1</span>) {
        ceiling = arr[i];
      }
    }

    <span class="hljs-keyword">return</span> { floor, ceiling };
  }

  <span class="hljs-comment">// Performance measurement</span>
  <span class="hljs-keyword">static</span> measureSearchPerformance(searchFunc, arr, target, name) {
    <span class="hljs-keyword">const</span> start = performance.now();
    <span class="hljs-keyword">const</span> result = searchFunc(arr, target);
    <span class="hljs-keyword">const</span> end = performance.now();

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${name}</span>: <span class="hljs-subst">${(end - start).toFixed(<span class="hljs-number">4</span>)}</span>ms, Result: <span class="hljs-subst">${result}</span>`</span>);
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Generate test data</span>
  <span class="hljs-keyword">static</span> generateSortedArray(size, min = <span class="hljs-number">0</span>, max = <span class="hljs-number">1000</span>) {
    <span class="hljs-keyword">const</span> arr = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
      arr.push(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min);
    }
    <span class="hljs-keyword">return</span> arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);
  }

  <span class="hljs-comment">// Fuzzy search (simple implementation)</span>
  <span class="hljs-keyword">static</span> fuzzySearch(arr, target, threshold = <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">const</span> results = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> arr[i] === <span class="hljs-string">"string"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">"string"</span>) {
        <span class="hljs-keyword">const</span> distance = SearchUtils.levenshteinDistance(arr[i], target);
        <span class="hljs-keyword">if</span> (distance &lt;= threshold) {
          results.push({ <span class="hljs-attr">index</span>: i, <span class="hljs-attr">value</span>: arr[i], distance });
        }
      }
    }

    <span class="hljs-keyword">return</span> results.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.distance - b.distance);
  }

  <span class="hljs-comment">// Levenshtein distance for fuzzy search</span>
  <span class="hljs-keyword">static</span> levenshteinDistance(str1, str2) {
    <span class="hljs-keyword">const</span> matrix = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= str2.length; i++) {
      matrix[i] = [i];
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= str1.length; j++) {
      matrix[<span class="hljs-number">0</span>][j] = j;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= str2.length; i++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= str1.length; j++) {
        <span class="hljs-keyword">if</span> (str2.charAt(i - <span class="hljs-number">1</span>) === str1.charAt(j - <span class="hljs-number">1</span>)) {
          matrix[i][j] = matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
        } <span class="hljs-keyword">else</span> {
          matrix[i][j] = <span class="hljs-built_in">Math</span>.min(
            matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, <span class="hljs-comment">// substitution</span>
            matrix[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, <span class="hljs-comment">// insertion</span>
            matrix[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span> <span class="hljs-comment">// deletion</span>
          );
        }
      }
    }

    <span class="hljs-keyword">return</span> matrix[str2.length][str1.length];
  }
}

<span class="hljs-comment">// Example Usage and Testing</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Searching Algorithms Demo ==="</span>);

<span class="hljs-comment">// Test data</span>
<span class="hljs-keyword">const</span> sortedArray = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">25</span>];
<span class="hljs-keyword">const</span> target = <span class="hljs-number">13</span>;

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Sorted array:"</span>, sortedArray);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Target:"</span>, target);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Basic Search Algorithms ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Linear Search:"</span>, linearSearch(sortedArray, target));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Binary Search (Iterative):"</span>, binarySearch(sortedArray, target));
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Binary Search (Recursive):"</span>,
  binarySearchRecursive(sortedArray, target)
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Advanced Search Algorithms ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Jump Search:"</span>, jumpSearch(sortedArray, target));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Interpolation Search:"</span>, interpolationSearch(sortedArray, target));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Exponential Search:"</span>, exponentialSearch(sortedArray, target));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ternary Search:"</span>, ternarySearch(sortedArray, target));

<span class="hljs-comment">// Test with duplicates</span>
<span class="hljs-keyword">const</span> arrayWithDuplicates = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Binary Search Variations ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Array with duplicates:"</span>, arrayWithDuplicates);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"First occurrence of 2:"</span>,
  findFirstOccurrence(arrayWithDuplicates, <span class="hljs-number">2</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Last occurrence of 6:"</span>,
  findLastOccurrence(arrayWithDuplicates, <span class="hljs-number">6</span>)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Range of 4:"</span>, findRange(arrayWithDuplicates, <span class="hljs-number">4</span>));
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Insert position for 3.5:"</span>,
  findInsertPosition(arrayWithDuplicates, <span class="hljs-number">3.5</span>)
);

<span class="hljs-comment">// Advanced problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Advanced Search Problems ==="</span>);
<span class="hljs-keyword">const</span> rotatedArray = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Rotated array:"</span>, rotatedArray);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Search 0 in rotated array:"</span>, searchRotatedArray(rotatedArray, <span class="hljs-number">0</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Find minimum in rotated array:"</span>, findMinRotated(rotatedArray));

<span class="hljs-keyword">const</span> peakArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Peak array:"</span>, peakArray);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Peak element index:"</span>, findPeakElement(peakArray));

<span class="hljs-comment">// 2D Matrix search</span>
<span class="hljs-keyword">const</span> matrix = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>],
  [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>],
  [<span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>],
];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== 2D Matrix Search ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Search 5 in matrix:"</span>, searchMatrix(matrix, <span class="hljs-number">5</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Search 13 in matrix:"</span>, searchMatrix(matrix, <span class="hljs-number">13</span>));

<span class="hljs-comment">// Performance comparison</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Performance Comparison ==="</span>);
<span class="hljs-keyword">const</span> largeArray = SearchUtils.generateSortedArray(<span class="hljs-number">10000</span>);
<span class="hljs-keyword">const</span> searchTarget = largeArray[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * largeArray.length)];

SearchUtils.measureSearchPerformance(
  linearSearch,
  largeArray,
  searchTarget,
  <span class="hljs-string">"Linear Search"</span>
);
SearchUtils.measureSearchPerformance(
  binarySearch,
  largeArray,
  searchTarget,
  <span class="hljs-string">"Binary Search"</span>
);
SearchUtils.measureSearchPerformance(
  jumpSearch,
  largeArray,
  searchTarget,
  <span class="hljs-string">"Jump Search"</span>
);
SearchUtils.measureSearchPerformance(
  interpolationSearch,
  largeArray,
  searchTarget,
  <span class="hljs-string">"Interpolation Search"</span>
);

<span class="hljs-comment">// Utility demonstrations</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Search Utilities ==="</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Closest to 14 in sorted array:"</span>,
  SearchUtils.findClosest(sortedArray, <span class="hljs-number">14</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Count of 2 in duplicates array:"</span>,
  SearchUtils.countOccurrences(arrayWithDuplicates, <span class="hljs-number">2</span>)
);

<span class="hljs-keyword">const</span> floorCeiling = SearchUtils.findFloorCeiling(sortedArray, <span class="hljs-number">12</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Floor and ceiling of 12:"</span>, floorCeiling);

<span class="hljs-comment">// Fuzzy search demo</span>
<span class="hljs-keyword">const</span> names = [<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Charlie"</span>, <span class="hljs-string">"David"</span>, <span class="hljs-string">"Eve"</span>, <span class="hljs-string">"Frank"</span>];
<span class="hljs-keyword">const</span> fuzzyResults = SearchUtils.fuzzySearch(names, <span class="hljs-string">"Charli"</span>, <span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Fuzzy Search ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Fuzzy search for "Charli":'</span>, fuzzyResults);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::chrono;

<span class="hljs-comment">// Searching Algorithms Implementation</span>

<span class="hljs-comment">// 1. Linear Search</span>
<span class="hljs-comment">// Time: O(n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">linearSearch</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) {
        <span class="hljs-keyword">if</span> (arr[i] == target) {
            <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// Linear Search - Find All Occurrences</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">linearSearchAll</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; indices;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.size(); i++) {
        <span class="hljs-keyword">if</span> (arr[i] == target) {
            indices.push_back(i);
        }
    }

    <span class="hljs-keyword">return</span> indices;
}

<span class="hljs-comment">// 2. Binary Search (Iterative)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt;= right) {
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (arr[mid] == target) {
            <span class="hljs-keyword">return</span> mid;
        }

        <span class="hljs-keyword">if</span> (arr[mid] &gt; target) {
            right = mid - <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            left = mid + <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// Binary Search (Recursive)</span>
<span class="hljs-comment">// Time: O(log n), Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearchRecursive</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
    <span class="hljs-keyword">if</span> (left &gt; right) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

    <span class="hljs-keyword">if</span> (arr[mid] == target) {
        <span class="hljs-keyword">return</span> mid;
    }

    <span class="hljs-keyword">if</span> (arr[mid] &gt; target) {
        <span class="hljs-keyword">return</span> binarySearchRecursive(arr, target, left, mid - <span class="hljs-number">1</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> binarySearchRecursive(arr, target, mid + <span class="hljs-number">1</span>, right);
    }
}

<span class="hljs-comment">// Find First Occurrence</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findFirstOccurrence</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">while</span> (left &lt;= right) {
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (arr[mid] == target) {
            result = mid;
            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// Continue searching left</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
            left = mid + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            right = mid - <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Find Last Occurrence</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLastOccurrence</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">while</span> (left &lt;= right) {
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (arr[mid] == target) {
            result = mid;
            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// Continue searching right</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
            left = mid + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            right = mid - <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Find Range</span>
<span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRange</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> first = findFirstOccurrence(arr, target);
    <span class="hljs-keyword">if</span> (first == <span class="hljs-number">-1</span>) {
        <span class="hljs-keyword">return</span> {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};
    }

    <span class="hljs-keyword">int</span> last = findLastOccurrence(arr, target);
    <span class="hljs-keyword">return</span> {first, last};
}

<span class="hljs-comment">// 3. Jump Search</span>
<span class="hljs-comment">// Time: O(√n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpSearch</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> n = arr.size();
    <span class="hljs-keyword">int</span> step = <span class="hljs-built_in">sqrt</span>(n);
    <span class="hljs-keyword">int</span> prev = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Find the block where element is present</span>
    <span class="hljs-keyword">while</span> (arr[min(step, n) - <span class="hljs-number">1</span>] &lt; target) {
        prev = step;
        step += <span class="hljs-built_in">sqrt</span>(n);

        <span class="hljs-keyword">if</span> (prev &gt;= n) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }
    }

    <span class="hljs-comment">// Linear search in the block</span>
    <span class="hljs-keyword">while</span> (arr[prev] &lt; target) {
        prev++;

        <span class="hljs-keyword">if</span> (prev == min(step, n)) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }
    }

    <span class="hljs-keyword">if</span> (arr[prev] == target) {
        <span class="hljs-keyword">return</span> prev;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// 4. Interpolation Search</span>
<span class="hljs-comment">// Time: O(log log n) average, O(n) worst</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpolationSearch</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; target &gt;= arr[left] &amp;&amp; target &lt;= arr[right]) {
        <span class="hljs-keyword">if</span> (left == right) {
            <span class="hljs-keyword">return</span> arr[left] == target ? left : <span class="hljs-number">-1</span>;
        }

        <span class="hljs-comment">// Calculate position using interpolation formula</span>
        <span class="hljs-keyword">int</span> pos = left + ((<span class="hljs-keyword">double</span>)(target - arr[left]) * (right - left)) / (arr[right] - arr[left]);

        <span class="hljs-keyword">if</span> (arr[pos] == target) {
            <span class="hljs-keyword">return</span> pos;
        }

        <span class="hljs-keyword">if</span> (arr[pos] &lt; target) {
            left = pos + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            right = pos - <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// 5. Exponential Search</span>
<span class="hljs-comment">// Time: O(log n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearchRange</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
    <span class="hljs-keyword">while</span> (left &lt;= right) {
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (arr[mid] == target) {
            <span class="hljs-keyword">return</span> mid;
        }

        <span class="hljs-keyword">if</span> (arr[mid] &gt; target) {
            right = mid - <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            left = mid + <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exponentialSearch</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> n = arr.size();

    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>] == target) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// Find range for binary search</span>
    <span class="hljs-keyword">int</span> bound = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (bound &lt; n &amp;&amp; arr[bound] &lt;= target) {
        bound *= <span class="hljs-number">2</span>;
    }

    <span class="hljs-keyword">return</span> binarySearchRange(arr, target, bound / <span class="hljs-number">2</span>, min(bound, n - <span class="hljs-number">1</span>));
}

<span class="hljs-comment">// 6. Ternary Search</span>
<span class="hljs-comment">// Time: O(log₃ n), Space: O(log n)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ternarySearch</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
    <span class="hljs-keyword">if</span> (left &gt; right) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">int</span> mid1 = left + (right - left) / <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> mid2 = right - (right - left) / <span class="hljs-number">3</span>;

    <span class="hljs-keyword">if</span> (arr[mid1] == target) {
        <span class="hljs-keyword">return</span> mid1;
    }
    <span class="hljs-keyword">if</span> (arr[mid2] == target) {
        <span class="hljs-keyword">return</span> mid2;
    }

    <span class="hljs-keyword">if</span> (target &lt; arr[mid1]) {
        <span class="hljs-keyword">return</span> ternarySearch(arr, target, left, mid1 - <span class="hljs-number">1</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid2]) {
        <span class="hljs-keyword">return</span> ternarySearch(arr, target, mid2 + <span class="hljs-number">1</span>, right);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> ternarySearch(arr, target, mid1 + <span class="hljs-number">1</span>, mid2 - <span class="hljs-number">1</span>);
    }
}

<span class="hljs-comment">// Advanced Search Problems</span>

<span class="hljs-comment">// Search in Rotated Sorted Array</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchRotatedArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt;= right) {
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (arr[mid] == target) {
            <span class="hljs-keyword">return</span> mid;
        }

        <span class="hljs-keyword">if</span> (arr[left] &lt;= arr[mid]) {
            <span class="hljs-comment">// Left half is sorted</span>
            <span class="hljs-keyword">if</span> (target &gt;= arr[left] &amp;&amp; target &lt; arr[mid]) {
                right = mid - <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                left = mid + <span class="hljs-number">1</span>;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Right half is sorted</span>
            <span class="hljs-keyword">if</span> (target &gt; arr[mid] &amp;&amp; target &lt;= arr[right]) {
                left = mid + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                right = mid - <span class="hljs-number">1</span>;
            }
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// Find Peak Element</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) {
            right = mid;
        } <span class="hljs-keyword">else</span> {
            left = mid + <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">return</span> left;
}

<span class="hljs-comment">// Find Minimum in Rotated Sorted Array</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinRotated</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

        <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[right]) {
            left = mid + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            right = mid;
        }
    }

    <span class="hljs-keyword">return</span> arr[left];
}

<span class="hljs-comment">// Search Utilities</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchUtils</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Generate sorted array for testing</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">generateSortedArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> minVal = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">1000</span>)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(size)</span></span>;
        random_device rd;
        <span class="hljs-function">mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>;
        <span class="hljs-function">uniform_int_distribution&lt;&gt; <span class="hljs-title">dis</span><span class="hljs-params">(minVal, maxVal)</span></span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
            arr[i] = dis(gen);
        }

        sort(arr.begin(), arr.end());
        <span class="hljs-keyword">return</span> arr;
    }

    <span class="hljs-comment">// Measure search performance</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurePerformance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*searchFunc)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;, <span class="hljs-keyword">int</span>),
                                  <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name)</span> </span>{
        <span class="hljs-keyword">auto</span> start = high_resolution_clock::now();
        <span class="hljs-keyword">int</span> result = searchFunc(arr, target);
        <span class="hljs-keyword">auto</span> end = high_resolution_clock::now();

        <span class="hljs-keyword">auto</span> duration = duration_cast&lt;microseconds&gt;(end - start);
        <span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; duration.count() &lt;&lt; <span class="hljs-string">" microseconds, Result: "</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Find closest element</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findClosest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">if</span> (arr.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> right = arr.size() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> closest = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">while</span> (left &lt;= right) {
            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;

            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(arr[mid] - target) &lt; <span class="hljs-built_in">abs</span>(arr[closest] - target)) {
                closest = mid;
            }

            <span class="hljs-keyword">if</span> (arr[mid] == target) {
                <span class="hljs-keyword">return</span> mid;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
                left = mid + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                right = mid - <span class="hljs-number">1</span>;
            }
        }

        <span class="hljs-keyword">return</span> closest;
    }

    <span class="hljs-comment">// Count occurrences</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countOccurrences</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">auto</span> range = findRange(arr, target);
        <span class="hljs-keyword">if</span> (range.first == <span class="hljs-number">-1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">return</span> range.second - range.first + <span class="hljs-number">1</span>;
    }
};

<span class="hljs-comment">// Print vector utility</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : arr) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Searching Algorithms Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test data</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sortedArray = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">25</span>};
    <span class="hljs-keyword">int</span> target = <span class="hljs-number">13</span>;

    printVector(sortedArray, <span class="hljs-string">"Sorted array"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Target: "</span> &lt;&lt; target &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Basic Search Algorithms ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Linear Search: "</span> &lt;&lt; linearSearch(sortedArray, target) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Binary Search (Iterative): "</span> &lt;&lt; binarySearch(sortedArray, target) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Binary Search (Recursive): "</span> &lt;&lt; binarySearchRecursive(sortedArray, target, <span class="hljs-number">0</span>, sortedArray.size() - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Advanced Search Algorithms ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Jump Search: "</span> &lt;&lt; jumpSearch(sortedArray, target) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Interpolation Search: "</span> &lt;&lt; interpolationSearch(sortedArray, target) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Exponential Search: "</span> &lt;&lt; exponentialSearch(sortedArray, target) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Ternary Search: "</span> &lt;&lt; ternarySearch(sortedArray, target, <span class="hljs-number">0</span>, sortedArray.size() - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test with duplicates</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arrayWithDuplicates = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Binary Search Variations ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printVector(arrayWithDuplicates, <span class="hljs-string">"Array with duplicates"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"First occurrence of 2: "</span> &lt;&lt; findFirstOccurrence(arrayWithDuplicates, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Last occurrence of 6: "</span> &lt;&lt; findLastOccurrence(arrayWithDuplicates, <span class="hljs-number">6</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">auto</span> range = findRange(arrayWithDuplicates, <span class="hljs-number">4</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Range of 4: ["</span> &lt;&lt; range.first &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; range.second &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Advanced problems</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Advanced Search Problems ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rotatedArray = {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
    printVector(rotatedArray, <span class="hljs-string">"Rotated array"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Search 0 in rotated array: "</span> &lt;&lt; searchRotatedArray(rotatedArray, <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Find minimum in rotated array: "</span> &lt;&lt; findMinRotated(rotatedArray) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; peakArray = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>};
    printVector(peakArray, <span class="hljs-string">"Peak array"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Peak element index: "</span> &lt;&lt; findPeakElement(peakArray) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Performance comparison</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Performance Comparison (10000 elements) ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; largeArray = SearchUtils::generateSortedArray(<span class="hljs-number">10000</span>);
    <span class="hljs-keyword">int</span> searchTarget = largeArray[rand() % largeArray.size()];

    SearchUtils::measurePerformance(linearSearch, largeArray, searchTarget, <span class="hljs-string">"Linear Search"</span>);
    SearchUtils::measurePerformance(binarySearch, largeArray, searchTarget, <span class="hljs-string">"Binary Search"</span>);
    SearchUtils::measurePerformance(jumpSearch, largeArray, searchTarget, <span class="hljs-string">"Jump Search"</span>);
    SearchUtils::measurePerformance(interpolationSearch, largeArray, searchTarget, <span class="hljs-string">"Interpolation Search"</span>);

    <span class="hljs-comment">// Utility demonstrations</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Search Utilities ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Closest to 14 in sorted array: "</span> &lt;&lt; SearchUtils::findClosest(sortedArray, <span class="hljs-number">14</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Count of 2 in duplicates array: "</span> &lt;&lt; SearchUtils::countOccurrences(arrayWithDuplicates, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="algorithm-selection-guide">Algorithm Selection Guide:</h3>
<ol>
<li>
<p><strong>Linear Search</strong>:</p>
<ul>
<li>✅ Unsorted data</li>
<li>✅ Small datasets (&lt; 100 elements)</li>
<li>✅ Simple implementation needed</li>
<li>❌ Large datasets</li>
</ul>
</li>
<li>
<p><strong>Binary Search</strong>:</p>
<ul>
<li>✅ Sorted data</li>
<li>✅ Large datasets</li>
<li>✅ Guaranteed O(log n) performance</li>
<li>❌ Unsorted data</li>
</ul>
</li>
<li>
<p><strong>Jump Search</strong>:</p>
<ul>
<li>✅ Sorted data, better than linear</li>
<li>✅ When binary search overhead is concern</li>
<li>❌ Generally worse than binary search</li>
</ul>
</li>
<li>
<p><strong>Interpolation Search</strong>:</p>
<ul>
<li>✅ Uniformly distributed sorted data</li>
<li>✅ Very large datasets</li>
<li>❌ Non-uniform distribution</li>
</ul>
</li>
</ol>
<h3 id="common-pitfalls">Common Pitfalls:</h3>
<ol>
<li>
<p><strong>Integer overflow</strong>: In mid calculation</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bad: Can overflow</span>
<span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((left + right) / <span class="hljs-number">2</span>);

<span class="hljs-comment">// Good: Prevents overflow</span>
<span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);
</div></code></pre>
</li>
<li>
<p><strong>Infinite loops</strong>: Incorrect boundary updates</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bad: Can cause infinite loop</span>
<span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
  left = mid; <span class="hljs-comment">// Should be mid + 1</span>
}
</div></code></pre>
</li>
<li>
<p><strong>Off-by-one errors</strong>: Incorrect loop conditions</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Correct condition for binary search</span>
<span class="hljs-keyword">while</span> (left &lt;= right) { <span class="hljs-comment">// Note: &lt;=, not &lt;</span>
</div></code></pre>
</li>
<li>
<p><strong>Unsorted data</strong>: Using binary search on unsorted array</p>
</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-search-insert-position">Problem 1: Search Insert Position</h3>
<p><strong>Question</strong>: Find the index where target should be inserted in sorted array.</p>
<p><strong>Example</strong>: <code>nums = [1,3,5,6], target = 5</code> → <code>2</code></p>
<p><strong>Solution</strong>:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">searchInsert</span>(<span class="hljs-params">nums, target</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>,
    right = nums.length - <span class="hljs-number">1</span>;

  <span class="hljs-keyword">while</span> (left &lt;= right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(left + (right - left) / <span class="hljs-number">2</span>);

    <span class="hljs-keyword">if</span> (nums[mid] === target) {
      <span class="hljs-keyword">return</span> mid;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) {
      left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      right = mid - <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">return</span> left;
}
</div></code></pre>
<h3 id="problem-2-find-first-and-last-position">Problem 2: Find First and Last Position</h3>
<p><strong>Question</strong>: Find first and last position of target in sorted array.</p>
<p><strong>Hint</strong>: Use modified binary search to find leftmost and rightmost occurrences.</p>
<h3 id="problem-3-search-in-2d-matrix-ii">Problem 3: Search in 2D Matrix II</h3>
<p><strong>Question</strong>: Search target in matrix where each row and column is sorted.</p>
<p><strong>Hint</strong>: Start from top-right or bottom-left corner.</p>
<h3 id="problem-4-find-minimum-in-rotated-sorted-array">Problem 4: Find Minimum in Rotated Sorted Array</h3>
<p><strong>Question</strong>: Find minimum element in rotated sorted array.</p>
<p><strong>Hint</strong>: Use binary search with rotation logic.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Algorithm selection</strong>: Can you choose the right search algorithm?</li>
<li><strong>Implementation correctness</strong>: Handle edge cases and boundaries</li>
<li><strong>Complexity analysis</strong>: Understand time/space trade-offs</li>
<li><strong>Problem variations</strong>: Adapt to different constraints</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Binary search variations</strong>: First/last occurrence, insert position</li>
<li><strong>Rotated arrays</strong>: Search in rotated sorted arrays</li>
<li><strong>2D searching</strong>: Matrix search problems</li>
<li><strong>Peak finding</strong>: Local maxima/minima</li>
<li><strong>Range queries</strong>: Finding ranges and counts</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Using linear search when binary search is possible</li>
<li>Integer overflow in mid calculation</li>
<li>Infinite loops due to incorrect boundaries</li>
<li>Not handling empty arrays or edge cases</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Clarify requirements</strong>: Sorted? Duplicates? Return index or boolean?</li>
<li><strong>Start with brute force</strong>: Then optimize to binary search</li>
<li><strong>Draw the search space</strong>: Visualize the problem</li>
<li><strong>Test edge cases</strong>: Empty array, single element, target not found</li>
<li><strong>Practice variations</strong>: Master the binary search template</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Binary search is powerful</strong> - O(log n) vs O(n) is huge for large data</li>
<li><strong>Sorted data enables efficiency</strong> - Always consider if sorting first helps</li>
<li><strong>Master the template</strong> - Binary search has many variations</li>
<li><strong>Handle edge cases</strong> - Empty arrays, duplicates, boundaries</li>
<li><strong>Choose wisely</strong> - Linear search is fine for small datasets</li>
<li><strong>Practice variations</strong> - First/last occurrence, rotated arrays, 2D matrices</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Tree Traversals and see how searching principles apply to hierarchical data structures.</p>
<h1 id="chapter-9-tree-traversals---navigating-hierarchical-data">Chapter 9: Tree Traversals - Navigating Hierarchical Data</h1>
<h2 id="%F0%9F%8E%AF-what-are-tree-traversals">🎯 What are Tree Traversals?</h2>
<p><strong>Tree traversal</strong> is the process of visiting each node in a tree data structure exactly once in a systematic way. Unlike linear data structures (arrays, linked lists), trees are hierarchical, so there are multiple ways to traverse them.</p>
<h3 id="why-tree-traversals-matter">Why Tree Traversals Matter:</h3>
<ul>
<li><strong>Data processing</strong>: Process all nodes in a specific order</li>
<li><strong>Tree algorithms</strong>: Foundation for search, insertion, deletion</li>
<li><strong>Expression evaluation</strong>: Parse mathematical/logical expressions</li>
<li><strong>File systems</strong>: Navigate directory structures</li>
<li><strong>Database indexing</strong>: B-tree operations</li>
<li><strong>Compiler design</strong>: Abstract syntax tree processing</li>
</ul>
<h3 id="traversal-categories">Traversal Categories:</h3>
<ol>
<li>
<p><strong>Depth-First Search (DFS)</strong>: Go deep before going wide</p>
<ul>
<li>Inorder (Left → Root → Right)</li>
<li>Preorder (Root → Left → Right)</li>
<li>Postorder (Left → Right → Root)</li>
</ul>
</li>
<li>
<p><strong>Breadth-First Search (BFS)</strong>: Go wide before going deep</p>
<ul>
<li>Level-order traversal</li>
</ul>
</li>
</ol>
<hr>
<h2 id="%F0%9F%8C%B3-tree-traversal-overview">🌳 Tree Traversal Overview</h2>
<table>
<thead>
<tr>
<th>Traversal</th>
<th>Order</th>
<th>Use Cases</th>
<th>Time</th>
<th>Space</th>
<th>Stack Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Inorder</strong></td>
<td>L→R→R</td>
<td>BST sorted output, expression evaluation</td>
<td>O(n)</td>
<td>O(h)</td>
<td>Recursive: O(h)</td>
</tr>
<tr>
<td><strong>Preorder</strong></td>
<td>R→L→R</td>
<td>Tree copying, prefix expressions</td>
<td>O(n)</td>
<td>O(h)</td>
<td>Recursive: O(h)</td>
</tr>
<tr>
<td><strong>Postorder</strong></td>
<td>L→R→R</td>
<td>Tree deletion, postfix expressions</td>
<td>O(n)</td>
<td>O(h)</td>
<td>Recursive: O(h)</td>
</tr>
<tr>
<td><strong>Level-order</strong></td>
<td>Level by level</td>
<td>Tree printing, shortest path</td>
<td>O(n)</td>
<td>O(w)</td>
<td>Queue: O(w)</td>
</tr>
</tbody>
</table>
<p><em>h = height of tree, w = maximum width of tree</em></p>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Tree Node Definition</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(val, left = null, right = null) {
    <span class="hljs-keyword">this</span>.val = val;
    <span class="hljs-keyword">this</span>.left = left;
    <span class="hljs-keyword">this</span>.right = right;
  }
}

<span class="hljs-comment">// Tree Traversal Implementations</span>

<span class="hljs-comment">// ===== DEPTH-FIRST SEARCH (DFS) TRAVERSALS =====</span>

<span class="hljs-comment">// 1. INORDER TRAVERSAL (Left → Root → Right)</span>
<span class="hljs-comment">// Use case: Get sorted sequence from BST</span>

<span class="hljs-comment">// Recursive Inorder</span>
<span class="hljs-comment">// Time: O(n), Space: O(h) where h is height</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inorderRecursive</span>(<span class="hljs-params">root, result = []</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Traverse left subtree</span>
  inorderRecursive(root.left, result);

  <span class="hljs-comment">// Visit root</span>
  result.push(root.val);

  <span class="hljs-comment">// Traverse right subtree</span>
  inorderRecursive(root.right, result);

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Iterative Inorder using Stack</span>
<span class="hljs-comment">// Time: O(n), Space: O(h)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inorderIterative</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> stack = [];
  <span class="hljs-keyword">let</span> current = root;

  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span> || stack.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Go to the leftmost node</span>
    <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {
      stack.push(current);
      current = current.left;
    }

    <span class="hljs-comment">// Current is null, so we backtrack</span>
    current = stack.pop();
    result.push(current.val);

    <span class="hljs-comment">// Visit right subtree</span>
    current = current.right;
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Morris Inorder Traversal (No extra space)</span>
<span class="hljs-comment">// Time: O(n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inorderMorris</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">let</span> current = root;

  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (current.left === <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// No left child, visit current and go right</span>
      result.push(current.val);
      current = current.right;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Find inorder predecessor</span>
      <span class="hljs-keyword">let</span> predecessor = current.left;
      <span class="hljs-keyword">while</span> (predecessor.right !== <span class="hljs-literal">null</span> &amp;&amp; predecessor.right !== current) {
        predecessor = predecessor.right;
      }

      <span class="hljs-keyword">if</span> (predecessor.right === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// Make current the right child of predecessor</span>
        predecessor.right = current;
        current = current.left;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Revert the changes</span>
        predecessor.right = <span class="hljs-literal">null</span>;
        result.push(current.val);
        current = current.right;
      }
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 2. PREORDER TRAVERSAL (Root → Left → Right)</span>
<span class="hljs-comment">// Use case: Tree copying, prefix expressions</span>

<span class="hljs-comment">// Recursive Preorder</span>
<span class="hljs-comment">// Time: O(n), Space: O(h)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preorderRecursive</span>(<span class="hljs-params">root, result = []</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Visit root</span>
  result.push(root.val);

  <span class="hljs-comment">// Traverse left subtree</span>
  preorderRecursive(root.left, result);

  <span class="hljs-comment">// Traverse right subtree</span>
  preorderRecursive(root.right, result);

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Iterative Preorder using Stack</span>
<span class="hljs-comment">// Time: O(n), Space: O(h)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preorderIterative</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> stack = [root];

  <span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> node = stack.pop();
    result.push(node.val);

    <span class="hljs-comment">// Push right first, then left (stack is LIFO)</span>
    <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
      stack.push(node.right);
    }
    <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
      stack.push(node.left);
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Morris Preorder Traversal</span>
<span class="hljs-comment">// Time: O(n), Space: O(1)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preorderMorris</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">let</span> current = root;

  <span class="hljs-keyword">while</span> (current !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (current.left === <span class="hljs-literal">null</span>) {
      result.push(current.val);
      current = current.right;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">let</span> predecessor = current.left;
      <span class="hljs-keyword">while</span> (predecessor.right !== <span class="hljs-literal">null</span> &amp;&amp; predecessor.right !== current) {
        predecessor = predecessor.right;
      }

      <span class="hljs-keyword">if</span> (predecessor.right === <span class="hljs-literal">null</span>) {
        result.push(current.val); <span class="hljs-comment">// Visit before going left</span>
        predecessor.right = current;
        current = current.left;
      } <span class="hljs-keyword">else</span> {
        predecessor.right = <span class="hljs-literal">null</span>;
        current = current.right;
      }
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 3. POSTORDER TRAVERSAL (Left → Right → Root)</span>
<span class="hljs-comment">// Use case: Tree deletion, postfix expressions</span>

<span class="hljs-comment">// Recursive Postorder</span>
<span class="hljs-comment">// Time: O(n), Space: O(h)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postorderRecursive</span>(<span class="hljs-params">root, result = []</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Traverse left subtree</span>
  postorderRecursive(root.left, result);

  <span class="hljs-comment">// Traverse right subtree</span>
  postorderRecursive(root.right, result);

  <span class="hljs-comment">// Visit root</span>
  result.push(root.val);

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Iterative Postorder using Two Stacks</span>
<span class="hljs-comment">// Time: O(n), Space: O(h)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postorderIterativeTwoStacks</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> stack1 = [root];
  <span class="hljs-keyword">const</span> stack2 = [];
  <span class="hljs-keyword">const</span> result = [];

  <span class="hljs-comment">// First stack for traversal, second for result order</span>
  <span class="hljs-keyword">while</span> (stack1.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> node = stack1.pop();
    stack2.push(node);

    <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
      stack1.push(node.left);
    }
    <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
      stack1.push(node.right);
    }
  }

  <span class="hljs-comment">// Pop from second stack to get postorder</span>
  <span class="hljs-keyword">while</span> (stack2.length &gt; <span class="hljs-number">0</span>) {
    result.push(stack2.pop().val);
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Iterative Postorder using One Stack</span>
<span class="hljs-comment">// Time: O(n), Space: O(h)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postorderIterativeOneStack</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> stack = [];
  <span class="hljs-keyword">let</span> lastVisited = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">let</span> current = root;

  <span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span> || current !== <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
      stack.push(current);
      current = current.left;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> peekNode = stack[stack.length - <span class="hljs-number">1</span>];

      <span class="hljs-comment">// If right child exists and hasn't been processed yet</span>
      <span class="hljs-keyword">if</span> (peekNode.right !== <span class="hljs-literal">null</span> &amp;&amp; lastVisited !== peekNode.right) {
        current = peekNode.right;
      } <span class="hljs-keyword">else</span> {
        result.push(peekNode.val);
        lastVisited = stack.pop();
      }
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== BREADTH-FIRST SEARCH (BFS) TRAVERSAL =====</span>

<span class="hljs-comment">// 4. LEVEL-ORDER TRAVERSAL (Breadth-First)</span>
<span class="hljs-comment">// Use case: Tree printing, shortest path in unweighted trees</span>

<span class="hljs-comment">// Basic Level-order using Queue</span>
<span class="hljs-comment">// Time: O(n), Space: O(w) where w is maximum width</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> queue = [root];

  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> node = queue.shift();
    result.push(node.val);

    <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
      queue.push(node.left);
    }
    <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
      queue.push(node.right);
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Level-order with Level Separation</span>
<span class="hljs-comment">// Returns array of arrays, each representing a level</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">levelOrderByLevels</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> queue = [root];

  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> levelSize = queue.length;
    <span class="hljs-keyword">const</span> currentLevel = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
      <span class="hljs-keyword">const</span> node = queue.shift();
      currentLevel.push(node.val);

      <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
        queue.push(node.left);
      }
      <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
        queue.push(node.right);
      }
    }

    result.push(currentLevel);
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Zigzag Level-order Traversal</span>
<span class="hljs-comment">// Alternate between left-to-right and right-to-left</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zigzagLevelOrder</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> queue = [root];
  <span class="hljs-keyword">let</span> leftToRight = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> levelSize = queue.length;
    <span class="hljs-keyword">const</span> currentLevel = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
      <span class="hljs-keyword">const</span> node = queue.shift();

      <span class="hljs-keyword">if</span> (leftToRight) {
        currentLevel.push(node.val);
      } <span class="hljs-keyword">else</span> {
        currentLevel.unshift(node.val);
      }

      <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
        queue.push(node.left);
      }
      <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
        queue.push(node.right);
      }
    }

    result.push(currentLevel);
    leftToRight = !leftToRight;
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Reverse Level-order Traversal (Bottom-up)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseLevelOrder</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> queue = [root];

  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> levelSize = queue.length;
    <span class="hljs-keyword">const</span> currentLevel = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
      <span class="hljs-keyword">const</span> node = queue.shift();
      currentLevel.push(node.val);

      <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
        queue.push(node.left);
      }
      <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
        queue.push(node.right);
      }
    }

    result.unshift(currentLevel); <span class="hljs-comment">// Add to beginning</span>
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== ADVANCED TRAVERSAL TECHNIQUES =====</span>

<span class="hljs-comment">// Vertical Order Traversal</span>
<span class="hljs-comment">// Group nodes by their horizontal distance from root</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">verticalOrder</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> columnMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">const</span> queue = [[root, <span class="hljs-number">0</span>]]; <span class="hljs-comment">// [node, column]</span>

  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> [node, col] = queue.shift();

    <span class="hljs-keyword">if</span> (!columnMap.has(col)) {
      columnMap.set(col, []);
    }
    columnMap.get(col).push(node.val);

    <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
      queue.push([node.left, col - <span class="hljs-number">1</span>]);
    }
    <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
      queue.push([node.right, col + <span class="hljs-number">1</span>]);
    }
  }

  <span class="hljs-comment">// Sort by column and return values</span>
  <span class="hljs-keyword">const</span> sortedColumns = <span class="hljs-built_in">Array</span>.from(columnMap.keys()).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);
  <span class="hljs-keyword">return</span> sortedColumns.map(<span class="hljs-function">(<span class="hljs-params">col</span>) =&gt;</span> columnMap.get(col));
}

<span class="hljs-comment">// Boundary Traversal</span>
<span class="hljs-comment">// Traverse the boundary of the tree (anticlockwise)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boundaryTraversal</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];

  <span class="hljs-comment">// Add root</span>
  result.push(root.val);

  <span class="hljs-keyword">if</span> (root.left === <span class="hljs-literal">null</span> &amp;&amp; root.right === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// Single node</span>
  }

  <span class="hljs-comment">// Add left boundary (excluding leaves)</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLeftBoundary</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span> || (node.left === <span class="hljs-literal">null</span> &amp;&amp; node.right === <span class="hljs-literal">null</span>)) {
      <span class="hljs-keyword">return</span>;
    }

    result.push(node.val);

    <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
      addLeftBoundary(node.left);
    } <span class="hljs-keyword">else</span> {
      addLeftBoundary(node.right);
    }
  }

  <span class="hljs-comment">// Add leaves</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLeaves</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (node.left === <span class="hljs-literal">null</span> &amp;&amp; node.right === <span class="hljs-literal">null</span>) {
      result.push(node.val);
      <span class="hljs-keyword">return</span>;
    }

    addLeaves(node.left);
    addLeaves(node.right);
  }

  <span class="hljs-comment">// Add right boundary (excluding leaves, in reverse)</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRightBoundary</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span> || (node.left === <span class="hljs-literal">null</span> &amp;&amp; node.right === <span class="hljs-literal">null</span>)) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
      addRightBoundary(node.right);
    } <span class="hljs-keyword">else</span> {
      addRightBoundary(node.left);
    }

    result.push(node.val);
  }

  addLeftBoundary(root.left);
  addLeaves(root);
  addRightBoundary(root.right);

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Diagonal Traversal</span>
<span class="hljs-comment">// Traverse diagonally (nodes at same diagonal distance)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diagonalTraversal</span>(<span class="hljs-params">root</span>) </span>{
  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> diagonalMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">node, diagonal</span>) </span>{
    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (!diagonalMap.has(diagonal)) {
      diagonalMap.set(diagonal, []);
    }
    diagonalMap.get(diagonal).push(node.val);

    <span class="hljs-comment">// Left child increases diagonal distance</span>
    traverse(node.left, diagonal + <span class="hljs-number">1</span>);
    <span class="hljs-comment">// Right child maintains same diagonal distance</span>
    traverse(node.right, diagonal);
  }

  traverse(root, <span class="hljs-number">0</span>);

  <span class="hljs-comment">// Convert map to array</span>
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; diagonalMap.size; i++) {
    <span class="hljs-keyword">if</span> (diagonalMap.has(i)) {
      result.push(...diagonalMap.get(i));
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== TRAVERSAL UTILITIES =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversalUtils</span> </span>{
  <span class="hljs-comment">// Build tree from array (level-order)</span>
  <span class="hljs-keyword">static</span> buildTreeFromArray(arr) {
    <span class="hljs-keyword">if</span> (!arr || arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> TreeNode(arr[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">const</span> queue = [root];
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt; arr.length) {
      <span class="hljs-keyword">const</span> node = queue.shift();

      <span class="hljs-keyword">if</span> (i &lt; arr.length &amp;&amp; arr[i] !== <span class="hljs-literal">null</span>) {
        node.left = <span class="hljs-keyword">new</span> TreeNode(arr[i]);
        queue.push(node.left);
      }
      i++;

      <span class="hljs-keyword">if</span> (i &lt; arr.length &amp;&amp; arr[i] !== <span class="hljs-literal">null</span>) {
        node.right = <span class="hljs-keyword">new</span> TreeNode(arr[i]);
        queue.push(node.right);
      }
      i++;
    }

    <span class="hljs-keyword">return</span> root;
  }

  <span class="hljs-comment">// Convert tree to array (level-order)</span>
  <span class="hljs-keyword">static</span> treeToArray(root) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> [];

    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> queue = [root];

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> node = queue.shift();

      <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
        result.push(<span class="hljs-literal">null</span>);
      } <span class="hljs-keyword">else</span> {
        result.push(node.val);
        queue.push(node.left);
        queue.push(node.right);
      }
    }

    <span class="hljs-comment">// Remove trailing nulls</span>
    <span class="hljs-keyword">while</span> (result.length &gt; <span class="hljs-number">0</span> &amp;&amp; result[result.length - <span class="hljs-number">1</span>] === <span class="hljs-literal">null</span>) {
      result.pop();
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Print tree structure</span>
  <span class="hljs-keyword">static</span> printTree(root, prefix = <span class="hljs-string">""</span>, isLast = <span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-built_in">console</span>.log(prefix + (isLast ? <span class="hljs-string">"└── "</span> : <span class="hljs-string">"├── "</span>) + root.val);

    <span class="hljs-keyword">const</span> children = [root.left, root.right].filter(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> child !== <span class="hljs-literal">null</span>);

    children.forEach(<span class="hljs-function">(<span class="hljs-params">child, index</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> isLastChild = index === children.length - <span class="hljs-number">1</span>;
      <span class="hljs-keyword">const</span> newPrefix = prefix + (isLast ? <span class="hljs-string">"    "</span> : <span class="hljs-string">"│   "</span>);
      TraversalUtils.printTree(child, newPrefix, isLastChild);
    });
  }

  <span class="hljs-comment">// Get tree height</span>
  <span class="hljs-keyword">static</span> getHeight(root) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> (
      <span class="hljs-number">1</span> +
      <span class="hljs-built_in">Math</span>.max(
        TraversalUtils.getHeight(root.left),
        TraversalUtils.getHeight(root.right)
      )
    );
  }

  <span class="hljs-comment">// Get tree width (maximum nodes at any level)</span>
  <span class="hljs-keyword">static</span> getWidth(root) {
    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">let</span> maxWidth = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> queue = [root];

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> levelSize = queue.length;
      maxWidth = <span class="hljs-built_in">Math</span>.max(maxWidth, levelSize);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
        <span class="hljs-keyword">const</span> node = queue.shift();

        <span class="hljs-keyword">if</span> (node.left !== <span class="hljs-literal">null</span>) {
          queue.push(node.left);
        }
        <span class="hljs-keyword">if</span> (node.right !== <span class="hljs-literal">null</span>) {
          queue.push(node.right);
        }
      }
    }

    <span class="hljs-keyword">return</span> maxWidth;
  }

  <span class="hljs-comment">// Compare all traversal methods</span>
  <span class="hljs-keyword">static</span> compareTraversals(root) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Tree Traversal Comparison ==="</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Inorder (Recursive):"</span>, inorderRecursive(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Inorder (Iterative):"</span>, inorderIterative(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Inorder (Morris):"</span>, inorderMorris(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Preorder (Recursive):"</span>, preorderRecursive(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Preorder (Iterative):"</span>, preorderIterative(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Postorder (Recursive):"</span>, postorderRecursive(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Postorder (Iterative):"</span>, postorderIterativeTwoStacks(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Level-order:"</span>, levelOrder(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Level-order by levels:"</span>, levelOrderByLevels(root));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Zigzag level-order:"</span>, zigzagLevelOrder(root));
  }

  <span class="hljs-comment">// Performance measurement</span>
  <span class="hljs-keyword">static</span> measureTraversalPerformance(root, traversalFunc, name) {
    <span class="hljs-keyword">const</span> start = performance.now();
    <span class="hljs-keyword">const</span> result = traversalFunc(root);
    <span class="hljs-keyword">const</span> end = performance.now();

    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">`<span class="hljs-subst">${name}</span>: <span class="hljs-subst">${(end - start).toFixed(<span class="hljs-number">4</span>)}</span>ms, Nodes: <span class="hljs-subst">${result.length}</span>`</span>
    );
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Generate random binary tree</span>
  <span class="hljs-keyword">static</span> generateRandomTree(maxDepth, probability = <span class="hljs-number">0.7</span>) {
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildRandom</span>(<span class="hljs-params">depth</span>) </span>{
      <span class="hljs-keyword">if</span> (depth &gt; maxDepth || <span class="hljs-built_in">Math</span>.random() &gt; probability) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">const</span> val = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>) + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> TreeNode(val);
      node.left = buildRandom(depth + <span class="hljs-number">1</span>);
      node.right = buildRandom(depth + <span class="hljs-number">1</span>);

      <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-keyword">return</span> buildRandom(<span class="hljs-number">0</span>);
  }

  <span class="hljs-comment">// Generate BST from sorted array</span>
  <span class="hljs-keyword">static</span> generateBSTFromSorted(arr) {
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildBST</span>(<span class="hljs-params">start, end</span>) </span>{
      <span class="hljs-keyword">if</span> (start &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((start + end) / <span class="hljs-number">2</span>);
      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> TreeNode(arr[mid]);

      node.left = buildBST(start, mid - <span class="hljs-number">1</span>);
      node.right = buildBST(mid + <span class="hljs-number">1</span>, end);

      <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-keyword">return</span> buildBST(<span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);
  }
}

<span class="hljs-comment">// ===== EXAMPLE USAGE AND TESTING =====</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Tree Traversals Demo ==="</span>);

<span class="hljs-comment">// Create example tree:</span>
<span class="hljs-comment">//       1</span>
<span class="hljs-comment">//      / \</span>
<span class="hljs-comment">//     2   3</span>
<span class="hljs-comment">//    / \</span>
<span class="hljs-comment">//   4   5</span>
<span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">1</span>);
root.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">2</span>);
root.right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>);
root.left.left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">4</span>);
root.left.right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">5</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Tree Structure ==="</span>);
TraversalUtils.printTree(root);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Basic Traversals ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Inorder:"</span>, inorderRecursive(root)); <span class="hljs-comment">// [4, 2, 5, 1, 3]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Preorder:"</span>, preorderRecursive(root)); <span class="hljs-comment">// [1, 2, 4, 5, 3]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Postorder:"</span>, postorderRecursive(root)); <span class="hljs-comment">// [4, 5, 2, 3, 1]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Level-order:"</span>, levelOrder(root)); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Advanced Traversals ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Level-order by levels:"</span>, levelOrderByLevels(root));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Zigzag level-order:"</span>, zigzagLevelOrder(root));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Reverse level-order:"</span>, reverseLevelOrder(root));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Vertical order:"</span>, verticalOrder(root));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Boundary traversal:"</span>, boundaryTraversal(root));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Diagonal traversal:"</span>, diagonalTraversal(root));

<span class="hljs-comment">// Create BST for demonstration</span>
<span class="hljs-keyword">const</span> bstArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
<span class="hljs-keyword">const</span> bst = TraversalUtils.generateBSTFromSorted(bstArray);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== BST Traversals ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"BST Structure:"</span>);
TraversalUtils.printTree(bst);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"BST Inorder (should be sorted):"</span>, inorderRecursive(bst));

<span class="hljs-comment">// Performance comparison</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Performance Comparison ==="</span>);
<span class="hljs-keyword">const</span> largeTree = TraversalUtils.generateRandomTree(<span class="hljs-number">10</span>);

TraversalUtils.measureTraversalPerformance(
  largeTree,
  inorderRecursive,
  <span class="hljs-string">"Inorder Recursive"</span>
);
TraversalUtils.measureTraversalPerformance(
  largeTree,
  inorderIterative,
  <span class="hljs-string">"Inorder Iterative"</span>
);
TraversalUtils.measureTraversalPerformance(
  largeTree,
  inorderMorris,
  <span class="hljs-string">"Inorder Morris"</span>
);
TraversalUtils.measureTraversalPerformance(
  largeTree,
  levelOrder,
  <span class="hljs-string">"Level-order"</span>
);

<span class="hljs-comment">// Tree statistics</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Tree Statistics ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Tree height:"</span>, TraversalUtils.getHeight(root));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Tree width:"</span>, TraversalUtils.getWidth(root));

<span class="hljs-comment">// All traversals comparison</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Complete Comparison ==="</span>);
TraversalUtils.compareTraversals(root);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::chrono;

<span class="hljs-comment">// Tree Node Definition</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">nullptr</span>), right(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-comment">// ===== DEPTH-FIRST SEARCH (DFS) TRAVERSALS =====</span>

<span class="hljs-comment">// 1. INORDER TRAVERSAL (Left → Root → Right)</span>

<span class="hljs-comment">// Recursive Inorder</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorderRecursive</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    inorderRecursive(root-&gt;left, result);
    result.push_back(root-&gt;val);
    inorderRecursive(root-&gt;right, result);
}

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderRecursive</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    inorderRecursive(root, result);
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Iterative Inorder</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderIterative</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;
    TreeNode* current = root;

    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span> || !stk.empty()) {
        <span class="hljs-comment">// Go to leftmost node</span>
        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) {
            stk.push(current);
            current = current-&gt;left;
        }

        <span class="hljs-comment">// Backtrack</span>
        current = stk.top();
        stk.pop();
        result.push_back(current-&gt;val);

        <span class="hljs-comment">// Visit right subtree</span>
        current = current-&gt;right;
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Morris Inorder (O(1) space)</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderMorris</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    TreeNode* current = root;

    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">if</span> (current-&gt;left == <span class="hljs-literal">nullptr</span>) {
            result.push_back(current-&gt;val);
            current = current-&gt;right;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Find inorder predecessor</span>
            TreeNode* predecessor = current-&gt;left;
            <span class="hljs-keyword">while</span> (predecessor-&gt;right != <span class="hljs-literal">nullptr</span> &amp;&amp; predecessor-&gt;right != current) {
                predecessor = predecessor-&gt;right;
            }

            <span class="hljs-keyword">if</span> (predecessor-&gt;right == <span class="hljs-literal">nullptr</span>) {
                <span class="hljs-comment">// Make current the right child of predecessor</span>
                predecessor-&gt;right = current;
                current = current-&gt;left;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// Revert changes</span>
                predecessor-&gt;right = <span class="hljs-literal">nullptr</span>;
                result.push_back(current-&gt;val);
                current = current-&gt;right;
            }
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 2. PREORDER TRAVERSAL (Root → Left → Right)</span>

<span class="hljs-comment">// Recursive Preorder</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorderRecursive</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    result.push_back(root-&gt;val);
    preorderRecursive(root-&gt;left, result);
    preorderRecursive(root-&gt;right, result);
}

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderRecursive</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    preorderRecursive(root, result);
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Iterative Preorder</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderIterative</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;
    stk.push(root);

    <span class="hljs-keyword">while</span> (!stk.empty()) {
        TreeNode* node = stk.top();
        stk.pop();
        result.push_back(node-&gt;val);

        <span class="hljs-comment">// Push right first, then left</span>
        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) {
            stk.push(node-&gt;right);
        }
        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) {
            stk.push(node-&gt;left);
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 3. POSTORDER TRAVERSAL (Left → Right → Root)</span>

<span class="hljs-comment">// Recursive Postorder</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorderRecursive</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

    postorderRecursive(root-&gt;left, result);
    postorderRecursive(root-&gt;right, result);
    result.push_back(root-&gt;val);
}

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderRecursive</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    postorderRecursive(root, result);
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Iterative Postorder (Two Stacks)</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderIterativeTwoStacks</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk1, stk2;
    stk1.push(root);

    <span class="hljs-keyword">while</span> (!stk1.empty()) {
        TreeNode* node = stk1.top();
        stk1.pop();
        stk2.push(node);

        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) {
            stk1.push(node-&gt;left);
        }
        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) {
            stk1.push(node-&gt;right);
        }
    }

    <span class="hljs-keyword">while</span> (!stk2.empty()) {
        result.push_back(stk2.top()-&gt;val);
        stk2.pop();
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Iterative Postorder (One Stack)</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderIterativeOneStack</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt; stk;
    TreeNode* lastVisited = <span class="hljs-literal">nullptr</span>;
    TreeNode* current = root;

    <span class="hljs-keyword">while</span> (!stk.empty() || current != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">nullptr</span>) {
            stk.push(current);
            current = current-&gt;left;
        } <span class="hljs-keyword">else</span> {
            TreeNode* peekNode = stk.top();

            <span class="hljs-keyword">if</span> (peekNode-&gt;right != <span class="hljs-literal">nullptr</span> &amp;&amp; lastVisited != peekNode-&gt;right) {
                current = peekNode-&gt;right;
            } <span class="hljs-keyword">else</span> {
                result.push_back(peekNode-&gt;val);
                lastVisited = stk.top();
                stk.pop();
            }
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== BREADTH-FIRST SEARCH (BFS) TRAVERSAL =====</span>

<span class="hljs-comment">// Level-order Traversal</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
    q.push(root);

    <span class="hljs-keyword">while</span> (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        result.push_back(node-&gt;val);

        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) {
            q.push(node-&gt;left);
        }
        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) {
            q.push(node-&gt;right);
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Level-order by Levels</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrderByLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
    q.push(root);

    <span class="hljs-keyword">while</span> (!q.empty()) {
        <span class="hljs-keyword">int</span> levelSize = q.size();
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; currentLevel;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node-&gt;val);

            <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) {
                q.push(node-&gt;left);
            }
            <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) {
                q.push(node-&gt;right);
            }
        }

        result.push_back(currentLevel);
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Zigzag Level-order</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
    <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
    q.push(root);
    <span class="hljs-keyword">bool</span> leftToRight = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">while</span> (!q.empty()) {
        <span class="hljs-keyword">int</span> levelSize = q.size();
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">currentLevel</span><span class="hljs-params">(levelSize)</span></span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();

            <span class="hljs-keyword">int</span> index = leftToRight ? i : levelSize - <span class="hljs-number">1</span> - i;
            currentLevel[index] = node-&gt;val;

            <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) {
                q.push(node-&gt;left);
            }
            <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) {
                q.push(node-&gt;right);
            }
        }

        result.push_back(currentLevel);
        leftToRight = !leftToRight;
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== ADVANCED TRAVERSALS =====</span>

<span class="hljs-comment">// Vertical Order Traversal</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">verticalOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; columnMap;
    <span class="hljs-built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt;&gt; q;
    q.push({root, <span class="hljs-number">0</span>});

    <span class="hljs-keyword">while</span> (!q.empty()) {
        <span class="hljs-keyword">auto</span> [node, col] = q.front();
        q.pop();

        columnMap[col].push_back(node-&gt;val);

        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) {
            q.push({node-&gt;left, col - <span class="hljs-number">1</span>});
        }
        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) {
            q.push({node-&gt;right, col + <span class="hljs-number">1</span>});
        }
    }

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [col, values] : columnMap) {
        result.push_back(values);
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Boundary Traversal</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">boundaryTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    result.push_back(root-&gt;val);

    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Left boundary (excluding leaves)</span>
    function&lt;<span class="hljs-keyword">void</span>(TreeNode*)&gt; addLeftBoundary = [&amp;](TreeNode* node) {
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span> || (node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>)) {
            <span class="hljs-keyword">return</span>;
        }

        result.push_back(node-&gt;val);

        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) {
            addLeftBoundary(node-&gt;left);
        } <span class="hljs-keyword">else</span> {
            addLeftBoundary(node-&gt;right);
        }
    };

    <span class="hljs-comment">// Leaves</span>
    function&lt;<span class="hljs-keyword">void</span>(TreeNode*)&gt; addLeaves = [&amp;](TreeNode* node) {
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>) {
            result.push_back(node-&gt;val);
            <span class="hljs-keyword">return</span>;
        }

        addLeaves(node-&gt;left);
        addLeaves(node-&gt;right);
    };

    <span class="hljs-comment">// Right boundary (excluding leaves, in reverse)</span>
    function&lt;<span class="hljs-keyword">void</span>(TreeNode*)&gt; addRightBoundary = [&amp;](TreeNode* node) {
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span> || (node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>)) {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) {
            addRightBoundary(node-&gt;right);
        } <span class="hljs-keyword">else</span> {
            addRightBoundary(node-&gt;left);
        }

        result.push_back(node-&gt;val);
    };

    addLeftBoundary(root-&gt;left);
    addLeaves(root);
    addRightBoundary(root-&gt;right);

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversalUtils</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Build tree from array</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> TreeNode* <span class="hljs-title">buildTreeFromArray</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
        <span class="hljs-keyword">if</span> (arr.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(arr[<span class="hljs-number">0</span>]);
        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
        q.push(root);
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span> (!q.empty() &amp;&amp; i &lt; arr.size()) {
            TreeNode* node = q.front();
            q.pop();

            <span class="hljs-keyword">if</span> (i &lt; arr.size()) {
                node-&gt;left = <span class="hljs-keyword">new</span> TreeNode(arr[i]);
                q.push(node-&gt;left);
                i++;
            }

            <span class="hljs-keyword">if</span> (i &lt; arr.size()) {
                node-&gt;right = <span class="hljs-keyword">new</span> TreeNode(arr[i]);
                q.push(node-&gt;right);
                i++;
            }
        }

        <span class="hljs-keyword">return</span> root;
    }

    <span class="hljs-comment">// Print tree structure</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">string</span> prefix = <span class="hljs-string">""</span>, <span class="hljs-keyword">bool</span> isLast = <span class="hljs-literal">true</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-built_in">cout</span> &lt;&lt; prefix &lt;&lt; (isLast ? <span class="hljs-string">"└── "</span> : <span class="hljs-string">"├── "</span>) &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-built_in">endl</span>;

        <span class="hljs-built_in">vector</span>&lt;TreeNode*&gt; children;
        <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">nullptr</span>) children.push_back(root-&gt;left);
        <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">nullptr</span>) children.push_back(root-&gt;right);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; children.size(); i++) {
            <span class="hljs-keyword">bool</span> isLastChild = (i == children.size() - <span class="hljs-number">1</span>);
            <span class="hljs-built_in">string</span> newPrefix = prefix + (isLast ? <span class="hljs-string">"    "</span> : <span class="hljs-string">"│   "</span>);
            printTree(children[i], newPrefix, isLastChild);
        }
    }

    <span class="hljs-comment">// Get tree height</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(getHeight(root-&gt;left), getHeight(root-&gt;right));
    }

    <span class="hljs-comment">// Performance measurement</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurePerformance</span><span class="hljs-params">(function&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(TreeNode*)&gt; traversalFunc,
                                  TreeNode* root, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name)</span> </span>{
        <span class="hljs-keyword">auto</span> start = high_resolution_clock::now();
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result = traversalFunc(root);
        <span class="hljs-keyword">auto</span> end = high_resolution_clock::now();

        <span class="hljs-keyword">auto</span> duration = duration_cast&lt;microseconds&gt;(end - start);
        <span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; duration.count() &lt;&lt; <span class="hljs-string">" microseconds, Nodes: "</span> &lt;&lt; result.size() &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Generate BST from sorted array</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> TreeNode* <span class="hljs-title">generateBSTFromSorted</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
        function&lt;TreeNode*(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; buildBST = [&amp;](<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end) -&gt; TreeNode* {
            <span class="hljs-keyword">if</span> (start &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

            <span class="hljs-keyword">int</span> mid = start + (end - start) / <span class="hljs-number">2</span>;
            TreeNode* node = <span class="hljs-keyword">new</span> TreeNode(arr[mid]);

            node-&gt;left = buildBST(start, mid - <span class="hljs-number">1</span>);
            node-&gt;right = buildBST(mid + <span class="hljs-number">1</span>, end);

            <span class="hljs-keyword">return</span> node;
        };

        <span class="hljs-keyword">return</span> buildBST(<span class="hljs-number">0</span>, arr.size() - <span class="hljs-number">1</span>);
    }
};

<span class="hljs-comment">// Print vector utility</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;T&gt;&amp; vec, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; x : vec) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Print 2D vector utility</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print2DVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; vec, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"["</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.size(); i++) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"["</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; vec[i].size(); j++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; vec[i][j];
            <span class="hljs-keyword">if</span> (j &lt; vec[i].size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">", "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span>;
        <span class="hljs-keyword">if</span> (i &lt; vec.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">", "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Tree Traversals Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Create example tree:</span>
    <span class="hljs-comment">//       1</span>
    <span class="hljs-comment">//      / \</span>
    <span class="hljs-comment">//     2   3</span>
    <span class="hljs-comment">//    / \</span>
    <span class="hljs-comment">//   4   5</span>
    TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">1</span>);
    root-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">2</span>);
    root-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>);
    root-&gt;left-&gt;left = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">4</span>);
    root-&gt;left-&gt;right = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">5</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Tree Structure ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    TraversalUtils::printTree(root);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Basic Traversals ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printVector(inorderRecursive(root), <span class="hljs-string">"Inorder"</span>);
    printVector(preorderRecursive(root), <span class="hljs-string">"Preorder"</span>);
    printVector(postorderRecursive(root), <span class="hljs-string">"Postorder"</span>);
    printVector(levelOrder(root), <span class="hljs-string">"Level-order"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Advanced Traversals ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    print2DVector(levelOrderByLevels(root), <span class="hljs-string">"Level-order by levels"</span>);
    print2DVector(zigzagLevelOrder(root), <span class="hljs-string">"Zigzag level-order"</span>);
    print2DVector(verticalOrder(root), <span class="hljs-string">"Vertical order"</span>);
    printVector(boundaryTraversal(root), <span class="hljs-string">"Boundary traversal"</span>);

    <span class="hljs-comment">// Create BST</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; bstArray = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
    TreeNode* bst = TraversalUtils::generateBSTFromSorted(bstArray);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== BST Traversals ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"BST Structure:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    TraversalUtils::printTree(bst);
    printVector(inorderRecursive(bst), <span class="hljs-string">"BST Inorder (should be sorted)"</span>);

    <span class="hljs-comment">// Performance comparison</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Performance Comparison ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    TraversalUtils::measurePerformance(inorderRecursive, root, <span class="hljs-string">"Inorder Recursive"</span>);
    TraversalUtils::measurePerformance(inorderIterative, root, <span class="hljs-string">"Inorder Iterative"</span>);
    TraversalUtils::measurePerformance(inorderMorris, root, <span class="hljs-string">"Inorder Morris"</span>);
    TraversalUtils::measurePerformance(levelOrder, root, <span class="hljs-string">"Level-order"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Tree Statistics ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Tree height: "</span> &lt;&lt; TraversalUtils::getHeight(root) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time--space-complexity">Time &amp; Space Complexity:</h3>
<table>
<thead>
<tr>
<th>Traversal</th>
<th>Time</th>
<th>Space (Recursive)</th>
<th>Space (Iterative)</th>
<th>Space (Morris)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Inorder</strong></td>
<td>O(n)</td>
<td>O(h)</td>
<td>O(h)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>Preorder</strong></td>
<td>O(n)</td>
<td>O(h)</td>
<td>O(h)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>Postorder</strong></td>
<td>O(n)</td>
<td>O(h)</td>
<td>O(h)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>Level-order</strong></td>
<td>O(n)</td>
<td>N/A</td>
<td>O(w)</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p><em>h = height, w = maximum width, n = number of nodes</em></p>
<h3 id="when-to-use-each">When to Use Each:</h3>
<ol>
<li>
<p><strong>Inorder</strong>:</p>
<ul>
<li>✅ BST: Get sorted sequence</li>
<li>✅ Expression trees: Infix notation</li>
<li>✅ Binary tree validation</li>
</ul>
</li>
<li>
<p><strong>Preorder</strong>:</p>
<ul>
<li>✅ Tree copying/serialization</li>
<li>✅ Prefix expressions</li>
<li>✅ Directory listing</li>
</ul>
</li>
<li>
<p><strong>Postorder</strong>:</p>
<ul>
<li>✅ Tree deletion (children first)</li>
<li>✅ Postfix expressions</li>
<li>✅ Calculate tree properties</li>
</ul>
</li>
<li>
<p><strong>Level-order</strong>:</p>
<ul>
<li>✅ Tree printing by levels</li>
<li>✅ Shortest path in unweighted trees</li>
<li>✅ Complete tree operations</li>
</ul>
</li>
</ol>
<h3 id="common-pitfalls">Common Pitfalls:</h3>
<ol>
<li><strong>Stack overflow</strong>: Deep recursion in unbalanced trees</li>
<li><strong>Memory leaks</strong>: Not deallocating tree nodes in C++</li>
<li><strong>Null pointer access</strong>: Not checking for null nodes</li>
<li><strong>Incorrect Morris implementation</strong>: Breaking tree structure permanently</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-binary-tree-right-side-view">Problem 1: Binary Tree Right Side View</h3>
<p><strong>Question</strong>: Return values of nodes you can see from the right side.</p>
<p><strong>Example</strong>: <code>[1,2,3,null,5,null,4]</code> → <code>[1,3,4]</code></p>
<p><strong>Hint</strong>: Use level-order traversal, take last node of each level.</p>
<h3 id="problem-2-binary-tree-vertical-order-traversal">Problem 2: Binary Tree Vertical Order Traversal</h3>
<p><strong>Question</strong>: Return vertical order traversal of binary tree.</p>
<p><strong>Hint</strong>: Use BFS with column tracking.</p>
<h3 id="problem-3-serialize-and-deserialize-binary-tree">Problem 3: Serialize and Deserialize Binary Tree</h3>
<p><strong>Question</strong>: Design algorithm to serialize/deserialize binary tree.</p>
<p><strong>Hint</strong>: Use preorder traversal with null markers.</p>
<h3 id="problem-4-binary-tree-maximum-path-sum">Problem 4: Binary Tree Maximum Path Sum</h3>
<p><strong>Question</strong>: Find maximum path sum between any two nodes.</p>
<p><strong>Hint</strong>: Use postorder traversal with path sum calculation.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Traversal mastery</strong>: Know all four basic traversals</li>
<li><strong>Implementation choice</strong>: Recursive vs iterative vs Morris</li>
<li><strong>Space optimization</strong>: When to use Morris traversal</li>
<li><strong>Problem adaptation</strong>: Apply traversals to solve problems</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Tree validation</strong>: Use inorder for BST validation</li>
<li><strong>Tree construction</strong>: Use preorder/postorder with inorder</li>
<li><strong>Path problems</strong>: Use DFS traversals</li>
<li><strong>Level problems</strong>: Use BFS traversal</li>
<li><strong>Tree views</strong>: Right/left/top/bottom views</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Confusing traversal orders</li>
<li>Not handling null nodes</li>
<li>Stack overflow in deep trees</li>
<li>Inefficient space usage when O(1) is possible</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Master the basics</strong>: Know all four traversals by heart</li>
<li><strong>Practice iterative</strong>: Interviewers often prefer iterative solutions</li>
<li><strong>Consider Morris</strong>: For space-constrained problems</li>
<li><strong>Draw examples</strong>: Visualize traversal order</li>
<li><strong>Handle edge cases</strong>: Empty tree, single node, skewed tree</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Four fundamental traversals</strong> - Each has specific use cases</li>
<li><strong>Recursive vs Iterative</strong> - Trade-off between simplicity and space</li>
<li><strong>Morris traversal</strong> - Achieves O(1) space complexity</li>
<li><strong>Level-order uses queue</strong> - BFS pattern for tree problems</li>
<li><strong>BST inorder is sorted</strong> - Key property for many algorithms</li>
<li><strong>Practice variations</strong> - Zigzag, vertical, boundary traversals</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Basic Graph Theory and see how traversal concepts extend to graph structures.</p>
<h1 id="chapter-10-basic-graph-theory---understanding-connected-data">Chapter 10: Basic Graph Theory - Understanding Connected Data</h1>
<h2 id="%F0%9F%8E%AF-what-are-graphs">🎯 What are Graphs?</h2>
<p><strong>Graphs</strong> are non-linear data structures consisting of vertices (nodes) connected by edges. They represent relationships between entities and are fundamental to modeling real-world problems like social networks, transportation systems, and computer networks.</p>
<h3 id="why-graphs-matter">Why Graphs Matter:</h3>
<ul>
<li><strong>Social networks</strong>: Friends, followers, connections</li>
<li><strong>Transportation</strong>: Roads, flights, routes</li>
<li><strong>Computer networks</strong>: Internet, LANs, routing</li>
<li><strong>Dependencies</strong>: Task scheduling, package management</li>
<li><strong>Recommendation systems</strong>: User preferences, item relationships</li>
<li><strong>Game development</strong>: Pathfinding, AI decision trees</li>
</ul>
<h3 id="graph-components">Graph Components:</h3>
<ol>
<li><strong>Vertices (V)</strong>: Nodes or points in the graph</li>
<li><strong>Edges (E)</strong>: Connections between vertices</li>
<li><strong>Weight</strong>: Optional value associated with edges</li>
<li><strong>Degree</strong>: Number of edges connected to a vertex</li>
</ol>
<hr>
<h2 id="%F0%9F%93%8A-graph-types--properties">📊 Graph Types &amp; Properties</h2>
<h3 id="graph-classifications">Graph Classifications:</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
<th>Example</th>
<th>Use Cases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Directed</strong></td>
<td>Edges have direction</td>
<td>Twitter follows</td>
<td>Web links, dependencies</td>
</tr>
<tr>
<td><strong>Undirected</strong></td>
<td>Edges are bidirectional</td>
<td>Facebook friends</td>
<td>Social networks, maps</td>
</tr>
<tr>
<td><strong>Weighted</strong></td>
<td>Edges have values</td>
<td>Road distances</td>
<td>Shortest path, cost optimization</td>
</tr>
<tr>
<td><strong>Unweighted</strong></td>
<td>All edges equal</td>
<td>Simple connections</td>
<td>Basic relationships</td>
</tr>
<tr>
<td><strong>Cyclic</strong></td>
<td>Contains cycles</td>
<td>Road networks</td>
<td>Most real-world graphs</td>
</tr>
<tr>
<td><strong>Acyclic</strong></td>
<td>No cycles</td>
<td>Family trees</td>
<td>Hierarchies, DAGs</td>
</tr>
<tr>
<td><strong>Connected</strong></td>
<td>Path exists between all vertices</td>
<td>Single network</td>
<td>Communication systems</td>
</tr>
<tr>
<td><strong>Disconnected</strong></td>
<td>Some vertices unreachable</td>
<td>Multiple networks</td>
<td>Isolated components</td>
</tr>
</tbody>
</table>
<h3 id="special-graph-types">Special Graph Types:</h3>
<ul>
<li><strong>Complete Graph</strong>: Every vertex connected to every other vertex</li>
<li><strong>Bipartite Graph</strong>: Vertices can be divided into two disjoint sets</li>
<li><strong>Tree</strong>: Connected acyclic graph with V-1 edges</li>
<li><strong>DAG (Directed Acyclic Graph)</strong>: Directed graph with no cycles</li>
<li><strong>Planar Graph</strong>: Can be drawn without edge crossings</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Graph Representations and Basic Operations</span>

<span class="hljs-comment">// ===== GRAPH REPRESENTATIONS =====</span>

<span class="hljs-comment">// 1. ADJACENCY LIST REPRESENTATION</span>
<span class="hljs-comment">// Most common and space-efficient for sparse graphs</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphAdjacencyList</span> </span>{
  <span class="hljs-keyword">constructor</span>(isDirected = false) {
    <span class="hljs-keyword">this</span>.vertices = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// vertex -&gt; list of neighbors</span>
    <span class="hljs-keyword">this</span>.isDirected = isDirected;
    <span class="hljs-keyword">this</span>.vertexCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.edgeCount = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Add vertex to graph</span>
  addVertex(vertex) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertices.has(vertex)) {
      <span class="hljs-keyword">this</span>.vertices.set(vertex, []);
      <span class="hljs-keyword">this</span>.vertexCount++;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Vertex already exists</span>
  }

  <span class="hljs-comment">// Remove vertex and all its edges</span>
  removeVertex(vertex) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertices.has(vertex)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Remove all edges to this vertex</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [v, neighbors] <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.vertices) {
      <span class="hljs-keyword">const</span> index = neighbors.findIndex(
        <span class="hljs-function">(<span class="hljs-params">neighbor</span>) =&gt;</span>
          (<span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor) === vertex
      );
      <span class="hljs-keyword">if</span> (index !== <span class="hljs-number">-1</span>) {
        neighbors.splice(index, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">this</span>.edgeCount--;
      }
    }

    <span class="hljs-comment">// Remove the vertex itself</span>
    <span class="hljs-keyword">this</span>.edgeCount -= <span class="hljs-keyword">this</span>.vertices.get(vertex).length;
    <span class="hljs-keyword">this</span>.vertices.delete(vertex);
    <span class="hljs-keyword">this</span>.vertexCount--;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Add edge between two vertices</span>
  addEdge(vertex1, vertex2, weight = <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// Ensure both vertices exist</span>
    <span class="hljs-keyword">this</span>.addVertex(vertex1);
    <span class="hljs-keyword">this</span>.addVertex(vertex2);

    <span class="hljs-comment">// Add edge from vertex1 to vertex2</span>
    <span class="hljs-keyword">const</span> neighbors1 = <span class="hljs-keyword">this</span>.vertices.get(vertex1);
    <span class="hljs-keyword">if</span> (weight === <span class="hljs-number">1</span>) {
      neighbors1.push(vertex2);
    } <span class="hljs-keyword">else</span> {
      neighbors1.push({ <span class="hljs-attr">vertex</span>: vertex2, weight });
    }

    <span class="hljs-comment">// If undirected, add reverse edge</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isDirected) {
      <span class="hljs-keyword">const</span> neighbors2 = <span class="hljs-keyword">this</span>.vertices.get(vertex2);
      <span class="hljs-keyword">if</span> (weight === <span class="hljs-number">1</span>) {
        neighbors2.push(vertex1);
      } <span class="hljs-keyword">else</span> {
        neighbors2.push({ <span class="hljs-attr">vertex</span>: vertex1, weight });
      }
    }

    <span class="hljs-keyword">this</span>.edgeCount++;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Remove edge between two vertices</span>
  removeEdge(vertex1, vertex2) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertices.has(vertex1) || !<span class="hljs-keyword">this</span>.vertices.has(vertex2)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Remove edge from vertex1 to vertex2</span>
    <span class="hljs-keyword">const</span> neighbors1 = <span class="hljs-keyword">this</span>.vertices.get(vertex1);
    <span class="hljs-keyword">const</span> index1 = neighbors1.findIndex(
      <span class="hljs-function">(<span class="hljs-params">neighbor</span>) =&gt;</span>
        (<span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor) === vertex2
    );

    <span class="hljs-keyword">if</span> (index1 === <span class="hljs-number">-1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Edge doesn't exist</span>
    }

    neighbors1.splice(index1, <span class="hljs-number">1</span>);

    <span class="hljs-comment">// If undirected, remove reverse edge</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isDirected) {
      <span class="hljs-keyword">const</span> neighbors2 = <span class="hljs-keyword">this</span>.vertices.get(vertex2);
      <span class="hljs-keyword">const</span> index2 = neighbors2.findIndex(
        <span class="hljs-function">(<span class="hljs-params">neighbor</span>) =&gt;</span>
          (<span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor) ===
          vertex1
      );
      <span class="hljs-keyword">if</span> (index2 !== <span class="hljs-number">-1</span>) {
        neighbors2.splice(index2, <span class="hljs-number">1</span>);
      }
    }

    <span class="hljs-keyword">this</span>.edgeCount--;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Check if edge exists</span>
  hasEdge(vertex1, vertex2) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertices.has(vertex1)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">const</span> neighbors = <span class="hljs-keyword">this</span>.vertices.get(vertex1);
    <span class="hljs-keyword">return</span> neighbors.some(
      <span class="hljs-function">(<span class="hljs-params">neighbor</span>) =&gt;</span>
        (<span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor) === vertex2
    );
  }

  <span class="hljs-comment">// Get neighbors of a vertex</span>
  getNeighbors(vertex) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.vertices.get(vertex) || [];
  }

  <span class="hljs-comment">// Get all vertices</span>
  getVertices() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>.vertices.keys());
  }

  <span class="hljs-comment">// Get vertex degree</span>
  getDegree(vertex) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertices.has(vertex)) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.vertices.get(vertex).length;
  }

  <span class="hljs-comment">// Print graph</span>
  printGraph() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Graph (<span class="hljs-subst">${<span class="hljs-keyword">this</span>.isDirected ? <span class="hljs-string">"Directed"</span> : <span class="hljs-string">"Undirected"</span>}</span>):`</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [vertex, neighbors] <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.vertices) {
      <span class="hljs-keyword">const</span> neighborStr = neighbors
        .map(<span class="hljs-function">(<span class="hljs-params">neighbor</span>) =&gt;</span>
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span>
            ? <span class="hljs-string">`<span class="hljs-subst">${neighbor.vertex}</span>(<span class="hljs-subst">${neighbor.weight}</span>)`</span>
            : neighbor
        )
        .join(<span class="hljs-string">", "</span>);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${vertex}</span> -&gt; [<span class="hljs-subst">${neighborStr}</span>]`</span>);
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Vertices: <span class="hljs-subst">${<span class="hljs-keyword">this</span>.vertexCount}</span>, Edges: <span class="hljs-subst">${<span class="hljs-keyword">this</span>.edgeCount}</span>`</span>);
  }
}

<span class="hljs-comment">// 2. ADJACENCY MATRIX REPRESENTATION</span>
<span class="hljs-comment">// Good for dense graphs and when you need O(1) edge lookup</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphAdjacencyMatrix</span> </span>{
  <span class="hljs-keyword">constructor</span>(maxVertices = 100, isDirected = false) {
    <span class="hljs-keyword">this</span>.maxVertices = maxVertices;
    <span class="hljs-keyword">this</span>.isDirected = isDirected;
    <span class="hljs-keyword">this</span>.matrix = <span class="hljs-built_in">Array</span>(maxVertices)
      .fill(<span class="hljs-literal">null</span>)
      .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(maxVertices).fill(<span class="hljs-number">0</span>));
    <span class="hljs-keyword">this</span>.vertexMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// vertex -&gt; index</span>
    <span class="hljs-keyword">this</span>.indexMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// index -&gt; vertex</span>
    <span class="hljs-keyword">this</span>.vertexCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.edgeCount = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Add vertex</span>
  addVertex(vertex) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.vertexMap.has(vertex) || <span class="hljs-keyword">this</span>.vertexCount &gt;= <span class="hljs-keyword">this</span>.maxVertices) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.vertexCount;
    <span class="hljs-keyword">this</span>.vertexMap.set(vertex, index);
    <span class="hljs-keyword">this</span>.indexMap.set(index, vertex);
    <span class="hljs-keyword">this</span>.vertexCount++;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Add edge</span>
  addEdge(vertex1, vertex2, weight = <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertexMap.has(vertex1) || !<span class="hljs-keyword">this</span>.vertexMap.has(vertex2)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">const</span> index1 = <span class="hljs-keyword">this</span>.vertexMap.get(vertex1);
    <span class="hljs-keyword">const</span> index2 = <span class="hljs-keyword">this</span>.vertexMap.get(vertex2);

    <span class="hljs-comment">// Add edge</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.matrix[index1][index2] === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.edgeCount++;
    }
    <span class="hljs-keyword">this</span>.matrix[index1][index2] = weight;

    <span class="hljs-comment">// If undirected, add reverse edge</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isDirected) {
      <span class="hljs-keyword">this</span>.matrix[index2][index1] = weight;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Remove edge</span>
  removeEdge(vertex1, vertex2) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertexMap.has(vertex1) || !<span class="hljs-keyword">this</span>.vertexMap.has(vertex2)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">const</span> index1 = <span class="hljs-keyword">this</span>.vertexMap.get(vertex1);
    <span class="hljs-keyword">const</span> index2 = <span class="hljs-keyword">this</span>.vertexMap.get(vertex2);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.matrix[index1][index2] !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.matrix[index1][index2] = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isDirected) {
        <span class="hljs-keyword">this</span>.matrix[index2][index1] = <span class="hljs-number">0</span>;
      }
      <span class="hljs-keyword">this</span>.edgeCount--;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Check if edge exists</span>
  hasEdge(vertex1, vertex2) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertexMap.has(vertex1) || !<span class="hljs-keyword">this</span>.vertexMap.has(vertex2)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">const</span> index1 = <span class="hljs-keyword">this</span>.vertexMap.get(vertex1);
    <span class="hljs-keyword">const</span> index2 = <span class="hljs-keyword">this</span>.vertexMap.get(vertex2);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.matrix[index1][index2] !== <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Get neighbors</span>
  getNeighbors(vertex) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.vertexMap.has(vertex)) {
      <span class="hljs-keyword">return</span> [];
    }

    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.vertexMap.get(vertex);
    <span class="hljs-keyword">const</span> neighbors = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertexCount; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.matrix[index][i] !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> neighborVertex = <span class="hljs-keyword">this</span>.indexMap.get(i);
        <span class="hljs-keyword">const</span> weight = <span class="hljs-keyword">this</span>.matrix[index][i];
        <span class="hljs-keyword">if</span> (weight === <span class="hljs-number">1</span>) {
          neighbors.push(neighborVertex);
        } <span class="hljs-keyword">else</span> {
          neighbors.push({ <span class="hljs-attr">vertex</span>: neighborVertex, weight });
        }
      }
    }

    <span class="hljs-keyword">return</span> neighbors;
  }

  <span class="hljs-comment">// Print matrix</span>
  printMatrix() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Adjacency Matrix:"</span>);
    <span class="hljs-keyword">const</span> vertices = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>.indexMap.values());

    <span class="hljs-comment">// Print header</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"   "</span>, vertices.join(<span class="hljs-string">"  "</span>));

    <span class="hljs-comment">// Print rows</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vertexCount; i++) {
      <span class="hljs-keyword">const</span> row = <span class="hljs-keyword">this</span>.matrix[i].slice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.vertexCount);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${vertices[i]}</span>:  <span class="hljs-subst">${row.join(<span class="hljs-string">"  "</span>)}</span>`</span>);
    }
  }
}

<span class="hljs-comment">// ===== GRAPH TRAVERSAL ALGORITHMS =====</span>

<span class="hljs-comment">// 1. DEPTH-FIRST SEARCH (DFS)</span>
<span class="hljs-comment">// Explores as far as possible before backtracking</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphDFS</span> </span>{
  <span class="hljs-comment">// Recursive DFS</span>
  <span class="hljs-keyword">static</span> dfsRecursive(graph, startVertex, visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(), result = []) {
    visited.add(startVertex);
    result.push(startVertex);

    <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(startVertex);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
      <span class="hljs-keyword">const</span> vertex = <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;
      <span class="hljs-keyword">if</span> (!visited.has(vertex)) {
        GraphDFS.dfsRecursive(graph, vertex, visited, result);
      }
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Iterative DFS using stack</span>
  <span class="hljs-keyword">static</span> dfsIterative(graph, startVertex) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> stack = [startVertex];

    <span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> vertex = stack.pop();

      <span class="hljs-keyword">if</span> (!visited.has(vertex)) {
        visited.add(vertex);
        result.push(vertex);

        <span class="hljs-comment">// Add neighbors to stack (in reverse order for consistent traversal)</span>
        <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = neighbors.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
          <span class="hljs-keyword">const</span> neighbor = neighbors[i];
          <span class="hljs-keyword">const</span> neighborVertex =
            <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;
          <span class="hljs-keyword">if</span> (!visited.has(neighborVertex)) {
            stack.push(neighborVertex);
          }
        }
      }
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// DFS to find path between two vertices</span>
  <span class="hljs-keyword">static</span> findPath(graph, start, end, visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(), path = []) {
    visited.add(start);
    path.push(start);

    <span class="hljs-keyword">if</span> (start === end) {
      <span class="hljs-keyword">return</span> [...path]; <span class="hljs-comment">// Return copy of path</span>
    }

    <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(start);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
      <span class="hljs-keyword">const</span> vertex = <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;
      <span class="hljs-keyword">if</span> (!visited.has(vertex)) {
        <span class="hljs-keyword">const</span> result = GraphDFS.findPath(graph, vertex, end, visited, path);
        <span class="hljs-keyword">if</span> (result) {
          <span class="hljs-keyword">return</span> result;
        }
      }
    }

    path.pop(); <span class="hljs-comment">// Backtrack</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// DFS to find all paths between two vertices</span>
  <span class="hljs-keyword">static</span> findAllPaths(
    graph,
    start,
    end,
    visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),
    path = [],
    allPaths = []
  ) {
    visited.add(start);
    path.push(start);

    <span class="hljs-keyword">if</span> (start === end) {
      allPaths.push([...path]);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(start);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> vertex =
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;
        <span class="hljs-keyword">if</span> (!visited.has(vertex)) {
          GraphDFS.findAllPaths(graph, vertex, end, visited, path, allPaths);
        }
      }
    }

    path.pop();
    visited.delete(start);
    <span class="hljs-keyword">return</span> allPaths;
  }

  <span class="hljs-comment">// Check if graph is connected (for undirected graphs)</span>
  <span class="hljs-keyword">static</span> isConnected(graph) {
    <span class="hljs-keyword">const</span> vertices = graph.getVertices();
    <span class="hljs-keyword">if</span> (vertices.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">const</span> visited = GraphDFS.dfsRecursive(graph, vertices[<span class="hljs-number">0</span>]);
    <span class="hljs-keyword">return</span> visited.length === vertices.length;
  }

  <span class="hljs-comment">// Detect cycle in undirected graph</span>
  <span class="hljs-keyword">static</span> hasCycleUndirected(graph) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> vertices = graph.getVertices();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfsCheckCycle</span>(<span class="hljs-params">vertex, parent</span>) </span>{
      visited.add(vertex);

      <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> neighborVertex =
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;

        <span class="hljs-keyword">if</span> (!visited.has(neighborVertex)) {
          <span class="hljs-keyword">if</span> (dfsCheckCycle(neighborVertex, vertex)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (neighborVertex !== parent) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Back edge found</span>
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> vertex <span class="hljs-keyword">of</span> vertices) {
      <span class="hljs-keyword">if</span> (!visited.has(vertex)) {
        <span class="hljs-keyword">if</span> (dfsCheckCycle(vertex, <span class="hljs-literal">null</span>)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Detect cycle in directed graph</span>
  <span class="hljs-keyword">static</span> hasCycleDirected(graph) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> recursionStack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> vertices = graph.getVertices();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfsCheckCycle</span>(<span class="hljs-params">vertex</span>) </span>{
      visited.add(vertex);
      recursionStack.add(vertex);

      <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> neighborVertex =
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;

        <span class="hljs-keyword">if</span> (!visited.has(neighborVertex)) {
          <span class="hljs-keyword">if</span> (dfsCheckCycle(neighborVertex)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (recursionStack.has(neighborVertex)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Back edge in recursion stack</span>
        }
      }

      recursionStack.delete(vertex);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> vertex <span class="hljs-keyword">of</span> vertices) {
      <span class="hljs-keyword">if</span> (!visited.has(vertex)) {
        <span class="hljs-keyword">if</span> (dfsCheckCycle(vertex)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}

<span class="hljs-comment">// 2. BREADTH-FIRST SEARCH (BFS)</span>
<span class="hljs-comment">// Explores neighbors level by level</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphBFS</span> </span>{
  <span class="hljs-comment">// Basic BFS traversal</span>
  <span class="hljs-keyword">static</span> bfs(graph, startVertex) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> queue = [startVertex];

    visited.add(startVertex);

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> vertex = queue.shift();
      result.push(vertex);

      <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> neighborVertex =
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;
        <span class="hljs-keyword">if</span> (!visited.has(neighborVertex)) {
          visited.add(neighborVertex);
          queue.push(neighborVertex);
        }
      }
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// BFS to find shortest path (unweighted graph)</span>
  <span class="hljs-keyword">static</span> shortestPath(graph, start, end) {
    <span class="hljs-keyword">if</span> (start === end) {
      <span class="hljs-keyword">return</span> [start];
    }

    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> queue = [[start]];
    visited.add(start);

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> path = queue.shift();
      <span class="hljs-keyword">const</span> vertex = path[path.length - <span class="hljs-number">1</span>];

      <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> neighborVertex =
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;

        <span class="hljs-keyword">if</span> (neighborVertex === end) {
          <span class="hljs-keyword">return</span> [...path, neighborVertex];
        }

        <span class="hljs-keyword">if</span> (!visited.has(neighborVertex)) {
          visited.add(neighborVertex);
          queue.push([...path, neighborVertex]);
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// No path found</span>
  }

  <span class="hljs-comment">// BFS to find shortest distance</span>
  <span class="hljs-keyword">static</span> shortestDistance(graph, start, end) {
    <span class="hljs-keyword">if</span> (start === end) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> queue = [{ <span class="hljs-attr">vertex</span>: start, <span class="hljs-attr">distance</span>: <span class="hljs-number">0</span> }];
    visited.add(start);

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> { vertex, distance } = queue.shift();

      <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> neighborVertex =
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;

        <span class="hljs-keyword">if</span> (neighborVertex === end) {
          <span class="hljs-keyword">return</span> distance + <span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">if</span> (!visited.has(neighborVertex)) {
          visited.add(neighborVertex);
          queue.push({ <span class="hljs-attr">vertex</span>: neighborVertex, <span class="hljs-attr">distance</span>: distance + <span class="hljs-number">1</span> });
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// No path found</span>
  }

  <span class="hljs-comment">// BFS level-order traversal</span>
  <span class="hljs-keyword">static</span> levelOrder(graph, startVertex) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> queue = [{ <span class="hljs-attr">vertex</span>: startVertex, <span class="hljs-attr">level</span>: <span class="hljs-number">0</span> }];
    visited.add(startVertex);

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> { vertex, level } = queue.shift();

      <span class="hljs-comment">// Ensure result array has enough levels</span>
      <span class="hljs-keyword">while</span> (result.length &lt;= level) {
        result.push([]);
      }

      result[level].push(vertex);

      <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> neighborVertex =
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;
        <span class="hljs-keyword">if</span> (!visited.has(neighborVertex)) {
          visited.add(neighborVertex);
          queue.push({ <span class="hljs-attr">vertex</span>: neighborVertex, <span class="hljs-attr">level</span>: level + <span class="hljs-number">1</span> });
        }
      }
    }

    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Check if graph is bipartite</span>
  <span class="hljs-keyword">static</span> isBipartite(graph) {
    <span class="hljs-keyword">const</span> color = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">const</span> vertices = graph.getVertices();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> startVertex <span class="hljs-keyword">of</span> vertices) {
      <span class="hljs-keyword">if</span> (color.has(startVertex)) <span class="hljs-keyword">continue</span>;

      <span class="hljs-keyword">const</span> queue = [startVertex];
      color.set(startVertex, <span class="hljs-number">0</span>);

      <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> vertex = queue.shift();
        <span class="hljs-keyword">const</span> currentColor = color.get(vertex);

        <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
          <span class="hljs-keyword">const</span> neighborVertex =
            <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;

          <span class="hljs-keyword">if</span> (!color.has(neighborVertex)) {
            color.set(neighborVertex, <span class="hljs-number">1</span> - currentColor);
            queue.push(neighborVertex);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color.get(neighborVertex) === currentColor) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Same color adjacent vertices</span>
          }
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}

<span class="hljs-comment">// ===== GRAPH UTILITIES =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphUtils</span> </span>{
  <span class="hljs-comment">// Create graph from edge list</span>
  <span class="hljs-keyword">static</span> fromEdgeList(edges, isDirected = <span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> GraphAdjacencyList(isDirected);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) {
      <span class="hljs-keyword">if</span> (edge.length === <span class="hljs-number">2</span>) {
        graph.addEdge(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (edge.length === <span class="hljs-number">3</span>) {
        graph.addEdge(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>], edge[<span class="hljs-number">2</span>]);
      }
    }

    <span class="hljs-keyword">return</span> graph;
  }

  <span class="hljs-comment">// Convert to edge list</span>
  <span class="hljs-keyword">static</span> toEdgeList(graph) {
    <span class="hljs-keyword">const</span> edges = [];
    <span class="hljs-keyword">const</span> vertices = graph.getVertices();
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> vertex <span class="hljs-keyword">of</span> vertices) {
      <span class="hljs-keyword">const</span> neighbors = graph.getNeighbors(vertex);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> neighborVertex =
          <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.vertex : neighbor;
        <span class="hljs-keyword">const</span> weight = <span class="hljs-keyword">typeof</span> neighbor === <span class="hljs-string">"object"</span> ? neighbor.weight : <span class="hljs-number">1</span>;

        <span class="hljs-keyword">const</span> edgeKey = graph.isDirected
          ? <span class="hljs-string">`<span class="hljs-subst">${vertex}</span>-&gt;<span class="hljs-subst">${neighborVertex}</span>`</span>
          : [vertex, neighborVertex].sort().join(<span class="hljs-string">"-"</span>);

        <span class="hljs-keyword">if</span> (!visited.has(edgeKey)) {
          visited.add(edgeKey);
          <span class="hljs-keyword">if</span> (weight === <span class="hljs-number">1</span>) {
            edges.push([vertex, neighborVertex]);
          } <span class="hljs-keyword">else</span> {
            edges.push([vertex, neighborVertex, weight]);
          }
        }
      }
    }

    <span class="hljs-keyword">return</span> edges;
  }

  <span class="hljs-comment">// Find connected components</span>
  <span class="hljs-keyword">static</span> findConnectedComponents(graph) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">const</span> components = [];
    <span class="hljs-keyword">const</span> vertices = graph.getVertices();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> vertex <span class="hljs-keyword">of</span> vertices) {
      <span class="hljs-keyword">if</span> (!visited.has(vertex)) {
        <span class="hljs-keyword">const</span> component = GraphDFS.dfsRecursive(graph, vertex, visited);
        components.push(component);
      }
    }

    <span class="hljs-keyword">return</span> components;
  }

  <span class="hljs-comment">// Calculate graph density</span>
  <span class="hljs-keyword">static</span> calculateDensity(graph) {
    <span class="hljs-keyword">const</span> V = graph.vertexCount;
    <span class="hljs-keyword">const</span> E = graph.edgeCount;

    <span class="hljs-keyword">if</span> (V &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> maxEdges = graph.isDirected ? V * (V - <span class="hljs-number">1</span>) : (V * (V - <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> E / maxEdges;
  }

  <span class="hljs-comment">// Generate random graph</span>
  <span class="hljs-keyword">static</span> generateRandomGraph(
    numVertices,
    edgeProbability = <span class="hljs-number">0.3</span>,
    isDirected = <span class="hljs-literal">false</span>
  ) {
    <span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> GraphAdjacencyList(isDirected);

    <span class="hljs-comment">// Add vertices</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numVertices; i++) {
      graph.addVertex(i);
    }

    <span class="hljs-comment">// Add random edges</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numVertices; i++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = isDirected ? <span class="hljs-number">0</span> : i + <span class="hljs-number">1</span>; j &lt; numVertices; j++) {
        <span class="hljs-keyword">if</span> (i !== j &amp;&amp; <span class="hljs-built_in">Math</span>.random() &lt; edgeProbability) {
          graph.addEdge(i, j);
        }
      }
    }

    <span class="hljs-keyword">return</span> graph;
  }

  <span class="hljs-comment">// Performance comparison</span>
  <span class="hljs-keyword">static</span> compareRepresentations(numVertices, numEdges) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Graph Representation Comparison ==="</span>);

    <span class="hljs-comment">// Create same graph in both representations</span>
    <span class="hljs-keyword">const</span> adjList = <span class="hljs-keyword">new</span> GraphAdjacencyList();
    <span class="hljs-keyword">const</span> adjMatrix = <span class="hljs-keyword">new</span> GraphAdjacencyMatrix(numVertices);

    <span class="hljs-comment">// Add vertices</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numVertices; i++) {
      adjList.addVertex(i);
      adjMatrix.addVertex(i);
    }

    <span class="hljs-comment">// Add random edges</span>
    <span class="hljs-keyword">const</span> edges = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numEdges; i++) {
      <span class="hljs-keyword">const</span> v1 = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * numVertices);
      <span class="hljs-keyword">const</span> v2 = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * numVertices);
      <span class="hljs-keyword">if</span> (v1 !== v2) {
        edges.push([v1, v2]);
      }
    }

    <span class="hljs-comment">// Measure edge addition time</span>
    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Adjacency List - Add Edges"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [v1, v2] <span class="hljs-keyword">of</span> edges) {
      adjList.addEdge(v1, v2);
    }
    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Adjacency List - Add Edges"</span>);

    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Adjacency Matrix - Add Edges"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [v1, v2] <span class="hljs-keyword">of</span> edges) {
      adjMatrix.addEdge(v1, v2);
    }
    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Adjacency Matrix - Add Edges"</span>);

    <span class="hljs-comment">// Measure edge lookup time</span>
    <span class="hljs-keyword">const</span> testEdge = edges[<span class="hljs-number">0</span>];

    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Adjacency List - Edge Lookup"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
      adjList.hasEdge(testEdge[<span class="hljs-number">0</span>], testEdge[<span class="hljs-number">1</span>]);
    }
    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Adjacency List - Edge Lookup"</span>);

    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Adjacency Matrix - Edge Lookup"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
      adjMatrix.hasEdge(testEdge[<span class="hljs-number">0</span>], testEdge[<span class="hljs-number">1</span>]);
    }
    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Adjacency Matrix - Edge Lookup"</span>);

    <span class="hljs-comment">// Space usage estimation</span>
    <span class="hljs-keyword">const</span> listSpace = numVertices + <span class="hljs-number">2</span> * numEdges; <span class="hljs-comment">// Rough estimate</span>
    <span class="hljs-keyword">const</span> matrixSpace = numVertices * numVertices;

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\nSpace Usage Estimation:`</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Adjacency List: ~<span class="hljs-subst">${listSpace}</span> units`</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Adjacency Matrix: ~<span class="hljs-subst">${matrixSpace}</span> units`</span>);
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">`Density: <span class="hljs-subst">${(
        (numEdges <span class="hljs-regexp">/ ((numVertices * (numVertices - 1)) /</span> <span class="hljs-number">2</span>)) *
        <span class="hljs-number">100</span>
      ).toFixed(<span class="hljs-number">2</span>)}</span>%`</span>
    );
  }
}

<span class="hljs-comment">// ===== EXAMPLE USAGE AND TESTING =====</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Basic Graph Theory Demo ==="</span>);

<span class="hljs-comment">// Create undirected graph</span>
<span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> GraphAdjacencyList(<span class="hljs-literal">false</span>);

<span class="hljs-comment">// Add vertices</span>
[<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>].forEach(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> graph.addVertex(v));

<span class="hljs-comment">// Add edges</span>
graph.addEdge(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>);
graph.addEdge(<span class="hljs-string">"A"</span>, <span class="hljs-string">"C"</span>);
graph.addEdge(<span class="hljs-string">"B"</span>, <span class="hljs-string">"D"</span>);
graph.addEdge(<span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>);
graph.addEdge(<span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Graph Structure ==="</span>);
graph.printGraph();

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Graph Traversals ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"DFS (Recursive):"</span>, GraphDFS.dfsRecursive(graph, <span class="hljs-string">"A"</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"DFS (Iterative):"</span>, GraphDFS.dfsIterative(graph, <span class="hljs-string">"A"</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"BFS:"</span>, GraphBFS.bfs(graph, <span class="hljs-string">"A"</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"BFS Level Order:"</span>, GraphBFS.levelOrder(graph, <span class="hljs-string">"A"</span>));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Path Finding ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Path A to E:"</span>, GraphDFS.findPath(graph, <span class="hljs-string">"A"</span>, <span class="hljs-string">"E"</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"All paths A to E:"</span>, GraphDFS.findAllPaths(graph, <span class="hljs-string">"A"</span>, <span class="hljs-string">"E"</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Shortest path A to E:"</span>, GraphBFS.shortestPath(graph, <span class="hljs-string">"A"</span>, <span class="hljs-string">"E"</span>));
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Shortest distance A to E:"</span>,
  GraphBFS.shortestDistance(graph, <span class="hljs-string">"A"</span>, <span class="hljs-string">"E"</span>)
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Graph Properties ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Is connected:"</span>, GraphDFS.isConnected(graph));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Has cycle:"</span>, GraphDFS.hasCycleUndirected(graph));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Is bipartite:"</span>, GraphBFS.isBipartite(graph));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Connected components:"</span>, GraphUtils.findConnectedComponents(graph));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Graph density:"</span>, GraphUtils.calculateDensity(graph).toFixed(<span class="hljs-number">3</span>));

<span class="hljs-comment">// Create directed graph for cycle detection</span>
<span class="hljs-keyword">const</span> directedGraph = <span class="hljs-keyword">new</span> GraphAdjacencyList(<span class="hljs-literal">true</span>);
[<span class="hljs-string">"X"</span>, <span class="hljs-string">"Y"</span>, <span class="hljs-string">"Z"</span>].forEach(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> directedGraph.addVertex(v));
directedGraph.addEdge(<span class="hljs-string">"X"</span>, <span class="hljs-string">"Y"</span>);
directedGraph.addEdge(<span class="hljs-string">"Y"</span>, <span class="hljs-string">"Z"</span>);
directedGraph.addEdge(<span class="hljs-string">"Z"</span>, <span class="hljs-string">"X"</span>); <span class="hljs-comment">// Creates cycle</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Directed Graph ==="</span>);
directedGraph.printGraph();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Has cycle (directed):"</span>, GraphDFS.hasCycleDirected(directedGraph));

<span class="hljs-comment">// Weighted graph example</span>
<span class="hljs-keyword">const</span> weightedGraph = <span class="hljs-keyword">new</span> GraphAdjacencyList(<span class="hljs-literal">false</span>);
[<span class="hljs-string">"P"</span>, <span class="hljs-string">"Q"</span>, <span class="hljs-string">"R"</span>, <span class="hljs-string">"S"</span>].forEach(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> weightedGraph.addVertex(v));
weightedGraph.addEdge(<span class="hljs-string">"P"</span>, <span class="hljs-string">"Q"</span>, <span class="hljs-number">5</span>);
weightedGraph.addEdge(<span class="hljs-string">"P"</span>, <span class="hljs-string">"R"</span>, <span class="hljs-number">3</span>);
weightedGraph.addEdge(<span class="hljs-string">"Q"</span>, <span class="hljs-string">"S"</span>, <span class="hljs-number">2</span>);
weightedGraph.addEdge(<span class="hljs-string">"R"</span>, <span class="hljs-string">"S"</span>, <span class="hljs-number">7</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Weighted Graph ==="</span>);
weightedGraph.printGraph();

<span class="hljs-comment">// Adjacency matrix example</span>
<span class="hljs-keyword">const</span> matrixGraph = <span class="hljs-keyword">new</span> GraphAdjacencyMatrix(<span class="hljs-number">5</span>, <span class="hljs-literal">false</span>);
[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].forEach(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> matrixGraph.addVertex(v));
matrixGraph.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
matrixGraph.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
matrixGraph.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
matrixGraph.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
matrixGraph.addEdge(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Adjacency Matrix ==="</span>);
matrixGraph.printMatrix();

<span class="hljs-comment">// Edge list conversion</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Edge List Conversion ==="</span>);
<span class="hljs-keyword">const</span> edgeList = GraphUtils.toEdgeList(graph);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Edge list:"</span>, edgeList);

<span class="hljs-keyword">const</span> graphFromEdges = GraphUtils.fromEdgeList(edgeList);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Graph from edge list:"</span>);
graphFromEdges.printGraph();

<span class="hljs-comment">// Performance comparison</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Performance Comparison ==="</span>);
GraphUtils.compareRepresentations(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);

<span class="hljs-comment">// Random graph generation</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Random Graph ==="</span>);
<span class="hljs-keyword">const</span> randomGraph = GraphUtils.generateRandomGraph(<span class="hljs-number">6</span>, <span class="hljs-number">0.4</span>);
randomGraph.printGraph();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Random graph properties:"</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"- Connected components:"</span>,
  GraphUtils.findConnectedComponents(randomGraph).length
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"- Density:"</span>, GraphUtils.calculateDensity(randomGraph).toFixed(<span class="hljs-number">3</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"- Has cycle:"</span>, GraphDFS.hasCycleUndirected(randomGraph));
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::chrono;

<span class="hljs-comment">// ===== ADJACENCY LIST REPRESENTATION =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphAdjacencyList</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">list</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; adjList</span>; <span class="hljs-comment">// vertex -&gt; list of (neighbor, weight)</span>
    <span class="hljs-keyword">bool</span> isDirected;
    <span class="hljs-keyword">int</span> vertexCount;
    <span class="hljs-keyword">int</span> edgeCount;

<span class="hljs-keyword">public</span>:
    GraphAdjacencyList(<span class="hljs-keyword">bool</span> directed = <span class="hljs-literal">false</span>) : isDirected(directed), vertexCount(<span class="hljs-number">0</span>), edgeCount(<span class="hljs-number">0</span>) {}

    <span class="hljs-comment">// Add vertex</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">addVertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex)</span> </span>{
        <span class="hljs-keyword">if</span> (adjList.find(vertex) == adjList.end()) {
            adjList[vertex] = <span class="hljs-built_in">list</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;();
            vertexCount++;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Add edge</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2, <span class="hljs-keyword">int</span> weight = <span class="hljs-number">1</span>)</span> </span>{
        addVertex(vertex1);
        addVertex(vertex2);

        adjList[vertex1].push_back({vertex2, weight});

        <span class="hljs-keyword">if</span> (!isDirected) {
            adjList[vertex2].push_back({vertex1, weight});
        }

        edgeCount++;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Remove edge</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">removeEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2)</span> </span>{
        <span class="hljs-keyword">if</span> (adjList.find(vertex1) == adjList.end() || adjList.find(vertex2) == adjList.end()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">auto</span>&amp; neighbors1 = adjList[vertex1];
        <span class="hljs-keyword">auto</span> it1 = find_if(neighbors1.begin(), neighbors1.end(),
                          [vertex2](<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; p) { <span class="hljs-keyword">return</span> p.first == vertex2; });

        <span class="hljs-keyword">if</span> (it1 == neighbors1.end()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        neighbors1.erase(it1);

        <span class="hljs-keyword">if</span> (!isDirected) {
            <span class="hljs-keyword">auto</span>&amp; neighbors2 = adjList[vertex2];
            <span class="hljs-keyword">auto</span> it2 = find_if(neighbors2.begin(), neighbors2.end(),
                              [vertex1](<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; p) { <span class="hljs-keyword">return</span> p.first == vertex1; });
            <span class="hljs-keyword">if</span> (it2 != neighbors2.end()) {
                neighbors2.erase(it2);
            }
        }

        edgeCount--;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Check if edge exists</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2)</span> </span>{
        <span class="hljs-keyword">if</span> (adjList.find(vertex1) == adjList.end()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbors = adjList[vertex1];
        <span class="hljs-keyword">return</span> find_if(neighbors.begin(), neighbors.end(),
                      [vertex2](<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; p) { <span class="hljs-keyword">return</span> p.first == vertex2; }) != neighbors.end();
    }

    <span class="hljs-comment">// Get neighbors</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">getNeighbors</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex)</span> </span>{
        <span class="hljs-keyword">if</span> (adjList.find(vertex) == adjList.end()) {
            <span class="hljs-keyword">return</span> {};
        }

        <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; neighbors;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbor : adjList[vertex]) {
            neighbors.push_back(neighbor);
        }
        <span class="hljs-keyword">return</span> neighbors;
    }

    <span class="hljs-comment">// Get all vertices</span>
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getVertices</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vertices;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : adjList) {
            vertices.push_back(pair.first);
        }
        <span class="hljs-keyword">return</span> vertices;
    }

    <span class="hljs-comment">// Print graph</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printGraph</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Graph ("</span> &lt;&lt; (isDirected ? <span class="hljs-string">"Directed"</span> : <span class="hljs-string">"Undirected"</span>) &lt;&lt; <span class="hljs-string">"):"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; vertex : adjList) {
            <span class="hljs-built_in">cout</span> &lt;&lt; vertex.first &lt;&lt; <span class="hljs-string">" -&gt; ["</span>;
            <span class="hljs-keyword">bool</span> first = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbor : vertex.second) {
                <span class="hljs-keyword">if</span> (!first) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">", "</span>;
                <span class="hljs-keyword">if</span> (neighbor.second == <span class="hljs-number">1</span>) {
                    <span class="hljs-built_in">cout</span> &lt;&lt; neighbor.first;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">cout</span> &lt;&lt; neighbor.first &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; neighbor.second &lt;&lt; <span class="hljs-string">")"</span>;
                }
                first = <span class="hljs-literal">false</span>;
            }
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Vertices: "</span> &lt;&lt; vertexCount &lt;&lt; <span class="hljs-string">", Edges: "</span> &lt;&lt; edgeCount &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Getters</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getVertexCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> vertexCount; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getEdgeCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> edgeCount; }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">getIsDirected</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> isDirected; }
};

<span class="hljs-comment">// ===== ADJACENCY MATRIX REPRESENTATION =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphAdjacencyMatrix</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; matrix;
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; vertexToIndex;
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; indexToVertex;
    <span class="hljs-keyword">bool</span> isDirected;
    <span class="hljs-keyword">int</span> maxVertices;
    <span class="hljs-keyword">int</span> vertexCount;
    <span class="hljs-keyword">int</span> edgeCount;

<span class="hljs-keyword">public</span>:
    GraphAdjacencyMatrix(<span class="hljs-keyword">int</span> maxVert = <span class="hljs-number">100</span>, <span class="hljs-keyword">bool</span> directed = <span class="hljs-literal">false</span>)
        : maxVertices(maxVert), isDirected(directed), vertexCount(<span class="hljs-number">0</span>), edgeCount(<span class="hljs-number">0</span>) {
        matrix.resize(maxVertices, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(maxVertices, <span class="hljs-number">0</span>));
    }

    <span class="hljs-comment">// Add vertex</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">addVertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex)</span> </span>{
        <span class="hljs-keyword">if</span> (vertexToIndex.find(vertex) != vertexToIndex.end() || vertexCount &gt;= maxVertices) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">int</span> index = vertexCount;
        vertexToIndex[vertex] = index;
        indexToVertex[index] = vertex;
        vertexCount++;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Add edge</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2, <span class="hljs-keyword">int</span> weight = <span class="hljs-number">1</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (vertexToIndex.find(vertex1) == vertexToIndex.end() ||
            vertexToIndex.find(vertex2) == vertexToIndex.end()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">int</span> index1 = vertexToIndex[vertex1];
        <span class="hljs-keyword">int</span> index2 = vertexToIndex[vertex2];

        <span class="hljs-keyword">if</span> (matrix[index1][index2] == <span class="hljs-number">0</span>) {
            edgeCount++;
        }

        matrix[index1][index2] = weight;

        <span class="hljs-keyword">if</span> (!isDirected) {
            matrix[index2][index1] = weight;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// Check if edge exists</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2)</span> </span>{
        <span class="hljs-keyword">if</span> (vertexToIndex.find(vertex1) == vertexToIndex.end() ||
            vertexToIndex.find(vertex2) == vertexToIndex.end()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">int</span> index1 = vertexToIndex[vertex1];
        <span class="hljs-keyword">int</span> index2 = vertexToIndex[vertex2];
        <span class="hljs-keyword">return</span> matrix[index1][index2] != <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// Print matrix</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMatrix</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Adjacency Matrix:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

        <span class="hljs-comment">// Print header</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"   "</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexCount; i++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; indexToVertex[i] &lt;&lt; <span class="hljs-string">"  "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

        <span class="hljs-comment">// Print rows</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vertexCount; i++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; indexToVertex[i] &lt;&lt; <span class="hljs-string">": "</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; vertexCount; j++) {
                <span class="hljs-built_in">cout</span> &lt;&lt; matrix[i][j] &lt;&lt; <span class="hljs-string">"  "</span>;
            }
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        }
    }
};

<span class="hljs-comment">// ===== GRAPH TRAVERSAL ALGORITHMS =====</span>

<span class="hljs-comment">// DFS Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphDFS</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Recursive DFS</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dfsRecursive</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> startVertex)</span> </span>{
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        dfsRecursiveHelper(graph, startVertex, visited, result);
        <span class="hljs-keyword">return</span> result;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfsRecursiveHelper</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> vertex,
                                  <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; visited, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
        visited.insert(vertex);
        result.push_back(vertex);

        <span class="hljs-keyword">auto</span> neighbors = graph.getNeighbors(vertex);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbor : neighbors) {
            <span class="hljs-keyword">if</span> (visited.find(neighbor.first) == visited.end()) {
                dfsRecursiveHelper(graph, neighbor.first, visited, result);
            }
        }
    }

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Iterative DFS</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dfsIterative</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> startVertex)</span> </span>{
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stk;

        stk.push(startVertex);

        <span class="hljs-keyword">while</span> (!stk.empty()) {
            <span class="hljs-keyword">int</span> vertex = stk.top();
            stk.pop();

            <span class="hljs-keyword">if</span> (visited.find(vertex) == visited.end()) {
                visited.insert(vertex);
                result.push_back(vertex);

                <span class="hljs-keyword">auto</span> neighbors = graph.getNeighbors(vertex);
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = neighbors.rbegin(); it != neighbors.rend(); ++it) {
                    <span class="hljs-keyword">if</span> (visited.find(it-&gt;first) == visited.end()) {
                        stk.push(it-&gt;first);
                    }
                }
            }
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Find path between two vertices</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findPath</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path;

        <span class="hljs-keyword">if</span> (findPathHelper(graph, start, end, visited, path)) {
            <span class="hljs-keyword">return</span> path;
        }

        <span class="hljs-keyword">return</span> {}; <span class="hljs-comment">// No path found</span>
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">findPathHelper</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> current, <span class="hljs-keyword">int</span> end,
                              <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; visited, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; path)</span> </span>{
        visited.insert(current);
        path.push_back(current);

        <span class="hljs-keyword">if</span> (current == end) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">auto</span> neighbors = graph.getNeighbors(current);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbor : neighbors) {
            <span class="hljs-keyword">if</span> (visited.find(neighbor.first) == visited.end()) {
                <span class="hljs-keyword">if</span> (findPathHelper(graph, neighbor.first, end, visited, path)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
        }

        path.pop_back(); <span class="hljs-comment">// Backtrack</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Check if graph has cycle (undirected)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycleUndirected</span><span class="hljs-params">(GraphAdjacencyList&amp; graph)</span> </span>{
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;
        <span class="hljs-keyword">auto</span> vertices = graph.getVertices();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> vertex : vertices) {
            <span class="hljs-keyword">if</span> (visited.find(vertex) == visited.end()) {
                <span class="hljs-keyword">if</span> (hasCycleUndirectedHelper(graph, vertex, <span class="hljs-number">-1</span>, visited)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycleUndirectedHelper</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> vertex, <span class="hljs-keyword">int</span> parent,
                                        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; visited)</span> </span>{
        visited.insert(vertex);

        <span class="hljs-keyword">auto</span> neighbors = graph.getNeighbors(vertex);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbor : neighbors) {
            <span class="hljs-keyword">if</span> (visited.find(neighbor.first) == visited.end()) {
                <span class="hljs-keyword">if</span> (hasCycleUndirectedHelper(graph, neighbor.first, vertex, visited)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (neighbor.first != parent) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Back edge found</span>
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};

<span class="hljs-comment">// BFS Implementation</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphBFS</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Basic BFS</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">bfs</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> startVertex)</span> </span>{
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;

        visited.insert(startVertex);
        q.push(startVertex);

        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-keyword">int</span> vertex = q.front();
            q.pop();
            result.push_back(vertex);

            <span class="hljs-keyword">auto</span> neighbors = graph.getNeighbors(vertex);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbor : neighbors) {
                <span class="hljs-keyword">if</span> (visited.find(neighbor.first) == visited.end()) {
                    visited.insert(neighbor.first);
                    q.push(neighbor.first);
                }
            }
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// Find shortest path (unweighted)</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shortestPath</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
        <span class="hljs-keyword">if</span> (start == end) {
            <span class="hljs-keyword">return</span> {start};
        }

        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;

        visited.insert(start);
        q.push({start});

        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; path = q.front();
            q.pop();

            <span class="hljs-keyword">int</span> vertex = path.back();
            <span class="hljs-keyword">auto</span> neighbors = graph.getNeighbors(vertex);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbor : neighbors) {
                <span class="hljs-keyword">if</span> (neighbor.first == end) {
                    path.push_back(neighbor.first);
                    <span class="hljs-keyword">return</span> path;
                }

                <span class="hljs-keyword">if</span> (visited.find(neighbor.first) == visited.end()) {
                    visited.insert(neighbor.first);
                    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; newPath = path;
                    newPath.push_back(neighbor.first);
                    q.push(newPath);
                }
            }
        }

        <span class="hljs-keyword">return</span> {}; <span class="hljs-comment">// No path found</span>
    }

    <span class="hljs-comment">// Find shortest distance</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">shortestDistance</span><span class="hljs-params">(GraphAdjacencyList&amp; graph, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
        <span class="hljs-keyword">if</span> (start == end) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;
        <span class="hljs-built_in">queue</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; q; <span class="hljs-comment">// vertex, distance</span>

        visited.insert(start);
        q.push({start, <span class="hljs-number">0</span>});

        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-keyword">auto</span> [vertex, distance] = q.front();
            q.pop();

            <span class="hljs-keyword">auto</span> neighbors = graph.getNeighbors(vertex);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; neighbor : neighbors) {
                <span class="hljs-keyword">if</span> (neighbor.first == end) {
                    <span class="hljs-keyword">return</span> distance + <span class="hljs-number">1</span>;
                }

                <span class="hljs-keyword">if</span> (visited.find(neighbor.first) == visited.end()) {
                    visited.insert(neighbor.first);
                    q.push({neighbor.first, distance + <span class="hljs-number">1</span>});
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// No path found</span>
    }
};

<span class="hljs-comment">// Utility functions</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; vec, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : vec) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Basic Graph Theory Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Create undirected graph</span>
    <span class="hljs-function">GraphAdjacencyList <span class="hljs-title">graph</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;

    <span class="hljs-comment">// Add vertices and edges</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
        graph.addVertex(i);
    }

    graph.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    graph.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
    graph.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);
    graph.addEdge(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
    graph.addEdge(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Graph Structure ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    graph.printGraph();

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Graph Traversals ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printVector(GraphDFS::dfsRecursive(graph, <span class="hljs-number">1</span>), <span class="hljs-string">"DFS (Recursive)"</span>);
    printVector(GraphDFS::dfsIterative(graph, <span class="hljs-number">1</span>), <span class="hljs-string">"DFS (Iterative)"</span>);
    printVector(GraphBFS::bfs(graph, <span class="hljs-number">1</span>), <span class="hljs-string">"BFS"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Path Finding ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printVector(GraphDFS::findPath(graph, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>), <span class="hljs-string">"Path 1 to 5"</span>);
    printVector(GraphBFS::shortestPath(graph, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>), <span class="hljs-string">"Shortest path 1 to 5"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Shortest distance 1 to 5: "</span> &lt;&lt; GraphBFS::shortestDistance(graph, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Graph Properties ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Has cycle: "</span> &lt;&lt; (GraphDFS::hasCycleUndirected(graph) ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Adjacency matrix example</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Adjacency Matrix ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-function">GraphAdjacencyMatrix <span class="hljs-title">matrixGraph</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-literal">false</span>)</span></span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
        matrixGraph.addVertex(i);
    }

    matrixGraph.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    matrixGraph.addEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
    matrixGraph.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
    matrixGraph.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);

    matrixGraph.printMatrix();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="representation-comparison">Representation Comparison:</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Adjacency List</th>
<th>Adjacency Matrix</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Add Vertex</strong></td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>Add Edge</strong></td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>Remove Edge</strong></td>
<td>O(V)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>Check Edge</strong></td>
<td>O(V)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>Get Neighbors</strong></td>
<td>O(degree)</td>
<td>O(V)</td>
</tr>
<tr>
<td><strong>Space</strong></td>
<td>O(V + E)</td>
<td>O(V²)</td>
</tr>
</tbody>
</table>
<h3 id="when-to-use-each">When to Use Each:</h3>
<p><strong>Adjacency List</strong>:</p>
<ul>
<li>✅ Sparse graphs (E &lt;&lt; V²)</li>
<li>✅ Memory-constrained environments</li>
<li>✅ Frequent traversals</li>
<li>❌ Frequent edge lookups</li>
</ul>
<p><strong>Adjacency Matrix</strong>:</p>
<ul>
<li>✅ Dense graphs (E ≈ V²)</li>
<li>✅ Frequent edge lookups</li>
<li>✅ Simple implementation</li>
<li>❌ Memory-constrained environments</li>
</ul>
<h3 id="traversal-complexity">Traversal Complexity:</h3>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Time</th>
<th>Space</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DFS</strong></td>
<td>O(V + E)</td>
<td>O(V)</td>
<td>Path finding, cycle detection</td>
</tr>
<tr>
<td><strong>BFS</strong></td>
<td>O(V + E)</td>
<td>O(V)</td>
<td>Shortest path, level-order</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-number-of-islands">Problem 1: Number of Islands</h3>
<p><strong>Question</strong>: Count number of islands in 2D grid (1=land, 0=water).</p>
<p><strong>Example</strong>:</p>
<pre class="hljs"><code><div>11110
11010
11000
00000
</div></code></pre>
<p><strong>Output</strong>: 1</p>
<p><strong>Hint</strong>: Use DFS/BFS to explore connected components.</p>
<h3 id="problem-2-clone-graph">Problem 2: Clone Graph</h3>
<p><strong>Question</strong>: Deep clone an undirected graph.</p>
<p><strong>Hint</strong>: Use DFS/BFS with hash map to track cloned nodes.</p>
<h3 id="problem-3-course-schedule">Problem 3: Course Schedule</h3>
<p><strong>Question</strong>: Determine if you can finish all courses given prerequisites.</p>
<p><strong>Hint</strong>: Model as directed graph, detect cycles.</p>
<h3 id="problem-4-word-ladder">Problem 4: Word Ladder</h3>
<p><strong>Question</strong>: Find shortest transformation sequence from start to end word.</p>
<p><strong>Hint</strong>: Model as graph where words are vertices, edges connect words differing by one character.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Representation choice</strong>: Can you choose appropriate representation?</li>
<li><strong>Traversal mastery</strong>: Know DFS and BFS implementations</li>
<li><strong>Problem modeling</strong>: Can you model real problems as graphs?</li>
<li><strong>Complexity analysis</strong>: Understand time/space trade-offs</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Connected components</strong>: Use DFS/BFS to find groups</li>
<li><strong>Cycle detection</strong>: DFS with recursion stack (directed) or parent tracking (undirected)</li>
<li><strong>Shortest path</strong>: BFS for unweighted, Dijkstra for weighted</li>
<li><strong>Topological sort</strong>: DFS-based ordering for DAGs</li>
<li><strong>Bipartite checking</strong>: BFS with 2-coloring</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Confusing directed vs undirected graphs</li>
<li>Not handling disconnected components</li>
<li>Infinite loops in traversal</li>
<li>Wrong complexity analysis</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Clarify graph type</strong>: Directed? Weighted? Connected?</li>
<li><strong>Choose representation wisely</strong>: Consider space/time trade-offs</li>
<li><strong>Handle edge cases</strong>: Empty graph, single vertex, disconnected components</li>
<li><strong>Practice both traversals</strong>: DFS and BFS have different use cases</li>
<li><strong>Think in terms of problems</strong>: Many problems are graph problems in disguise</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Graphs model relationships</strong> - Fundamental for many real-world problems</li>
<li><strong>Two main representations</strong> - Adjacency list vs matrix trade-offs</li>
<li><strong>DFS goes deep</strong> - Good for path finding and cycle detection</li>
<li><strong>BFS goes wide</strong> - Good for shortest paths and level-order processing</li>
<li><strong>Many problems are graphs</strong> - Social networks, dependencies, maps</li>
<li><strong>Practice recognition</strong> - Learn to identify graph problems</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Two Pointers technique and see how it optimizes array and string problems.</p>
<h1 id="chapter-11-two-pointers---efficient-array--string-processing">Chapter 11: Two Pointers - Efficient Array &amp; String Processing</h1>
<h2 id="%F0%9F%8E%AF-what-is-the-two-pointers-technique">🎯 What is the Two Pointers Technique?</h2>
<p><strong>Two Pointers</strong> is an algorithmic pattern that uses two pointers to traverse data structures, typically arrays or strings, to solve problems more efficiently than brute force approaches. Instead of nested loops (O(n²)), we often achieve O(n) time complexity.</p>
<h3 id="why-two-pointers-matter">Why Two Pointers Matter:</h3>
<ul>
<li><strong>Optimization</strong>: Reduces time complexity from O(n²) to O(n)</li>
<li><strong>Space efficiency</strong>: Usually O(1) extra space</li>
<li><strong>Versatile</strong>: Works on arrays, strings, linked lists</li>
<li><strong>Interview favorite</strong>: Common in coding interviews</li>
<li><strong>Real applications</strong>: Data processing, algorithms, system design</li>
</ul>
<h3 id="core-concept">Core Concept:</h3>
<p>Use two pointers that move through the data structure according to specific rules to find solutions without examining all possible pairs.</p>
<hr>
<h2 id="%F0%9F%93%8A-two-pointers-patterns">📊 Two Pointers Patterns</h2>
<h3 id="pattern-classifications">Pattern Classifications:</h3>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>Description</th>
<th>Movement</th>
<th>Use Cases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Opposite Direction</strong></td>
<td>Start from ends, move toward center</td>
<td><code>left++</code>, <code>right--</code></td>
<td>Palindromes, Two Sum (sorted)</td>
</tr>
<tr>
<td><strong>Same Direction</strong></td>
<td>Both start from beginning</td>
<td><code>slow++</code>, <code>fast++</code></td>
<td>Remove duplicates, sliding window</td>
</tr>
<tr>
<td><strong>Fast &amp; Slow</strong></td>
<td>Different speeds</td>
<td><code>slow++</code>, <code>fast += 2</code></td>
<td>Cycle detection, middle element</td>
</tr>
<tr>
<td><strong>Sliding Window</strong></td>
<td>Maintain window size</td>
<td>Expand/contract window</td>
<td>Subarray problems</td>
</tr>
</tbody>
</table>
<h3 id="when-to-use-two-pointers">When to Use Two Pointers:</h3>
<ul>
<li>✅ <strong>Sorted arrays</strong>: Take advantage of ordering</li>
<li>✅ <strong>Palindrome problems</strong>: Check from both ends</li>
<li>✅ <strong>Pair/triplet finding</strong>: Avoid nested loops</li>
<li>✅ <strong>Subarray problems</strong>: Maintain window efficiently</li>
<li>✅ <strong>Linked list problems</strong>: Fast/slow pointer techniques</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Two Pointers Technique - Comprehensive Implementation</span>

<span class="hljs-comment">// ===== PATTERN 1: OPPOSITE DIRECTION POINTERS =====</span>

<span class="hljs-comment">/**
 * Two Sum - Find pair that sums to target (sorted array)
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSumSorted</span>(<span class="hljs-params">nums, target</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = nums.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">const</span> sum = nums[left] + nums[right];

        <span class="hljs-keyword">if</span> (sum === target) {
            <span class="hljs-keyword">return</span> [left, right]; <span class="hljs-comment">// Return indices</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {
            left++; <span class="hljs-comment">// Need larger sum</span>
        } <span class="hljs-keyword">else</span> {
            right--; <span class="hljs-comment">// Need smaller sum</span>
        }
    }

    <span class="hljs-keyword">return</span> [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>]; <span class="hljs-comment">// No solution found</span>
}

<span class="hljs-comment">/**
 * Valid Palindrome - Check if string is palindrome
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPalindrome</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-comment">// Clean string: remove non-alphanumeric, convert to lowercase</span>
    <span class="hljs-keyword">const</span> cleaned = s.replace(<span class="hljs-regexp">/[^a-zA-Z0-9]/g</span>, <span class="hljs-string">''</span>).toLowerCase();

    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = cleaned.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">if</span> (cleaned[left] !== cleaned[right]) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        left++;
        right--;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">/**
 * Three Sum - Find all unique triplets that sum to zero
 * Time: O(n²), Space: O(1) excluding output
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">threeSum</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">const</span> result = [];
    nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// Sort array first</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) {
        <span class="hljs-comment">// Skip duplicates for first element</span>
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) {
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">let</span> left = i + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">let</span> right = nums.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> target = -nums[i]; <span class="hljs-comment">// We want nums[i] + nums[left] + nums[right] = 0</span>

        <span class="hljs-keyword">while</span> (left &lt; right) {
            <span class="hljs-keyword">const</span> sum = nums[left] + nums[right];

            <span class="hljs-keyword">if</span> (sum === target) {
                result.push([nums[i], nums[left], nums[right]]);

                <span class="hljs-comment">// Skip duplicates for second element</span>
                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) {
                    left++;
                }
                <span class="hljs-comment">// Skip duplicates for third element</span>
                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) {
                    right--;
                }

                left++;
                right--;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {
                left++;
            } <span class="hljs-keyword">else</span> {
                right--;
            }
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Container With Most Water - Find maximum area
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxArea</span>(<span class="hljs-params">height</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = height.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> maxWater = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-comment">// Calculate current area</span>
        <span class="hljs-keyword">const</span> width = right - left;
        <span class="hljs-keyword">const</span> currentHeight = <span class="hljs-built_in">Math</span>.min(height[left], height[right]);
        <span class="hljs-keyword">const</span> area = width * currentHeight;

        maxWater = <span class="hljs-built_in">Math</span>.max(maxWater, area);

        <span class="hljs-comment">// Move pointer with smaller height</span>
        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) {
            left++;
        } <span class="hljs-keyword">else</span> {
            right--;
        }
    }

    <span class="hljs-keyword">return</span> maxWater;
}

<span class="hljs-comment">/**
 * Reverse Array In-Place
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseArray</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-comment">// Swap elements</span>
        [arr[left], arr[right]] = [arr[right], arr[left]];
        left++;
        right--;
    }

    <span class="hljs-keyword">return</span> arr;
}

<span class="hljs-comment">// ===== PATTERN 2: SAME DIRECTION POINTERS =====</span>

<span class="hljs-comment">/**
 * Remove Duplicates from Sorted Array
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeDuplicates</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.length;

    <span class="hljs-keyword">let</span> writeIndex = <span class="hljs-number">1</span>; <span class="hljs-comment">// Position to write next unique element</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> readIndex = <span class="hljs-number">1</span>; readIndex &lt; nums.length; readIndex++) {
        <span class="hljs-keyword">if</span> (nums[readIndex] !== nums[readIndex - <span class="hljs-number">1</span>]) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    <span class="hljs-keyword">return</span> writeIndex; <span class="hljs-comment">// New length</span>
}

<span class="hljs-comment">/**
 * Remove Element - Remove all instances of val
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeElement</span>(<span class="hljs-params">nums, val</span>) </span>{
    <span class="hljs-keyword">let</span> writeIndex = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> readIndex = <span class="hljs-number">0</span>; readIndex &lt; nums.length; readIndex++) {
        <span class="hljs-keyword">if</span> (nums[readIndex] !== val) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    <span class="hljs-keyword">return</span> writeIndex;
}

<span class="hljs-comment">/**
 * Move Zeros - Move all zeros to end
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveZeroes</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> writeIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// Position for next non-zero element</span>

    <span class="hljs-comment">// Move all non-zero elements to front</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> readIndex = <span class="hljs-number">0</span>; readIndex &lt; nums.length; readIndex++) {
        <span class="hljs-keyword">if</span> (nums[readIndex] !== <span class="hljs-number">0</span>) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    <span class="hljs-comment">// Fill remaining positions with zeros</span>
    <span class="hljs-keyword">while</span> (writeIndex &lt; nums.length) {
        nums[writeIndex] = <span class="hljs-number">0</span>;
        writeIndex++;
    }

    <span class="hljs-keyword">return</span> nums;
}

<span class="hljs-comment">/**
 * Partition Array - Rearrange so elements &lt; x come before elements &gt;= x
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">nums, x</span>) </span>{
    <span class="hljs-keyword">let</span> writeIndex = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// First pass: move elements &lt; x to front</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> readIndex = <span class="hljs-number">0</span>; readIndex &lt; nums.length; readIndex++) {
        <span class="hljs-keyword">if</span> (nums[readIndex] &lt; x) {
            [nums[writeIndex], nums[readIndex]] = [nums[readIndex], nums[writeIndex]];
            writeIndex++;
        }
    }

    <span class="hljs-keyword">return</span> nums;
}

<span class="hljs-comment">// ===== PATTERN 3: FAST &amp; SLOW POINTERS =====</span>

<span class="hljs-comment">/**
 * Find Middle of Array/Linked List
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findMiddle</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Fast pointer moves 2 steps, slow moves 1 step</span>
    <span class="hljs-keyword">while</span> (fast &lt; arr.length - <span class="hljs-number">1</span> &amp;&amp; fast &lt; arr.length - <span class="hljs-number">2</span>) {
        slow++;
        fast += <span class="hljs-number">2</span>;
    }

    <span class="hljs-keyword">return</span> arr[slow];
}

<span class="hljs-comment">/**
 * Detect Cycle in Array (using indices as next pointers)
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Phase 1: Detect if cycle exists</span>
    <span class="hljs-keyword">do</span> {
        slow = <span class="hljs-built_in">Math</span>.abs(nums[slow]) % nums.length;
        fast = <span class="hljs-built_in">Math</span>.abs(nums[<span class="hljs-built_in">Math</span>.abs(nums[fast]) % nums.length]) % nums.length;
    } <span class="hljs-keyword">while</span> (slow !== fast);

    <span class="hljs-comment">// Phase 2: Find cycle start (if needed)</span>
    slow = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (slow !== fast) {
        slow = <span class="hljs-built_in">Math</span>.abs(nums[slow]) % nums.length;
        fast = <span class="hljs-built_in">Math</span>.abs(nums[fast]) % nums.length;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Cycle detected</span>
}

<span class="hljs-comment">// ===== PATTERN 4: SLIDING WINDOW WITH TWO POINTERS =====</span>

<span class="hljs-comment">/**
 * Longest Substring Without Repeating Characters
 * Time: O(n), Space: O(min(m,n)) where m is charset size
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">const</span> charSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.length; right++) {
        <span class="hljs-comment">// Shrink window until no duplicates</span>
        <span class="hljs-keyword">while</span> (charSet.has(s[right])) {
            charSet.delete(s[left]);
            left++;
        }

        charSet.add(s[right]);
        maxLength = <span class="hljs-built_in">Math</span>.max(maxLength, right - left + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">/**
 * Minimum Window Substring
 * Time: O(|s| + |t|), Space: O(|s| + |t|)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minWindow</span>(<span class="hljs-params">s, t</span>) </span>{
    <span class="hljs-keyword">if</span> (s.length &lt; t.length) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;

    <span class="hljs-comment">// Count characters in t</span>
    <span class="hljs-keyword">const</span> targetCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> t) {
        targetCount.set(char, (targetCount.get(char) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> minLength = <span class="hljs-literal">Infinity</span>;
    <span class="hljs-keyword">let</span> minStart = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> required = targetCount.size;
    <span class="hljs-keyword">let</span> formed = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> windowCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.length; right++) {
        <span class="hljs-keyword">const</span> char = s[right];
        windowCount.set(char, (windowCount.get(char) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);

        <span class="hljs-keyword">if</span> (targetCount.has(char) &amp;&amp; windowCount.get(char) === targetCount.get(char)) {
            formed++;
        }

        <span class="hljs-comment">// Try to shrink window</span>
        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; formed === required) {
            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; minLength) {
                minLength = right - left + <span class="hljs-number">1</span>;
                minStart = left;
            }

            <span class="hljs-keyword">const</span> leftChar = s[left];
            windowCount.set(leftChar, windowCount.get(leftChar) - <span class="hljs-number">1</span>);

            <span class="hljs-keyword">if</span> (targetCount.has(leftChar) &amp;&amp; windowCount.get(leftChar) &lt; targetCount.get(leftChar)) {
                formed--;
            }

            left++;
        }
    }

    <span class="hljs-keyword">return</span> minLength === <span class="hljs-literal">Infinity</span> ? <span class="hljs-string">""</span> : s.substring(minStart, minStart + minLength);
}

<span class="hljs-comment">/**
 * Subarray Sum Equals K (for positive numbers)
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subarraySum</span>(<span class="hljs-params">nums, k</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> currentSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; nums.length; right++) {
        currentSum += nums[right];

        <span class="hljs-comment">// Shrink window if sum exceeds k</span>
        <span class="hljs-keyword">while</span> (currentSum &gt; k &amp;&amp; left &lt;= right) {
            currentSum -= nums[left];
            left++;
        }

        <span class="hljs-keyword">if</span> (currentSum === k) {
            count++;
        }
    }

    <span class="hljs-keyword">return</span> count;
}

<span class="hljs-comment">// ===== ADVANCED TWO POINTERS TECHNIQUES =====</span>

<span class="hljs-comment">/**
 * Four Sum - Find all unique quadruplets that sum to target
 * Time: O(n³), Space: O(1) excluding output
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fourSum</span>(<span class="hljs-params">nums, target</span>) </span>{
    <span class="hljs-keyword">const</span> result = [];
    nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">3</span>; i++) {
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length - <span class="hljs-number">2</span>; j++) {
            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] === nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;

            <span class="hljs-keyword">let</span> left = j + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">let</span> right = nums.length - <span class="hljs-number">1</span>;

            <span class="hljs-keyword">while</span> (left &lt; right) {
                <span class="hljs-keyword">const</span> sum = nums[i] + nums[j] + nums[left] + nums[right];

                <span class="hljs-keyword">if</span> (sum === target) {
                    result.push([nums[i], nums[j], nums[left], nums[right]]);

                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="hljs-number">1</span>]) left++;
                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="hljs-number">1</span>]) right--;

                    left++;
                    right--;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {
                    left++;
                } <span class="hljs-keyword">else</span> {
                    right--;
                }
            }
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Trapping Rain Water
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trap</span>(<span class="hljs-params">height</span>) </span>{
    <span class="hljs-keyword">if</span> (height.length &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = height.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> leftMax = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> rightMax = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> water = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) {
            <span class="hljs-keyword">if</span> (height[left] &gt;= leftMax) {
                leftMax = height[left];
            } <span class="hljs-keyword">else</span> {
                water += leftMax - height[left];
            }
            left++;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (height[right] &gt;= rightMax) {
                rightMax = height[right];
            } <span class="hljs-keyword">else</span> {
                water += rightMax - height[right];
            }
            right--;
        }
    }

    <span class="hljs-keyword">return</span> water;
}

<span class="hljs-comment">/**
 * Sort Colors (Dutch National Flag)
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortColors</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;    <span class="hljs-comment">// Boundary for 0s</span>
    <span class="hljs-keyword">let</span> current = <span class="hljs-number">0</span>; <span class="hljs-comment">// Current element</span>
    <span class="hljs-keyword">let</span> right = nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// Boundary for 2s</span>

    <span class="hljs-keyword">while</span> (current &lt;= right) {
        <span class="hljs-keyword">if</span> (nums[current] === <span class="hljs-number">0</span>) {
            [nums[left], nums[current]] = [nums[current], nums[left]];
            left++;
            current++;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[current] === <span class="hljs-number">2</span>) {
            [nums[current], nums[right]] = [nums[right], nums[current]];
            right--;
            <span class="hljs-comment">// Don't increment current as we need to check swapped element</span>
        } <span class="hljs-keyword">else</span> {
            current++; <span class="hljs-comment">// nums[current] === 1</span>
        }
    }

    <span class="hljs-keyword">return</span> nums;
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-comment">/**
 * Two Pointers Template for Custom Problems
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoPointersTemplate</span>(<span class="hljs-params">arr, condition</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = arr.length - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">if</span> (condition(arr[left], arr[right])) {
            <span class="hljs-comment">// Found solution or move both pointers</span>
            <span class="hljs-keyword">return</span> [left, right];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* need to increase something */</span>) {
            left++;
        } <span class="hljs-keyword">else</span> {
            right--;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// No solution found</span>
}

<span class="hljs-comment">/**
 * Performance Testing
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performanceTest</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'=== Two Pointers Performance Test ==='</span>);

    <span class="hljs-comment">// Generate test data</span>
    <span class="hljs-keyword">const</span> sizes = [<span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">100000</span>];

    sizes.forEach(<span class="hljs-function"><span class="hljs-params">size</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from({<span class="hljs-attr">length</span>: size}, (_, i) =&gt; i);
        <span class="hljs-keyword">const</span> target = size - <span class="hljs-number">1</span>;

        <span class="hljs-built_in">console</span>.time(<span class="hljs-string">`Two Sum (size: <span class="hljs-subst">${size}</span>)`</span>);
        twoSumSorted(arr, target);
        <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">`Two Sum (size: <span class="hljs-subst">${size}</span>)`</span>);

        <span class="hljs-built_in">console</span>.time(<span class="hljs-string">`Remove Duplicates (size: <span class="hljs-subst">${size}</span>)`</span>);
        removeDuplicates([...arr, ...arr]); <span class="hljs-comment">// Create duplicates</span>
        <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">`Remove Duplicates (size: <span class="hljs-subst">${size}</span>)`</span>);
    });
}

<span class="hljs-comment">// ===== EXAMPLE USAGE AND TESTING =====</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'=== Two Pointers Technique Demo ==='</span>);

<span class="hljs-comment">// Test Opposite Direction Pattern</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n=== Opposite Direction Pattern ==='</span>);
<span class="hljs-keyword">const</span> sortedArray = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Two Sum:'</span>, twoSumSorted(sortedArray, <span class="hljs-number">9</span>)); <span class="hljs-comment">// [0, 1]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Is Palindrome "racecar":'</span>, isPalindrome(<span class="hljs-string">'racecar'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Is Palindrome "race a car":'</span>, isPalindrome(<span class="hljs-string">'race a car'</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Three Sum:'</span>, threeSum([<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-4</span>])); <span class="hljs-comment">// [[-1,-1,2],[-1,0,1]]</span>

<span class="hljs-keyword">const</span> heights = [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Max Area:'</span>, maxArea(heights)); <span class="hljs-comment">// 49</span>

<span class="hljs-keyword">const</span> testArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Original:'</span>, testArray);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Reversed:'</span>, reverseArray([...testArray])); <span class="hljs-comment">// [5, 4, 3, 2, 1]</span>

<span class="hljs-comment">// Test Same Direction Pattern</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n=== Same Direction Pattern ==='</span>);
<span class="hljs-keyword">const</span> duplicatesArray = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Remove Duplicates:'</span>, removeDuplicates([...duplicatesArray])); <span class="hljs-comment">// 5</span>

<span class="hljs-keyword">const</span> elementArray = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Remove Element 3:'</span>, removeElement([...elementArray], <span class="hljs-number">3</span>)); <span class="hljs-comment">// 4</span>

<span class="hljs-keyword">const</span> zerosArray = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Move Zeros:'</span>, moveZeroes([...zerosArray])); <span class="hljs-comment">// [1, 3, 12, 0, 0]</span>

<span class="hljs-keyword">const</span> partitionArray = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Partition around 5:'</span>, partition([...partitionArray], <span class="hljs-number">5</span>)); <span class="hljs-comment">// [3, 1, 4, 1, 2, 9, 5, 6]</span>

<span class="hljs-comment">// Test Fast &amp; Slow Pattern</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n=== Fast &amp; Slow Pattern ==='</span>);
<span class="hljs-keyword">const</span> middleArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Find Middle:'</span>, findMiddle(middleArray)); <span class="hljs-comment">// 4</span>

<span class="hljs-comment">// Test Sliding Window Pattern</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n=== Sliding Window Pattern ==='</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Longest Substring:'</span>, lengthOfLongestSubstring(<span class="hljs-string">'abcabcbb'</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Min Window:'</span>, minWindow(<span class="hljs-string">'ADOBECODEBANC'</span>, <span class="hljs-string">'ABC'</span>)); <span class="hljs-comment">// 'BANC'</span>

<span class="hljs-keyword">const</span> sumArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Subarray Sum (k=5):'</span>, subarraySum(sumArray, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// Test Advanced Techniques</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n=== Advanced Techniques ==='</span>);
<span class="hljs-keyword">const</span> fourSumArray = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Four Sum (target=0):'</span>, fourSum(fourSumArray, <span class="hljs-number">0</span>));

<span class="hljs-keyword">const</span> rainArray = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Trapped Rain Water:'</span>, trap(rainArray)); <span class="hljs-comment">// 6</span>

<span class="hljs-keyword">const</span> colorsArray = [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Sort Colors:'</span>, sortColors([...colorsArray])); <span class="hljs-comment">// [0, 0, 1, 1, 2, 2]</span>

<span class="hljs-comment">// Performance test</span>
performanceTest();

<span class="hljs-comment">// Pattern Recognition Examples</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n=== Pattern Recognition ==='</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'When to use each pattern:'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1. Opposite Direction: Sorted arrays, palindromes, pair finding'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2. Same Direction: Remove elements, partitioning'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'3. Fast &amp; Slow: Cycle detection, finding middle'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'4. Sliding Window: Substring problems, subarray sums'</span>);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// ===== OPPOSITE DIRECTION POINTERS =====</span>

<span class="hljs-comment">// Two Sum in Sorted Array</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSumSorted</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">int</span> sum = nums[left] + nums[right];

        <span class="hljs-keyword">if</span> (sum == target) {
            <span class="hljs-keyword">return</span> {left, right};
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {
            left++;
        } <span class="hljs-keyword">else</span> {
            right--;
        }
    }

    <span class="hljs-keyword">return</span> {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};
}

<span class="hljs-comment">// Valid Palindrome</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-comment">// Skip non-alphanumeric characters</span>
        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !<span class="hljs-built_in">isalnum</span>(s[left])) left++;
        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !<span class="hljs-built_in">isalnum</span>(s[right])) right--;

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">tolower</span>(s[left]) != <span class="hljs-built_in">tolower</span>(s[right])) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        left++;
        right--;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">// Three Sum</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">threeSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
    sort(nums.begin(), nums.end());

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size() - <span class="hljs-number">2</span>; i++) {
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;

        <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>, right = nums.size() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> target = -nums[i];

        <span class="hljs-keyword">while</span> (left &lt; right) {
            <span class="hljs-keyword">int</span> sum = nums[left] + nums[right];

            <span class="hljs-keyword">if</span> (sum == target) {
                result.push_back({nums[i], nums[left], nums[right]});

                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;
                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;

                left++;
                right--;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) {
                left++;
            } <span class="hljs-keyword">else</span> {
                right--;
            }
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Container With Most Water</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = height.size() - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> maxWater = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">int</span> width = right - left;
        <span class="hljs-keyword">int</span> currentHeight = min(height[left], height[right]);
        <span class="hljs-keyword">int</span> area = width * currentHeight;

        maxWater = max(maxWater, area);

        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) {
            left++;
        } <span class="hljs-keyword">else</span> {
            right--;
        }
    }

    <span class="hljs-keyword">return</span> maxWater;
}

<span class="hljs-comment">// ===== SAME DIRECTION POINTERS =====</span>

<span class="hljs-comment">// Remove Duplicates from Sorted Array</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">if</span> (nums.size() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.size();

    <span class="hljs-keyword">int</span> writeIndex = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> readIndex = <span class="hljs-number">1</span>; readIndex &lt; nums.size(); readIndex++) {
        <span class="hljs-keyword">if</span> (nums[readIndex] != nums[readIndex - <span class="hljs-number">1</span>]) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    <span class="hljs-keyword">return</span> writeIndex;
}

<span class="hljs-comment">// Remove Element</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> val)</span> </span>{
    <span class="hljs-keyword">int</span> writeIndex = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> readIndex = <span class="hljs-number">0</span>; readIndex &lt; nums.size(); readIndex++) {
        <span class="hljs-keyword">if</span> (nums[readIndex] != val) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    <span class="hljs-keyword">return</span> writeIndex;
}

<span class="hljs-comment">// Move Zeros</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">int</span> writeIndex = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Move non-zero elements to front</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> readIndex = <span class="hljs-number">0</span>; readIndex &lt; nums.size(); readIndex++) {
        <span class="hljs-keyword">if</span> (nums[readIndex] != <span class="hljs-number">0</span>) {
            nums[writeIndex] = nums[readIndex];
            writeIndex++;
        }
    }

    <span class="hljs-comment">// Fill remaining with zeros</span>
    <span class="hljs-keyword">while</span> (writeIndex &lt; nums.size()) {
        nums[writeIndex] = <span class="hljs-number">0</span>;
        writeIndex++;
    }
}

<span class="hljs-comment">// ===== FAST &amp; SLOW POINTERS =====</span>

<span class="hljs-comment">// Find Middle Element</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMiddle</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>{
    <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (fast &lt; arr.size() - <span class="hljs-number">1</span> &amp;&amp; fast &lt; arr.size() - <span class="hljs-number">2</span>) {
        slow++;
        fast += <span class="hljs-number">2</span>;
    }

    <span class="hljs-keyword">return</span> arr[slow];
}

<span class="hljs-comment">// ===== SLIDING WINDOW =====</span>

<span class="hljs-comment">// Longest Substring Without Repeating Characters</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; charSet;
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; s.length(); right++) {
        <span class="hljs-keyword">while</span> (charSet.count(s[right])) {
            charSet.erase(s[left]);
            left++;
        }

        charSet.insert(s[right]);
        maxLength = max(maxLength, right - left + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">// Minimum Window Substring</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>{
    <span class="hljs-keyword">if</span> (s.length() &lt; t.length()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;

    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; targetCount;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) {
        targetCount[c]++;
    }

    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, minLength = INT_MAX, minStart = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> required = targetCount.size(), formed = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; windowCount;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; s.length(); right++) {
        <span class="hljs-keyword">char</span> c = s[right];
        windowCount[c]++;

        <span class="hljs-keyword">if</span> (targetCount.count(c) &amp;&amp; windowCount[c] == targetCount[c]) {
            formed++;
        }

        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; formed == required) {
            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; minLength) {
                minLength = right - left + <span class="hljs-number">1</span>;
                minStart = left;
            }

            <span class="hljs-keyword">char</span> leftChar = s[left];
            windowCount[leftChar]--;

            <span class="hljs-keyword">if</span> (targetCount.count(leftChar) &amp;&amp; windowCount[leftChar] &lt; targetCount[leftChar]) {
                formed--;
            }

            left++;
        }
    }

    <span class="hljs-keyword">return</span> minLength == INT_MAX ? <span class="hljs-string">""</span> : s.substr(minStart, minLength);
}

<span class="hljs-comment">// ===== ADVANCED TECHNIQUES =====</span>

<span class="hljs-comment">// Trapping Rain Water</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>{
    <span class="hljs-keyword">if</span> (height.size() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = height.size() - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> leftMax = <span class="hljs-number">0</span>, rightMax = <span class="hljs-number">0</span>, water = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) {
            <span class="hljs-keyword">if</span> (height[left] &gt;= leftMax) {
                leftMax = height[left];
            } <span class="hljs-keyword">else</span> {
                water += leftMax - height[left];
            }
            left++;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (height[right] &gt;= rightMax) {
                rightMax = height[right];
            } <span class="hljs-keyword">else</span> {
                water += rightMax - height[right];
            }
            right--;
        }
    }

    <span class="hljs-keyword">return</span> water;
}

<span class="hljs-comment">// Sort Colors (Dutch National Flag)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, current = <span class="hljs-number">0</span>, right = nums.size() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (current &lt;= right) {
        <span class="hljs-keyword">if</span> (nums[current] == <span class="hljs-number">0</span>) {
            swap(nums[left], nums[current]);
            left++;
            current++;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[current] == <span class="hljs-number">2</span>) {
            swap(nums[current], nums[right]);
            right--;
            <span class="hljs-comment">// Don't increment current</span>
        } <span class="hljs-keyword">else</span> {
            current++;
        }
    }
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;T&gt;&amp; vec, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; x : vec) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; row : matrix) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"["</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row.size(); i++) {
            <span class="hljs-built_in">cout</span> &lt;&lt; row[i];
            <span class="hljs-keyword">if</span> (i &lt; row.size() - <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">", "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Two Pointers Technique Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Opposite Direction</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Opposite Direction Pattern ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sortedArray = {<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>};
    <span class="hljs-keyword">auto</span> twoSumResult = twoSumSorted(sortedArray, <span class="hljs-number">9</span>);
    printVector(twoSumResult, <span class="hljs-string">"Two Sum"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is Palindrome 'racecar': "</span> &lt;&lt; (isPalindrome(<span class="hljs-string">"racecar"</span>) ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is Palindrome 'race a car': "</span> &lt;&lt; (isPalindrome(<span class="hljs-string">"race a car"</span>) ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; threeSumArray = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-4</span>};
    <span class="hljs-keyword">auto</span> threeSumResult = threeSum(threeSumArray);
    printMatrix(threeSumResult, <span class="hljs-string">"Three Sum"</span>);

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; heights = {<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Max Area: "</span> &lt;&lt; maxArea(heights) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Same Direction</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Same Direction Pattern ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; duplicatesArray = {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Remove Duplicates: "</span> &lt;&lt; removeDuplicates(duplicatesArray) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; elementArray = {<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Remove Element 3: "</span> &lt;&lt; removeElement(elementArray, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; zerosArray = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>};
    moveZeroes(zerosArray);
    printVector(zerosArray, <span class="hljs-string">"Move Zeros"</span>);

    <span class="hljs-comment">// Test Fast &amp; Slow</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Fast &amp; Slow Pattern ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; middleArray = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Find Middle: "</span> &lt;&lt; findMiddle(middleArray) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Sliding Window</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Sliding Window Pattern ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Longest Substring: "</span> &lt;&lt; lengthOfLongestSubstring(<span class="hljs-string">"abcabcbb"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Min Window: "</span> &lt;&lt; minWindow(<span class="hljs-string">"ADOBECODEBANC"</span>, <span class="hljs-string">"ABC"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Advanced</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Advanced Techniques ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rainArray = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Trapped Rain Water: "</span> &lt;&lt; trap(rainArray) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; colorsArray = {<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>};
    sortColors(colorsArray);
    printVector(colorsArray, <span class="hljs-string">"Sort Colors"</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity-improvements">Time Complexity Improvements:</h3>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Brute Force</th>
<th>Two Pointers</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Two Sum (sorted)</strong></td>
<td>O(n²)</td>
<td>O(n)</td>
<td>n times faster</td>
</tr>
<tr>
<td><strong>Three Sum</strong></td>
<td>O(n³)</td>
<td>O(n²)</td>
<td>n times faster</td>
</tr>
<tr>
<td><strong>Palindrome Check</strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>Same, but O(1) space</td>
</tr>
<tr>
<td><strong>Remove Duplicates</strong></td>
<td>O(n²)</td>
<td>O(n)</td>
<td>n times faster</td>
</tr>
<tr>
<td><strong>Container Water</strong></td>
<td>O(n²)</td>
<td>O(n)</td>
<td>n times faster</td>
</tr>
</tbody>
</table>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li>Most two-pointer solutions use <strong>O(1) extra space</strong></li>
<li>Sliding window may use <strong>O(k)</strong> where k is window size</li>
<li>Much better than hash-based solutions that use <strong>O(n) space</strong></li>
</ul>
<h3 id="when-two-pointers-wins">When Two Pointers Wins:</h3>
<ul>
<li>✅ <strong>Sorted arrays</strong>: Take advantage of ordering</li>
<li>✅ <strong>Pair/triplet problems</strong>: Avoid nested loops</li>
<li>✅ <strong>In-place operations</strong>: Minimize space usage</li>
<li>✅ <strong>Optimization problems</strong>: Find optimal solutions efficiently</li>
</ul>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-squares-of-sorted-array">Problem 1: Squares of Sorted Array</h3>
<p><strong>Question</strong>: Given sorted array, return squares in sorted order.
<strong>Example</strong>: <code>[-4,-1,0,3,10]</code> → <code>[0,1,9,16,100]</code>
<strong>Hint</strong>: Use two pointers from ends, compare absolute values.</p>
<h3 id="problem-2-intersection-of-two-arrays">Problem 2: Intersection of Two Arrays</h3>
<p><strong>Question</strong>: Find intersection of two sorted arrays.
<strong>Example</strong>: <code>[1,2,2,1]</code>, <code>[2,2]</code> → <code>[2]</code>
<strong>Hint</strong>: Use two pointers, advance smaller element.</p>
<h3 id="problem-3-merge-sorted-array">Problem 3: Merge Sorted Array</h3>
<p><strong>Question</strong>: Merge two sorted arrays in-place.
<strong>Example</strong>: <code>[1,2,3,0,0,0]</code>, <code>[2,5,6]</code> → <code>[1,2,2,3,5,6]</code>
<strong>Hint</strong>: Start from the end to avoid overwriting.</p>
<h3 id="problem-4-backspace-string-compare">Problem 4: Backspace String Compare</h3>
<p><strong>Question</strong>: Compare strings with backspaces (<code>#</code>).
<strong>Example</strong>: <code>&quot;ab#c&quot;</code>, <code>&quot;ad#c&quot;</code> → <code>true</code>
<strong>Hint</strong>: Process from end using two pointers.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Pattern recognition</strong>: Can you identify when to use two pointers?</li>
<li><strong>Pointer movement logic</strong>: Do you move pointers correctly?</li>
<li><strong>Edge case handling</strong>: Empty arrays, single elements, no solution</li>
<li><strong>Optimization thinking</strong>: Can you improve from brute force?</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Sorted array problems</strong>: Almost always consider two pointers</li>
<li><strong>Palindrome problems</strong>: Start from ends</li>
<li><strong>Sum problems</strong>: Use sorting + two pointers</li>
<li><strong>Sliding window</strong>: Expand/contract window with two pointers</li>
<li><strong>In-place operations</strong>: Use read/write pointers</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Moving pointers incorrectly (infinite loops)</li>
<li>Not handling duplicates properly</li>
<li>Forgetting edge cases (empty input, single element)</li>
<li>Using extra space when O(1) is possible</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Draw it out</strong>: Visualize pointer movements</li>
<li><strong>Start simple</strong>: Get basic case working first</li>
<li><strong>Handle duplicates</strong>: Often requires special logic</li>
<li><strong>Check boundaries</strong>: Ensure pointers don't go out of bounds</li>
<li><strong>Consider sorting</strong>: Sometimes preprocessing helps</li>
<li><strong>Think about invariants</strong>: What should be true at each step?</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Two pointers optimize nested loops</strong> - Reduce O(n²) to O(n)</li>
<li><strong>Four main patterns</strong> - Opposite, same direction, fast/slow, sliding window</li>
<li><strong>Sorted arrays are key</strong> - Ordering enables efficient pointer movement</li>
<li><strong>Space efficient</strong> - Usually O(1) extra space</li>
<li><strong>Interview favorite</strong> - Master the patterns for coding interviews</li>
<li><strong>Think before coding</strong> - Identify the pattern first</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Sliding Window technique in detail and see how it optimizes subarray and substring problems.</p>
<h1 id="chapter-12-sliding-window---optimizing-subarray--substring-problems">Chapter 12: Sliding Window - Optimizing Subarray &amp; Substring Problems</h1>
<h2 id="%F0%9F%8E%AF-what-is-the-sliding-window-technique">🎯 What is the Sliding Window Technique?</h2>
<p><strong>Sliding Window</strong> is an algorithmic pattern that maintains a &quot;window&quot; (subarray/substring) that slides through the data structure to solve problems efficiently. Instead of checking all possible subarrays (O(n²) or O(n³)), we maintain a window and adjust its size dynamically to achieve O(n) time complexity.</p>
<h3 id="why-sliding-window-matters">Why Sliding Window Matters:</h3>
<ul>
<li><strong>Optimization</strong>: Reduces time complexity from O(n²/n³) to O(n)</li>
<li><strong>Space efficiency</strong>: Usually O(1) or O(k) extra space</li>
<li><strong>Versatile</strong>: Works on arrays, strings, linked lists</li>
<li><strong>Real applications</strong>: Data streaming, network protocols, analytics</li>
<li><strong>Interview favorite</strong>: Common pattern in coding interviews</li>
</ul>
<h3 id="core-concept">Core Concept:</h3>
<p>Maintain a window with two pointers (left and right) and expand/contract the window based on problem constraints while tracking the optimal solution.</p>
<hr>
<h2 id="%F0%9F%93%8A-sliding-window-patterns">📊 Sliding Window Patterns</h2>
<h3 id="pattern-classifications">Pattern Classifications:</h3>
<table>
<thead>
<tr>
<th>Pattern</th>
<th>Window Size</th>
<th>Expansion/Contraction</th>
<th>Use Cases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Fixed Size</strong></td>
<td>Constant</td>
<td>Slide by 1 position</td>
<td>Max sum of k elements</td>
</tr>
<tr>
<td><strong>Variable Size</strong></td>
<td>Dynamic</td>
<td>Expand/contract based on condition</td>
<td>Longest substring</td>
</tr>
<tr>
<td><strong>Shrinkable</strong></td>
<td>Grows then shrinks</td>
<td>Expand until invalid, then shrink</td>
<td>Min window substring</td>
</tr>
<tr>
<td><strong>Non-shrinkable</strong></td>
<td>Only grows</td>
<td>Expand and slide</td>
<td>Longest valid window</td>
</tr>
</tbody>
</table>
<h3 id="when-to-use-sliding-window">When to Use Sliding Window:</h3>
<ul>
<li>✅ <strong>Contiguous subarray/substring problems</strong></li>
<li>✅ <strong>Optimization problems</strong> (min/max/longest/shortest)</li>
<li>✅ <strong>Problems with constraints</strong> (sum, distinct characters, etc.)</li>
<li>✅ <strong>Streaming data</strong> where you process elements sequentially</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Sliding Window Technique - Comprehensive Implementation</span>

<span class="hljs-comment">// ===== PATTERN 1: FIXED SIZE SLIDING WINDOW =====</span>

<span class="hljs-comment">/**
 * Maximum Sum of Subarray of Size K
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxSumSubarray</span>(<span class="hljs-params">arr, k</span>) </span>{
  <span class="hljs-keyword">if</span> (arr.length &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

  <span class="hljs-comment">// Calculate sum of first window</span>
  <span class="hljs-keyword">let</span> windowSum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {
    windowSum += arr[i];
  }

  <span class="hljs-keyword">let</span> maxSum = windowSum;

  <span class="hljs-comment">// Slide the window</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = k; i &lt; arr.length; i++) {
    windowSum = windowSum - arr[i - k] + arr[i];
    maxSum = <span class="hljs-built_in">Math</span>.max(maxSum, windowSum);
  }

  <span class="hljs-keyword">return</span> maxSum;
}

<span class="hljs-comment">/**
 * Average of All Subarrays of Size K
 * Time: O(n), Space: O(n-k+1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findAverages</span>(<span class="hljs-params">arr, k</span>) </span>{
  <span class="hljs-keyword">if</span> (arr.length &lt; k) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">let</span> windowSum = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Calculate sum of first window</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {
    windowSum += arr[i];
  }
  result.push(windowSum / k);

  <span class="hljs-comment">// Slide the window</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = k; i &lt; arr.length; i++) {
    windowSum = windowSum - arr[i - k] + arr[i];
    result.push(windowSum / k);
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Maximum of All Subarrays of Size K
 * Time: O(n), Space: O(k) using deque
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxSlidingWindow</span>(<span class="hljs-params">nums, k</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> deque = []; <span class="hljs-comment">// Store indices</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
    <span class="hljs-comment">// Remove indices outside current window</span>
    <span class="hljs-keyword">while</span> (deque.length &gt; <span class="hljs-number">0</span> &amp;&amp; deque[<span class="hljs-number">0</span>] &lt;= i - k) {
      deque.shift();
    }

    <span class="hljs-comment">// Remove indices of smaller elements</span>
    <span class="hljs-keyword">while</span> (deque.length &gt; <span class="hljs-number">0</span> &amp;&amp; nums[deque[deque.length - <span class="hljs-number">1</span>]] &lt;= nums[i]) {
      deque.pop();
    }

    deque.push(i);

    <span class="hljs-comment">// Add to result if window is complete</span>
    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) {
      result.push(nums[deque[<span class="hljs-number">0</span>]]);
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * First Negative Number in Every Window of Size K
 * Time: O(n), Space: O(k)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">firstNegativeInWindow</span>(<span class="hljs-params">arr, k</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> negatives = []; <span class="hljs-comment">// Queue of negative number indices</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    <span class="hljs-comment">// Remove indices outside current window</span>
    <span class="hljs-keyword">while</span> (negatives.length &gt; <span class="hljs-number">0</span> &amp;&amp; negatives[<span class="hljs-number">0</span>] &lt;= i - k) {
      negatives.shift();
    }

    <span class="hljs-comment">// Add current negative number</span>
    <span class="hljs-keyword">if</span> (arr[i] &lt; <span class="hljs-number">0</span>) {
      negatives.push(i);
    }

    <span class="hljs-comment">// Add result for current window</span>
    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) {
      result.push(negatives.length &gt; <span class="hljs-number">0</span> ? arr[negatives[<span class="hljs-number">0</span>]] : <span class="hljs-number">0</span>);
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== PATTERN 2: VARIABLE SIZE SLIDING WINDOW =====</span>

<span class="hljs-comment">/**
 * Longest Substring Without Repeating Characters
 * Time: O(n), Space: O(min(m,n)) where m is charset size
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">const</span> charSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.length; right++) {
    <span class="hljs-comment">// Shrink window until no duplicates</span>
    <span class="hljs-keyword">while</span> (charSet.has(s[right])) {
      charSet.delete(s[left]);
      left++;
    }

    charSet.add(s[right]);
    maxLength = <span class="hljs-built_in">Math</span>.max(maxLength, right - left + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">/**
 * Longest Substring with At Most K Distinct Characters
 * Time: O(n), Space: O(k)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lengthOfLongestSubstringKDistinct</span>(<span class="hljs-params">s, k</span>) </span>{
  <span class="hljs-keyword">if</span> (k === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> charCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.length; right++) {
    <span class="hljs-comment">// Add character to window</span>
    charCount.set(s[right], (charCount.get(s[right]) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);

    <span class="hljs-comment">// Shrink window if more than k distinct characters</span>
    <span class="hljs-keyword">while</span> (charCount.size &gt; k) {
      <span class="hljs-keyword">const</span> leftChar = s[left];
      charCount.set(leftChar, charCount.get(leftChar) - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (charCount.get(leftChar) === <span class="hljs-number">0</span>) {
        charCount.delete(leftChar);
      }
      left++;
    }

    maxLength = <span class="hljs-built_in">Math</span>.max(maxLength, right - left + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">/**
 * Longest Substring with At Most 2 Distinct Characters
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lengthOfLongestSubstringTwoDistinct</span>(<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">return</span> lengthOfLongestSubstringKDistinct(s, <span class="hljs-number">2</span>);
}

<span class="hljs-comment">/**
 * Longest Repeating Character Replacement
 * Time: O(n), Space: O(1) - at most 26 characters
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">characterReplacement</span>(<span class="hljs-params">s, k</span>) </span>{
  <span class="hljs-keyword">const</span> charCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> maxCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Count of most frequent character in current window</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.length; right++) {
    charCount.set(s[right], (charCount.get(s[right]) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
    maxCount = <span class="hljs-built_in">Math</span>.max(maxCount, charCount.get(s[right]));

    <span class="hljs-comment">// If window size - maxCount &gt; k, shrink window</span>
    <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> - maxCount &gt; k) {
      charCount.set(s[left], charCount.get(s[left]) - <span class="hljs-number">1</span>);
      left++;
    }

    maxLength = <span class="hljs-built_in">Math</span>.max(maxLength, right - left + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">/**
 * Subarray with Given Sum (Positive Numbers)
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subarraySum</span>(<span class="hljs-params">arr, targetSum</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> currentSum = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; arr.length; right++) {
    currentSum += arr[right];

    <span class="hljs-comment">// Shrink window if sum exceeds target</span>
    <span class="hljs-keyword">while</span> (currentSum &gt; targetSum &amp;&amp; left &lt;= right) {
      currentSum -= arr[left];
      left++;
    }

    <span class="hljs-keyword">if</span> (currentSum === targetSum) {
      <span class="hljs-keyword">return</span> [left, right]; <span class="hljs-comment">// Return indices</span>
    }
  }

  <span class="hljs-keyword">return</span> [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>]; <span class="hljs-comment">// No subarray found</span>
}

<span class="hljs-comment">/**
 * Smallest Subarray with Sum Greater Than X
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">smallestSubarrayWithSum</span>(<span class="hljs-params">arr, x</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> currentSum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> minLength = <span class="hljs-literal">Infinity</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; arr.length; right++) {
    currentSum += arr[right];

    <span class="hljs-comment">// Shrink window while sum &gt; x</span>
    <span class="hljs-keyword">while</span> (currentSum &gt; x &amp;&amp; left &lt;= right) {
      minLength = <span class="hljs-built_in">Math</span>.min(minLength, right - left + <span class="hljs-number">1</span>);
      currentSum -= arr[left];
      left++;
    }
  }

  <span class="hljs-keyword">return</span> minLength === <span class="hljs-literal">Infinity</span> ? <span class="hljs-number">0</span> : minLength;
}

<span class="hljs-comment">// ===== PATTERN 3: SHRINKABLE SLIDING WINDOW =====</span>

<span class="hljs-comment">/**
 * Minimum Window Substring
 * Time: O(|s| + |t|), Space: O(|s| + |t|)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minWindow</span>(<span class="hljs-params">s, t</span>) </span>{
  <span class="hljs-keyword">if</span> (s.length &lt; t.length) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;

  <span class="hljs-comment">// Count characters in t</span>
  <span class="hljs-keyword">const</span> targetCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> t) {
    targetCount.set(char, (targetCount.get(char) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> minLength = <span class="hljs-literal">Infinity</span>;
  <span class="hljs-keyword">let</span> minStart = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> required = targetCount.size;
  <span class="hljs-keyword">let</span> formed = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> windowCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.length; right++) {
    <span class="hljs-keyword">const</span> char = s[right];
    windowCount.set(char, (windowCount.get(char) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);

    <span class="hljs-keyword">if</span> (
      targetCount.has(char) &amp;&amp;
      windowCount.get(char) === targetCount.get(char)
    ) {
      formed++;
    }

    <span class="hljs-comment">// Try to shrink window</span>
    <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; formed === required) {
      <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; minLength) {
        minLength = right - left + <span class="hljs-number">1</span>;
        minStart = left;
      }

      <span class="hljs-keyword">const</span> leftChar = s[left];
      windowCount.set(leftChar, windowCount.get(leftChar) - <span class="hljs-number">1</span>);

      <span class="hljs-keyword">if</span> (
        targetCount.has(leftChar) &amp;&amp;
        windowCount.get(leftChar) &lt; targetCount.get(leftChar)
      ) {
        formed--;
      }

      left++;
    }
  }

  <span class="hljs-keyword">return</span> minLength === <span class="hljs-literal">Infinity</span>
    ? <span class="hljs-string">""</span>
    : s.substring(minStart, minStart + minLength);
}

<span class="hljs-comment">/**
 * Find All Anagrams in a String
 * Time: O(|s| + |p|), Space: O(1) - at most 26 characters
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findAnagrams</span>(<span class="hljs-params">s, p</span>) </span>{
  <span class="hljs-keyword">if</span> (s.length &lt; p.length) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> pCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">const</span> windowCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-comment">// Count characters in p</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> p) {
    pCount.set(char, (pCount.get(char) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">while</span> (right &lt; s.length) {
    <span class="hljs-comment">// Expand window</span>
    <span class="hljs-keyword">const</span> rightChar = s[right];
    windowCount.set(rightChar, (windowCount.get(rightChar) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);

    <span class="hljs-comment">// Shrink window if size exceeds p.length</span>
    <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; p.length) {
      <span class="hljs-keyword">const</span> leftChar = s[left];
      windowCount.set(leftChar, windowCount.get(leftChar) - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (windowCount.get(leftChar) === <span class="hljs-number">0</span>) {
        windowCount.delete(leftChar);
      }
      left++;
    }

    <span class="hljs-comment">// Check if current window is anagram</span>
    <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> === p.length &amp;&amp; mapsEqual(windowCount, pCount)) {
      result.push(left);
    }

    right++;
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Helper function to compare maps</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapsEqual</span>(<span class="hljs-params">map1, map2</span>) </span>{
  <span class="hljs-keyword">if</span> (map1.size !== map2.size) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map1) {
    <span class="hljs-keyword">if</span> (map2.get(key) !== value) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-comment">/**
 * Permutation in String
 * Time: O(|s1| + |s2|), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkInclusion</span>(<span class="hljs-params">s1, s2</span>) </span>{
  <span class="hljs-keyword">if</span> (s1.length &gt; s2.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">const</span> s1Count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">const</span> windowCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-comment">// Count characters in s1</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> s1) {
    s1Count.set(char, (s1Count.get(char) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s2.length; right++) {
    <span class="hljs-comment">// Expand window</span>
    <span class="hljs-keyword">const</span> rightChar = s2[right];
    windowCount.set(rightChar, (windowCount.get(rightChar) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);

    <span class="hljs-comment">// Shrink window if size exceeds s1.length</span>
    <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; s1.length) {
      <span class="hljs-keyword">const</span> leftChar = s2[left];
      windowCount.set(leftChar, windowCount.get(leftChar) - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (windowCount.get(leftChar) === <span class="hljs-number">0</span>) {
        windowCount.delete(leftChar);
      }
      left++;
    }

    <span class="hljs-comment">// Check if current window is permutation</span>
    <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> === s1.length &amp;&amp; mapsEqual(windowCount, s1Count)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">// ===== PATTERN 4: NON-SHRINKABLE SLIDING WINDOW =====</span>

<span class="hljs-comment">/**
 * Longest Subarray with Ones after Replacement
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longestOnes</span>(<span class="hljs-params">nums, k</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> zeroCount = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; nums.length; right++) {
    <span class="hljs-keyword">if</span> (nums[right] === <span class="hljs-number">0</span>) {
      zeroCount++;
    }

    <span class="hljs-comment">// Shrink window if zero count exceeds k</span>
    <span class="hljs-keyword">while</span> (zeroCount &gt; k) {
      <span class="hljs-keyword">if</span> (nums[left] === <span class="hljs-number">0</span>) {
        zeroCount--;
      }
      left++;
    }

    maxLength = <span class="hljs-built_in">Math</span>.max(maxLength, right - left + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">/**
 * Fruits into Baskets (At Most 2 Types)
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">totalFruit</span>(<span class="hljs-params">fruits</span>) </span>{
  <span class="hljs-keyword">const</span> fruitCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> maxFruits = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; fruits.length; right++) {
    fruitCount.set(fruits[right], (fruitCount.get(fruits[right]) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);

    <span class="hljs-comment">// Shrink window if more than 2 types</span>
    <span class="hljs-keyword">while</span> (fruitCount.size &gt; <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">const</span> leftFruit = fruits[left];
      fruitCount.set(leftFruit, fruitCount.get(leftFruit) - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">if</span> (fruitCount.get(leftFruit) === <span class="hljs-number">0</span>) {
        fruitCount.delete(leftFruit);
      }
      left++;
    }

    maxFruits = <span class="hljs-built_in">Math</span>.max(maxFruits, right - left + <span class="hljs-number">1</span>);
  }

  <span class="hljs-keyword">return</span> maxFruits;
}

<span class="hljs-comment">// ===== ADVANCED SLIDING WINDOW TECHNIQUES =====</span>

<span class="hljs-comment">/**
 * Sliding Window Maximum with Custom Comparator
 * Time: O(n log k), Space: O(k)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slidingWindowMaximumCustom</span>(<span class="hljs-params">nums, k, compareFn</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
    <span class="hljs-comment">// Remove elements outside window</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">window</span>.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>].index &lt;= i - k) {
      <span class="hljs-built_in">window</span>.shift();
    }

    <span class="hljs-comment">// Maintain decreasing order</span>
    <span class="hljs-keyword">while</span> (
      <span class="hljs-built_in">window</span>.length &gt; <span class="hljs-number">0</span> &amp;&amp;
      compareFn(nums[i], <span class="hljs-built_in">window</span>[<span class="hljs-built_in">window</span>.length - <span class="hljs-number">1</span>].value) &gt;= <span class="hljs-number">0</span>
    ) {
      <span class="hljs-built_in">window</span>.pop();
    }

    <span class="hljs-built_in">window</span>.push({ <span class="hljs-attr">value</span>: nums[i], <span class="hljs-attr">index</span>: i });

    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) {
      result.push(<span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>].value);
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Count Number of Nice Subarrays
 * Time: O(n), Space: O(1)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberOfSubarrays</span>(<span class="hljs-params">nums, k</span>) </span>{
  <span class="hljs-keyword">return</span> atMostK(nums, k) - atMostK(nums, k - <span class="hljs-number">1</span>);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">atMostK</span>(<span class="hljs-params">nums, k</span>) </span>{
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> oddCount = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; nums.length; right++) {
      <span class="hljs-keyword">if</span> (nums[right] % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {
        oddCount++;
      }

      <span class="hljs-keyword">while</span> (oddCount &gt; k) {
        <span class="hljs-keyword">if</span> (nums[left] % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) {
          oddCount--;
        }
        left++;
      }

      count += right - left + <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">return</span> count;
  }
}

<span class="hljs-comment">/**
 * Sliding Window Median
 * Time: O(n log k), Space: O(k)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">medianSlidingWindow</span>(<span class="hljs-params">nums, k</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
    <span class="hljs-comment">// Add current element</span>
    insertSorted(<span class="hljs-built_in">window</span>, nums[i]);

    <span class="hljs-comment">// Remove element outside window</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.length &gt; k) {
      <span class="hljs-keyword">const</span> toRemove = nums[i - k];
      <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">window</span>.indexOf(toRemove);
      <span class="hljs-built_in">window</span>.splice(index, <span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// Calculate median</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.length === k) {
      <span class="hljs-keyword">const</span> median =
        k % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>
          ? <span class="hljs-built_in">window</span>[<span class="hljs-built_in">Math</span>.floor(k / <span class="hljs-number">2</span>)]
          : (<span class="hljs-built_in">window</span>[k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] + <span class="hljs-built_in">window</span>[k / <span class="hljs-number">2</span>]) / <span class="hljs-number">2</span>;
      result.push(median);
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSorted</span>(<span class="hljs-params">arr, val</span>) </span>{
  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> right = arr.length;

  <span class="hljs-keyword">while</span> (left &lt; right) {
    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((left + right) / <span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span> (arr[mid] &lt; val) {
      left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      right = mid;
    }
  }

  arr.splice(left, <span class="hljs-number">0</span>, val);
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-comment">/**
 * Generic Sliding Window Template
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slidingWindowTemplate</span>(<span class="hljs-params">arr, k, operation</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">let</span> windowState = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    <span class="hljs-comment">// Add element to window</span>
    windowState = operation.add(windowState, arr[i], i);

    <span class="hljs-comment">// Remove element if window too large</span>
    <span class="hljs-keyword">if</span> (i &gt;= k) {
      windowState = operation.remove(windowState, arr[i - k], i - k);
    }

    <span class="hljs-comment">// Process window if complete</span>
    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) {
      result.push(operation.getResult(windowState));
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Performance Testing
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performanceTest</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Sliding Window Performance Test ==="</span>);

  <span class="hljs-keyword">const</span> sizes = [<span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">100000</span>];

  sizes.forEach(<span class="hljs-function">(<span class="hljs-params">size</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from({ <span class="hljs-attr">length</span>: size }, (_, i) =&gt;
      <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>)
    );
    <span class="hljs-keyword">const</span> k = <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">100</span>, size);

    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">`Max Sum Subarray (size: <span class="hljs-subst">${size}</span>)`</span>);
    maxSumSubarray(arr, k);
    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">`Max Sum Subarray (size: <span class="hljs-subst">${size}</span>)`</span>);

    <span class="hljs-keyword">const</span> str = <span class="hljs-built_in">Array</span>.from({ <span class="hljs-attr">length</span>: size }, () =&gt;
      <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">97</span> + <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">26</span>))
    ).join(<span class="hljs-string">""</span>);

    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">`Longest Substring (size: <span class="hljs-subst">${size}</span>)`</span>);
    lengthOfLongestSubstring(str);
    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">`Longest Substring (size: <span class="hljs-subst">${size}</span>)`</span>);
  });
}

<span class="hljs-comment">// ===== EXAMPLE USAGE AND TESTING =====</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Sliding Window Technique Demo ==="</span>);

<span class="hljs-comment">// Test Fixed Size Window</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Fixed Size Window ==="</span>);
<span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Max Sum (k=3):"</span>, maxSumSubarray(arr1, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 9</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Averages (k=3):"</span>, findAverages(arr1, <span class="hljs-number">3</span>)); <span class="hljs-comment">// [2.67, 2.33, 3, 2]</span>

<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Max Sliding Window (k=3):"</span>, maxSlidingWindow(arr2, <span class="hljs-number">3</span>)); <span class="hljs-comment">// [3, 3, 5, 5, 6, 7]</span>

<span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">12</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">16</span>, <span class="hljs-number">28</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"First Negative (k=3):"</span>, firstNegativeInWindow(arr3, <span class="hljs-number">3</span>)); <span class="hljs-comment">// [-1, -1, -7, -15, -15, 0]</span>

<span class="hljs-comment">// Test Variable Size Window</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Variable Size Window ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Longest Substring:"</span>, lengthOfLongestSubstring(<span class="hljs-string">"abcabcbb"</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Longest K Distinct:"</span>,
  lengthOfLongestSubstringKDistinct(<span class="hljs-string">"araaci"</span>, <span class="hljs-number">2</span>)
); <span class="hljs-comment">// 4</span>
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Longest 2 Distinct:"</span>,
  lengthOfLongestSubstringTwoDistinct(<span class="hljs-string">"eceba"</span>)
); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Character Replacement:"</span>, characterReplacement(<span class="hljs-string">"AABABBA"</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 4</span>

<span class="hljs-keyword">const</span> arr4 = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Subarray Sum (target=9):"</span>, subarraySum(arr4, <span class="hljs-number">9</span>)); <span class="hljs-comment">// [0, 2]</span>

<span class="hljs-keyword">const</span> arr5 = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Smallest Subarray (x=6):"</span>, smallestSubarrayWithSum(arr5, <span class="hljs-number">6</span>)); <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// Test Shrinkable Window</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Shrinkable Window ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Min Window:"</span>, minWindow(<span class="hljs-string">"ADOBECODEBANC"</span>, <span class="hljs-string">"ABC"</span>)); <span class="hljs-comment">// 'BANC'</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Find Anagrams:"</span>, findAnagrams(<span class="hljs-string">"abab"</span>, <span class="hljs-string">"ab"</span>)); <span class="hljs-comment">// [0, 2]</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Check Inclusion:"</span>, checkInclusion(<span class="hljs-string">"ab"</span>, <span class="hljs-string">"eidbaooo"</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Test Non-shrinkable Window</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Non-shrinkable Window ==="</span>);
<span class="hljs-keyword">const</span> arr6 = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Longest Ones (k=2):"</span>, longestOnes(arr6, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 6</span>

<span class="hljs-keyword">const</span> fruits = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Total Fruit:"</span>, totalFruit(fruits)); <span class="hljs-comment">// 3</span>

<span class="hljs-comment">// Test Advanced Techniques</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Advanced Techniques ==="</span>);
<span class="hljs-keyword">const</span> arr7 = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Nice Subarrays (k=3):"</span>, numberOfSubarrays(arr7, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 2</span>

<span class="hljs-keyword">const</span> arr8 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Sliding Window Median (k=3):"</span>, medianSlidingWindow(arr8, <span class="hljs-number">3</span>)); <span class="hljs-comment">// [1, -1, -1, 3, 5, 6]</span>

<span class="hljs-comment">// Custom comparator example</span>
<span class="hljs-keyword">const</span> customMax = slidingWindowMaximumCustom(arr2, <span class="hljs-number">3</span>, (a, b) =&gt; a - b);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Custom Max:"</span>, customMax);

<span class="hljs-comment">// Performance test</span>
performanceTest();

<span class="hljs-comment">// Pattern Recognition</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Pattern Recognition ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Choose the right pattern:"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"1. Fixed Size: When window size is constant"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"2. Variable Size: When optimizing window size"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"3. Shrinkable: When finding minimum valid window"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"4. Non-shrinkable: When finding maximum valid window"</span>);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// ===== FIXED SIZE SLIDING WINDOW =====</span>

<span class="hljs-comment">// Maximum Sum of Subarray of Size K</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSumSubarray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">if</span> (arr.size() &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">int</span> windowSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {
        windowSum += arr[i];
    }

    <span class="hljs-keyword">int</span> maxSum = windowSum;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; arr.size(); i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = max(maxSum, windowSum);
    }

    <span class="hljs-keyword">return</span> maxSum;
}

<span class="hljs-comment">// Maximum Sliding Window</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt; dq; <span class="hljs-comment">// Store indices</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) {
        <span class="hljs-comment">// Remove indices outside current window</span>
        <span class="hljs-keyword">while</span> (!dq.empty() &amp;&amp; dq.front() &lt;= i - k) {
            dq.pop_front();
        }

        <span class="hljs-comment">// Remove indices of smaller elements</span>
        <span class="hljs-keyword">while</span> (!dq.empty() &amp;&amp; nums[dq.back()] &lt;= nums[i]) {
            dq.pop_back();
        }

        dq.push_back(i);

        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) {
            result.push_back(nums[dq.front()]);
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== VARIABLE SIZE SLIDING WINDOW =====</span>

<span class="hljs-comment">// Longest Substring Without Repeating Characters</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; charSet;
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; s.length(); right++) {
        <span class="hljs-keyword">while</span> (charSet.count(s[right])) {
            charSet.erase(s[left]);
            left++;
        }

        charSet.insert(s[right]);
        maxLength = max(maxLength, right - left + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">// Longest Substring with At Most K Distinct Characters</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstringKDistinct</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; charCount;
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; s.length(); right++) {
        charCount[s[right]]++;

        <span class="hljs-keyword">while</span> (charCount.size() &gt; k) {
            charCount[s[left]]--;
            <span class="hljs-keyword">if</span> (charCount[s[left]] == <span class="hljs-number">0</span>) {
                charCount.erase(s[left]);
            }
            left++;
        }

        maxLength = max(maxLength, right - left + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">// Longest Repeating Character Replacement</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; charCount;
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>, maxCount = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; s.length(); right++) {
        charCount[s[right]]++;
        maxCount = max(maxCount, charCount[s[right]]);

        <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> - maxCount &gt; k) {
            charCount[s[left]]--;
            left++;
        }

        maxLength = max(maxLength, right - left + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">// Subarray with Given Sum</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> targetSum)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, currentSum = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; arr.size(); right++) {
        currentSum += arr[right];

        <span class="hljs-keyword">while</span> (currentSum &gt; targetSum &amp;&amp; left &lt;= right) {
            currentSum -= arr[left];
            left++;
        }

        <span class="hljs-keyword">if</span> (currentSum == targetSum) {
            <span class="hljs-keyword">return</span> {left, right};
        }
    }

    <span class="hljs-keyword">return</span> {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};
}

<span class="hljs-comment">// ===== SHRINKABLE SLIDING WINDOW =====</span>

<span class="hljs-comment">// Minimum Window Substring</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>{
    <span class="hljs-keyword">if</span> (s.length() &lt; t.length()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;

    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; targetCount;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) {
        targetCount[c]++;
    }

    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, minLength = INT_MAX, minStart = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> required = targetCount.size(), formed = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; windowCount;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; s.length(); right++) {
        <span class="hljs-keyword">char</span> c = s[right];
        windowCount[c]++;

        <span class="hljs-keyword">if</span> (targetCount.count(c) &amp;&amp; windowCount[c] == targetCount[c]) {
            formed++;
        }

        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; formed == required) {
            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; minLength) {
                minLength = right - left + <span class="hljs-number">1</span>;
                minStart = left;
            }

            <span class="hljs-keyword">char</span> leftChar = s[left];
            windowCount[leftChar]--;

            <span class="hljs-keyword">if</span> (targetCount.count(leftChar) &amp;&amp; windowCount[leftChar] &lt; targetCount[leftChar]) {
                formed--;
            }

            left++;
        }
    }

    <span class="hljs-keyword">return</span> minLength == INT_MAX ? <span class="hljs-string">""</span> : s.substr(minStart, minLength);
}

<span class="hljs-comment">// Find All Anagrams in a String</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span>{
    <span class="hljs-keyword">if</span> (s.length() &lt; p.length()) <span class="hljs-keyword">return</span> {};

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; pCount, windowCount;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : p) {
        pCount[c]++;
    }

    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; s.length(); right++) {
        windowCount[s[right]]++;

        <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; p.length()) {
            windowCount[s[left]]--;
            <span class="hljs-keyword">if</span> (windowCount[s[left]] == <span class="hljs-number">0</span>) {
                windowCount.erase(s[left]);
            }
            left++;
        }

        <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> == p.length() &amp;&amp; windowCount == pCount) {
            result.push_back(left);
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== NON-SHRINKABLE SLIDING WINDOW =====</span>

<span class="hljs-comment">// Longest Subarray with Ones after Replacement</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestOnes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, maxLength = <span class="hljs-number">0</span>, zeroCount = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; nums.size(); right++) {
        <span class="hljs-keyword">if</span> (nums[right] == <span class="hljs-number">0</span>) {
            zeroCount++;
        }

        <span class="hljs-keyword">while</span> (zeroCount &gt; k) {
            <span class="hljs-keyword">if</span> (nums[left] == <span class="hljs-number">0</span>) {
                zeroCount--;
            }
            left++;
        }

        maxLength = max(maxLength, right - left + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">// Fruits into Baskets</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; fruits)</span> </span>{
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; fruitCount;
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, maxFruits = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; fruits.size(); right++) {
        fruitCount[fruits[right]]++;

        <span class="hljs-keyword">while</span> (fruitCount.size() &gt; <span class="hljs-number">2</span>) {
            fruitCount[fruits[left]]--;
            <span class="hljs-keyword">if</span> (fruitCount[fruits[left]] == <span class="hljs-number">0</span>) {
                fruitCount.erase(fruits[left]);
            }
            left++;
        }

        maxFruits = max(maxFruits, right - left + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> maxFruits;
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;T&gt;&amp; vec, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; x : vec) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Sliding Window Technique Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Fixed Size Window</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Fixed Size Window ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr1 = {<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Max Sum (k=3): "</span> &lt;&lt; maxSumSubarray(arr1, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr2 = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
    <span class="hljs-keyword">auto</span> maxWindow = maxSlidingWindow(arr2, <span class="hljs-number">3</span>);
    printVector(maxWindow, <span class="hljs-string">"Max Sliding Window (k=3)"</span>);

    <span class="hljs-comment">// Test Variable Size Window</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Variable Size Window ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Longest Substring: "</span> &lt;&lt; lengthOfLongestSubstring(<span class="hljs-string">"abcabcbb"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Longest K Distinct: "</span> &lt;&lt; lengthOfLongestSubstringKDistinct(<span class="hljs-string">"araaci"</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Character Replacement: "</span> &lt;&lt; characterReplacement(<span class="hljs-string">"AABABBA"</span>, <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr4 = {<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>};
    <span class="hljs-keyword">auto</span> subarrayResult = subarraySum(arr4, <span class="hljs-number">9</span>);
    printVector(subarrayResult, <span class="hljs-string">"Subarray Sum (target=9)"</span>);

    <span class="hljs-comment">// Test Shrinkable Window</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Shrinkable Window ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Min Window: "</span> &lt;&lt; minWindow(<span class="hljs-string">"ADOBECODEBANC"</span>, <span class="hljs-string">"ABC"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">auto</span> anagrams = findAnagrams(<span class="hljs-string">"abab"</span>, <span class="hljs-string">"ab"</span>);
    printVector(anagrams, <span class="hljs-string">"Find Anagrams"</span>);

    <span class="hljs-comment">// Test Non-shrinkable Window</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Non-shrinkable Window ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr6 = {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Longest Ones (k=2): "</span> &lt;&lt; longestOnes(arr6, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fruits = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total Fruit: "</span> &lt;&lt; totalFruit(fruits) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity-improvements">Time Complexity Improvements:</h3>
<table>
<thead>
<tr>
<th>Problem Type</th>
<th>Brute Force</th>
<th>Sliding Window</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Fixed Size Problems</strong></td>
<td>O(n×k)</td>
<td>O(n)</td>
<td>k times faster</td>
</tr>
<tr>
<td><strong>Variable Size Problems</strong></td>
<td>O(n²) or O(n³)</td>
<td>O(n)</td>
<td>n times faster</td>
</tr>
<tr>
<td><strong>Substring Problems</strong></td>
<td>O(n²×m)</td>
<td>O(n+m)</td>
<td>Exponential improvement</td>
</tr>
<tr>
<td><strong>Subarray Sum</strong></td>
<td>O(n²)</td>
<td>O(n)</td>
<td>n times faster</td>
</tr>
</tbody>
</table>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>Fixed Size</strong>: O(1) or O(k)</li>
<li><strong>Variable Size</strong>: O(k) where k is window size</li>
<li><strong>Character Problems</strong>: O(1) for ASCII (at most 256 characters)</li>
<li><strong>Much better than generating all subarrays</strong>: O(n²) space</li>
</ul>
<h3 id="when-sliding-window-excels">When Sliding Window Excels:</h3>
<ul>
<li>✅ <strong>Contiguous elements</strong>: Problems involving subarrays/substrings</li>
<li>✅ <strong>Optimization</strong>: Finding min/max/longest/shortest</li>
<li>✅ <strong>Constraints</strong>: Problems with specific conditions</li>
<li>✅ <strong>Streaming data</strong>: Processing data sequentially</li>
</ul>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-minimum-size-subarray-sum">Problem 1: Minimum Size Subarray Sum</h3>
<p><strong>Question</strong>: Find minimum length subarray with sum ≥ target.
<strong>Example</strong>: <code>[2,3,1,2,4,3]</code>, target=7 → 2 (subarray <code>[4,3]</code>)
<strong>Hint</strong>: Use variable size window, expand until sum ≥ target, then shrink.</p>
<h3 id="problem-2-longest-substring-with-at-most-k-distinct-characters">Problem 2: Longest Substring with At Most K Distinct Characters</h3>
<p><strong>Question</strong>: Find longest substring with at most k distinct characters.
<strong>Example</strong>: <code>&quot;eceba&quot;</code>, k=2 → 3 (<code>&quot;ece&quot;</code>)
<strong>Hint</strong>: Use hash map to count characters, shrink when count &gt; k.</p>
<h3 id="problem-3-sliding-window-maximum">Problem 3: Sliding Window Maximum</h3>
<p><strong>Question</strong>: Find maximum in each window of size k.
<strong>Example</strong>: <code>[1,3,-1,-3,5,3,6,7]</code>, k=3 → <code>[3,3,5,5,6,7]</code>
<strong>Hint</strong>: Use deque to maintain decreasing order of elements.</p>
<h3 id="problem-4-count-subarrays-with-k-odd-numbers">Problem 4: Count Subarrays with K Odd Numbers</h3>
<p><strong>Question</strong>: Count subarrays with exactly k odd numbers.
<strong>Example</strong>: <code>[1,1,2,1,1]</code>, k=3 → 2
<strong>Hint</strong>: Use &quot;at most k&quot; - &quot;at most k-1&quot; technique.</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Pattern recognition</strong>: Can you identify sliding window problems?</li>
<li><strong>Window management</strong>: Do you expand/contract correctly?</li>
<li><strong>Edge case handling</strong>: Empty input, window larger than array</li>
<li><strong>Optimization</strong>: Can you achieve O(n) time complexity?</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Fixed size</strong>: &quot;Find max/min in every window of size k&quot;</li>
<li><strong>Variable size</strong>: &quot;Find longest/shortest subarray with condition&quot;</li>
<li><strong>Character counting</strong>: &quot;Find substring with specific character constraints&quot;</li>
<li><strong>Two pointers</strong>: &quot;Maintain window with left and right pointers&quot;</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Using nested loops for subarray problems</li>
<li>Not maintaining window invariants correctly</li>
<li>Forgetting to handle edge cases</li>
<li>Inefficient window expansion/contraction</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Identify the pattern</strong>: Look for &quot;subarray&quot;, &quot;substring&quot;, &quot;window&quot;, &quot;contiguous&quot;</li>
<li><strong>Choose right variant</strong>: Fixed vs variable size</li>
<li><strong>Maintain invariants</strong>: What should be true about the window?</li>
<li><strong>Handle edge cases</strong>: Empty input, k &gt; array size</li>
<li><strong>Optimize data structures</strong>: Use appropriate containers for tracking</li>
<li><strong>Practice templates</strong>: Master the basic patterns</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Sliding window optimizes subarray problems</strong> - From O(n²) to O(n)</li>
<li><strong>Four main patterns</strong> - Fixed, variable, shrinkable, non-shrinkable</li>
<li><strong>Two pointers manage window</strong> - Left and right boundaries</li>
<li><strong>Maintain window invariants</strong> - What conditions must the window satisfy?</li>
<li><strong>Choose right data structures</strong> - Hash maps, sets, deques as needed</li>
<li><strong>Master the templates</strong> - Practice until pattern recognition is automatic</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Basic Dynamic Programming and see how to solve optimization problems by breaking them into subproblems.</p>
<h1 id="chapter-13-basic-dynamic-programming---optimizing-through-subproblems">Chapter 13: Basic Dynamic Programming - Optimizing Through Subproblems</h1>
<h2 id="%F0%9F%8E%AF-what-is-dynamic-programming">🎯 What is Dynamic Programming?</h2>
<p><strong>Dynamic Programming (DP)</strong> is an algorithmic technique that solves complex problems by breaking them down into simpler subproblems and storing the results to avoid redundant calculations. It's particularly effective for optimization problems where we need to find the best solution among many possibilities.</p>
<h3 id="why-dynamic-programming-matters">Why Dynamic Programming Matters:</h3>
<ul>
<li><strong>Optimization</strong>: Reduces exponential time complexity to polynomial</li>
<li><strong>Efficiency</strong>: Avoids redundant calculations through memoization</li>
<li><strong>Versatile</strong>: Solves many types of optimization problems</li>
<li><strong>Real applications</strong>: Resource allocation, scheduling, game theory</li>
<li><strong>Interview favorite</strong>: Essential for technical interviews</li>
</ul>
<h3 id="core-principles">Core Principles:</h3>
<ol>
<li><strong>Optimal Substructure</strong>: Optimal solution contains optimal solutions to subproblems</li>
<li><strong>Overlapping Subproblems</strong>: Same subproblems are solved multiple times</li>
<li><strong>Memoization</strong>: Store results to avoid recomputation</li>
</ol>
<hr>
<h2 id="%F0%9F%93%8A-dynamic-programming-approaches">📊 Dynamic Programming Approaches</h2>
<h3 id="approach-classifications">Approach Classifications:</h3>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Description</th>
<th>Implementation</th>
<th>Use Cases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Top-Down (Memoization)</strong></td>
<td>Recursive with caching</td>
<td>Recursion + memo table</td>
<td>Natural recursive problems</td>
</tr>
<tr>
<td><strong>Bottom-Up (Tabulation)</strong></td>
<td>Iterative table filling</td>
<td>Loops + DP table</td>
<td>When iteration is clearer</td>
</tr>
<tr>
<td><strong>Space Optimized</strong></td>
<td>Reduce space complexity</td>
<td>Rolling arrays</td>
<td>When only recent states needed</td>
</tr>
</tbody>
</table>
<h3 id="when-to-use-dynamic-programming">When to Use Dynamic Programming:</h3>
<ul>
<li>✅ <strong>Optimization problems</strong>: Find min/max/count/best solution</li>
<li>✅ <strong>Overlapping subproblems</strong>: Same calculations repeated</li>
<li>✅ <strong>Optimal substructure</strong>: Optimal solution built from optimal subsolutions</li>
<li>✅ <strong>Decision problems</strong>: Make choices that affect future options</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Dynamic Programming - Comprehensive Implementation</span>

<span class="hljs-comment">// ===== CLASSIC DP PROBLEMS =====</span>

<span class="hljs-comment">/**
 * Fibonacci Sequence - Classic DP Introduction
 * Problem: Find nth Fibonacci number
 * Recurrence: F(n) = F(n-1) + F(n-2)
 */</span>

<span class="hljs-comment">// Naive Recursive (Exponential Time)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacciNaive</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;
  <span class="hljs-keyword">return</span> fibonacciNaive(n - <span class="hljs-number">1</span>) + fibonacciNaive(n - <span class="hljs-number">2</span>);
}

<span class="hljs-comment">// Top-Down DP (Memoization)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacciMemo</span>(<span class="hljs-params">n, memo = {}</span>) </span>{
  <span class="hljs-keyword">if</span> (n <span class="hljs-keyword">in</span> memo) <span class="hljs-keyword">return</span> memo[n];
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;

  memo[n] = fibonacciMemo(n - <span class="hljs-number">1</span>, memo) + fibonacciMemo(n - <span class="hljs-number">2</span>, memo);
  <span class="hljs-keyword">return</span> memo[n];
}

<span class="hljs-comment">// Bottom-Up DP (Tabulation)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacciDP</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;

  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
  dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
    dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];
  }

  <span class="hljs-keyword">return</span> dp[n];
}

<span class="hljs-comment">// Space Optimized DP</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacciOptimized</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;

  <span class="hljs-keyword">let</span> prev2 = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> prev1 = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">const</span> current = prev1 + prev2;
    prev2 = prev1;
    prev1 = current;
  }

  <span class="hljs-keyword">return</span> prev1;
}

<span class="hljs-comment">/**
 * Climbing Stairs
 * Problem: Count ways to climb n stairs (1 or 2 steps at a time)
 * Recurrence: ways(n) = ways(n-1) + ways(n-2)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;

  <span class="hljs-keyword">let</span> prev2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// ways(1)</span>
  <span class="hljs-keyword">let</span> prev1 = <span class="hljs-number">2</span>; <span class="hljs-comment">// ways(2)</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">const</span> current = prev1 + prev2;
    prev2 = prev1;
    prev1 = current;
  }

  <span class="hljs-keyword">return</span> prev1;
}

<span class="hljs-comment">/**
 * House Robber
 * Problem: Rob houses to maximize money without robbing adjacent houses
 * Recurrence: rob(i) = max(rob(i-1), rob(i-2) + nums[i])
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rob</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];

  <span class="hljs-keyword">let</span> prev2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// rob(i-2)</span>
  <span class="hljs-keyword">let</span> prev1 = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// rob(i-1)</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) {
    <span class="hljs-keyword">const</span> current = <span class="hljs-built_in">Math</span>.max(prev1, prev2 + nums[i]);
    prev2 = prev1;
    prev1 = current;
  }

  <span class="hljs-keyword">return</span> prev1;
}

<span class="hljs-comment">/**
 * Coin Change
 * Problem: Find minimum coins needed to make amount
 * Recurrence: dp[amount] = min(dp[amount - coin] + 1) for all coins
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coinChange</span>(<span class="hljs-params">coins, amount</span>) </span>{
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(amount + <span class="hljs-number">1</span>).fill(<span class="hljs-literal">Infinity</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> coin <span class="hljs-keyword">of</span> coins) {
      <span class="hljs-keyword">if</span> (coin &lt;= i) {
        dp[i] = <span class="hljs-built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);
      }
    }
  }

  <span class="hljs-keyword">return</span> dp[amount] === <span class="hljs-literal">Infinity</span> ? <span class="hljs-number">-1</span> : dp[amount];
}

<span class="hljs-comment">/**
 * Coin Change II - Count Ways
 * Problem: Count number of ways to make amount
 * Recurrence: dp[amount] = sum(dp[amount - coin]) for all coins
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">change</span>(<span class="hljs-params">amount, coins</span>) </span>{
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(amount + <span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

  <span class="hljs-comment">// Process coins one by one to avoid counting permutations</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> coin <span class="hljs-keyword">of</span> coins) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = coin; i &lt;= amount; i++) {
      dp[i] += dp[i - coin];
    }
  }

  <span class="hljs-keyword">return</span> dp[amount];
}

<span class="hljs-comment">/**
 * Longest Increasing Subsequence (LIS)
 * Problem: Find length of longest increasing subsequence
 * Recurrence: dp[i] = max(dp[j] + 1) where j &lt; i and nums[j] &lt; nums[i]
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lengthOfLIS</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">if</span> (nums.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length).fill(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {
      <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) {
        dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i], dp[j] + <span class="hljs-number">1</span>);
      }
    }
    maxLength = <span class="hljs-built_in">Math</span>.max(maxLength, dp[i]);
  }

  <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">/**
 * Maximum Subarray (Kadane's Algorithm)
 * Problem: Find maximum sum of contiguous subarray
 * Recurrence: maxEndingHere = max(nums[i], maxEndingHere + nums[i])
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">let</span> maxSoFar = nums[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">let</span> maxEndingHere = nums[<span class="hljs-number">0</span>];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) {
    maxEndingHere = <span class="hljs-built_in">Math</span>.max(nums[i], maxEndingHere + nums[i]);
    maxSoFar = <span class="hljs-built_in">Math</span>.max(maxSoFar, maxEndingHere);
  }

  <span class="hljs-keyword">return</span> maxSoFar;
}

<span class="hljs-comment">/**
 * Unique Paths
 * Problem: Count unique paths from top-left to bottom-right in grid
 * Recurrence: dp[i][j] = dp[i-1][j] + dp[i][j-1]
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniquePaths</span>(<span class="hljs-params">m, n</span>) </span>{
  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(m)
    .fill(<span class="hljs-literal">null</span>)
    .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">1</span>));

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
      dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
    }
  }

  <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
}

<span class="hljs-comment">// Space Optimized Version</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniquePathsOptimized</span>(<span class="hljs-params">m, n</span>) </span>{
  <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">1</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
      dp[j] += dp[j - <span class="hljs-number">1</span>];
    }
  }

  <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];
}

<span class="hljs-comment">/**
 * Unique Paths II (with obstacles)
 * Problem: Count unique paths with obstacles
 * Recurrence: dp[i][j] = dp[i-1][j] + dp[i][j-1] if no obstacle
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniquePathsWithObstacles</span>(<span class="hljs-params">obstacleGrid</span>) </span>{
  <span class="hljs-keyword">const</span> m = obstacleGrid.length;
  <span class="hljs-keyword">const</span> n = obstacleGrid[<span class="hljs-number">0</span>].length;

  <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(m)
    .fill(<span class="hljs-literal">null</span>)
    .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>));
  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

  <span class="hljs-comment">// Fill first row</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
    dp[<span class="hljs-number">0</span>][j] = obstacleGrid[<span class="hljs-number">0</span>][j] === <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];
  }

  <span class="hljs-comment">// Fill first column</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
    dp[i][<span class="hljs-number">0</span>] = obstacleGrid[i][<span class="hljs-number">0</span>] === <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
  }

  <span class="hljs-comment">// Fill rest of the grid</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
      <span class="hljs-keyword">if</span> (obstacleGrid[i][j] === <span class="hljs-number">1</span>) {
        dp[i][j] = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
      }
    }
  }

  <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
}

<span class="hljs-comment">/**
 * Minimum Path Sum
 * Problem: Find minimum sum path from top-left to bottom-right
 * Recurrence: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minPathSum</span>(<span class="hljs-params">grid</span>) </span>{
  <span class="hljs-keyword">const</span> m = grid.length;
  <span class="hljs-keyword">const</span> n = grid[<span class="hljs-number">0</span>].length;

  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(m)
    .fill(<span class="hljs-literal">null</span>)
    .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>));
  dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];

  <span class="hljs-comment">// Fill first row</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
    dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];
  }

  <span class="hljs-comment">// Fill first column</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
    dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];
  }

  <span class="hljs-comment">// Fill rest of the grid</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
      dp[i][j] = grid[i][j] + <span class="hljs-built_in">Math</span>.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);
    }
  }

  <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
}

<span class="hljs-comment">// ===== STRING DP PROBLEMS =====</span>

<span class="hljs-comment">/**
 * Longest Common Subsequence (LCS)
 * Problem: Find length of longest common subsequence
 * Recurrence: dp[i][j] = dp[i-1][j-1] + 1 if chars match, else max(dp[i-1][j], dp[i][j-1])
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">text1, text2</span>) </span>{
  <span class="hljs-keyword">const</span> m = text1.length;
  <span class="hljs-keyword">const</span> n = text2.length;

  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(m + <span class="hljs-number">1</span>)
    .fill(<span class="hljs-literal">null</span>)
    .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>));

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
      <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] === text2[j - <span class="hljs-number">1</span>]) {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        dp[i][j] = <span class="hljs-built_in">Math</span>.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);
      }
    }
  }

  <span class="hljs-keyword">return</span> dp[m][n];
}

<span class="hljs-comment">/**
 * Edit Distance (Levenshtein Distance)
 * Problem: Minimum operations to convert word1 to word2
 * Operations: insert, delete, replace
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minDistance</span>(<span class="hljs-params">word1, word2</span>) </span>{
  <span class="hljs-keyword">const</span> m = word1.length;
  <span class="hljs-keyword">const</span> n = word2.length;

  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(m + <span class="hljs-number">1</span>)
    .fill(<span class="hljs-literal">null</span>)
    .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>));

  <span class="hljs-comment">// Base cases</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) dp[i][<span class="hljs-number">0</span>] = i; <span class="hljs-comment">// Delete all</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) dp[<span class="hljs-number">0</span>][j] = j; <span class="hljs-comment">// Insert all</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
      <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] === word2[j - <span class="hljs-number">1</span>]) {
        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// No operation needed</span>
      } <span class="hljs-keyword">else</span> {
        dp[i][j] =
          <span class="hljs-number">1</span> +
          <span class="hljs-built_in">Math</span>.min(
            dp[i - <span class="hljs-number">1</span>][j], <span class="hljs-comment">// Delete</span>
            dp[i][j - <span class="hljs-number">1</span>], <span class="hljs-comment">// Insert</span>
            dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] <span class="hljs-comment">// Replace</span>
          );
      }
    }
  }

  <span class="hljs-keyword">return</span> dp[m][n];
}

<span class="hljs-comment">/**
 * Palindromic Substrings
 * Problem: Count number of palindromic substrings
 * Approach: Expand around centers
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countSubstrings</span>(<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expandAroundCenter</span>(<span class="hljs-params">left, right</span>) </span>{
    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) {
      count++;
      left--;
      right++;
    }
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) {
    expandAroundCenter(i, i); <span class="hljs-comment">// Odd length palindromes</span>
    expandAroundCenter(i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// Even length palindromes</span>
  }

  <span class="hljs-keyword">return</span> count;
}

<span class="hljs-comment">/**
 * Longest Palindromic Substring
 * Problem: Find longest palindromic substring
 * Approach: DP table or expand around centers
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longestPalindrome</span>(<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">if</span> (s.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;

  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expandAroundCenter</span>(<span class="hljs-params">left, right</span>) </span>{
    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) {
      <span class="hljs-keyword">const</span> currentLength = right - left + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">if</span> (currentLength &gt; maxLength) {
        start = left;
        maxLength = currentLength;
      }
      left--;
      right++;
    }
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) {
    expandAroundCenter(i, i); <span class="hljs-comment">// Odd length</span>
    expandAroundCenter(i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// Even length</span>
  }

  <span class="hljs-keyword">return</span> s.substring(start, start + maxLength);
}

<span class="hljs-comment">// ===== KNAPSACK PROBLEMS =====</span>

<span class="hljs-comment">/**
 * 0/1 Knapsack
 * Problem: Maximum value with weight constraint
 * Recurrence: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">knapsack</span>(<span class="hljs-params">weights, values, capacity</span>) </span>{
  <span class="hljs-keyword">const</span> n = weights.length;
  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>)
    .fill(<span class="hljs-literal">null</span>)
    .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(capacity + <span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>));

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> w = <span class="hljs-number">1</span>; w &lt;= capacity; w++) {
      <span class="hljs-keyword">if</span> (weights[i - <span class="hljs-number">1</span>] &lt;= w) {
        dp[i][w] = <span class="hljs-built_in">Math</span>.max(
          dp[i - <span class="hljs-number">1</span>][w], <span class="hljs-comment">// Don't take item</span>
          dp[i - <span class="hljs-number">1</span>][w - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>] <span class="hljs-comment">// Take item</span>
        );
      } <span class="hljs-keyword">else</span> {
        dp[i][w] = dp[i - <span class="hljs-number">1</span>][w]; <span class="hljs-comment">// Can't take item</span>
      }
    }
  }

  <span class="hljs-keyword">return</span> dp[n][capacity];
}

<span class="hljs-comment">// Space Optimized Knapsack</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">knapsackOptimized</span>(<span class="hljs-params">weights, values, capacity</span>) </span>{
  <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(capacity + <span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; weights.length; i++) {
    <span class="hljs-comment">// Traverse backwards to avoid using updated values</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> w = capacity; w &gt;= weights[i]; w--) {
      dp[w] = <span class="hljs-built_in">Math</span>.max(dp[w], dp[w - weights[i]] + values[i]);
    }
  }

  <span class="hljs-keyword">return</span> dp[capacity];
}

<span class="hljs-comment">/**
 * Partition Equal Subset Sum
 * Problem: Check if array can be partitioned into two equal sum subsets
 * Approach: Knapsack variant - find subset with sum = total/2
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canPartition</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">const</span> sum = nums.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">const</span> target = sum / <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(target + <span class="hljs-number">1</span>).fill(<span class="hljs-literal">false</span>);
  dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = target; j &gt;= num; j--) {
      dp[j] = dp[j] || dp[j - num];
    }
  }

  <span class="hljs-keyword">return</span> dp[target];
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-comment">/**
 * Generic DP Template with Memoization
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dpWithMemo</span>(<span class="hljs-params">problem, ...args</span>) </span>{
  <span class="hljs-keyword">const</span> memo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solve</span>(<span class="hljs-params">...params</span>) </span>{
    <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">JSON</span>.stringify(params);
    <span class="hljs-keyword">if</span> (memo.has(key)) <span class="hljs-keyword">return</span> memo.get(key);

    <span class="hljs-keyword">const</span> result = problem(...params, solve);
    memo.set(key, result);
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">return</span> solve(...args);
}

<span class="hljs-comment">/**
 * Performance Comparison
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performanceComparison</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== DP Performance Comparison ==="</span>);

  <span class="hljs-keyword">const</span> n = <span class="hljs-number">35</span>;

  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Fibonacci Naive"</span>);
  <span class="hljs-comment">// fibonacciNaive(n); // Too slow for large n</span>
  <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Fibonacci Naive"</span>);

  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Fibonacci Memoization"</span>);
  fibonacciMemo(n);
  <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Fibonacci Memoization"</span>);

  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Fibonacci DP"</span>);
  fibonacciDP(n);
  <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Fibonacci DP"</span>);

  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Fibonacci Optimized"</span>);
  fibonacciOptimized(n);
  <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Fibonacci Optimized"</span>);
}

<span class="hljs-comment">/**
 * DP Problem Classifier
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">classifyDPProblem</span>(<span class="hljs-params">description</span>) </span>{
  <span class="hljs-keyword">const</span> patterns = {
    <span class="hljs-attr">sequence</span>: [<span class="hljs-string">"fibonacci"</span>, <span class="hljs-string">"climbing"</span>, <span class="hljs-string">"house robber"</span>],
    <span class="hljs-attr">grid</span>: [<span class="hljs-string">"unique paths"</span>, <span class="hljs-string">"minimum path"</span>, <span class="hljs-string">"dungeon"</span>],
    <span class="hljs-attr">string</span>: [<span class="hljs-string">"edit distance"</span>, <span class="hljs-string">"lcs"</span>, <span class="hljs-string">"palindrome"</span>],
    <span class="hljs-attr">knapsack</span>: [<span class="hljs-string">"subset sum"</span>, <span class="hljs-string">"coin change"</span>, <span class="hljs-string">"partition"</span>],
    <span class="hljs-attr">interval</span>: [<span class="hljs-string">"matrix chain"</span>, <span class="hljs-string">"burst balloons"</span>],
    <span class="hljs-attr">tree</span>: [<span class="hljs-string">"binary tree"</span>, <span class="hljs-string">"diameter"</span>, <span class="hljs-string">"path sum"</span>],
  };

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [category, keywords] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(patterns)) {
    <span class="hljs-keyword">if</span> (
      keywords.some(<span class="hljs-function">(<span class="hljs-params">keyword</span>) =&gt;</span> description.toLowerCase().includes(keyword))
    ) {
      <span class="hljs-keyword">return</span> category;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">"unknown"</span>;
}

<span class="hljs-comment">// ===== EXAMPLE USAGE AND TESTING =====</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Dynamic Programming Demo ==="</span>);

<span class="hljs-comment">// Test Classic Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Classic DP Problems ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Fibonacci(10):"</span>, fibonacciDP(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 55</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Climb Stairs(5):"</span>, climbStairs(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 8</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"House Robber([2,7,9,3,1]):"</span>, rob([<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])); <span class="hljs-comment">// 12</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Coin Change([1,3,4], 6):"</span>, coinChange([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">6</span>)); <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Coin Change Ways([1,2,5], 5):"</span>, change(<span class="hljs-number">5</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>])); <span class="hljs-comment">// 4</span>
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"LIS([10,9,2,5,3,7,101,18]):"</span>,
  lengthOfLIS([<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">101</span>, <span class="hljs-number">18</span>])
); <span class="hljs-comment">// 4</span>
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Max Subarray([-2,1,-3,4,-1,2,1,-5,4]):"</span>,
  maxSubArray([<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">4</span>])
); <span class="hljs-comment">// 6</span>

<span class="hljs-comment">// Test Grid Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Grid DP Problems ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Unique Paths(3,7):"</span>, uniquePaths(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)); <span class="hljs-comment">// 28</span>
<span class="hljs-keyword">const</span> obstacleGrid = [
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
];
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Unique Paths with Obstacles:"</span>,
  uniquePathsWithObstacles(obstacleGrid)
); <span class="hljs-comment">// 2</span>
<span class="hljs-keyword">const</span> grid = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>],
  [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],
];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Min Path Sum:"</span>, minPathSum(grid)); <span class="hljs-comment">// 7</span>

<span class="hljs-comment">// Test String Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== String DP Problems ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'LCS("abcde", "ace"):'</span>, longestCommonSubsequence(<span class="hljs-string">"abcde"</span>, <span class="hljs-string">"ace"</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Edit Distance("horse", "ros"):'</span>, minDistance(<span class="hljs-string">"horse"</span>, <span class="hljs-string">"ros"</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Palindromic Substrings("abc"):'</span>, countSubstrings(<span class="hljs-string">"abc"</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Longest Palindrome("babad"):'</span>, longestPalindrome(<span class="hljs-string">"babad"</span>)); <span class="hljs-comment">// "bab" or "aba"</span>

<span class="hljs-comment">// Test Knapsack Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Knapsack DP Problems ==="</span>);
<span class="hljs-keyword">const</span> weights = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Knapsack(capacity=7):"</span>, knapsack(weights, values, <span class="hljs-number">7</span>)); <span class="hljs-comment">// 9</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Can Partition([1,5,11,5]):"</span>, canPartition([<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>])); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Performance comparison</span>
performanceComparison();

<span class="hljs-comment">// Problem classification</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Problem Classification ==="</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Find fibonacci number":'</span>,
  classifyDPProblem(<span class="hljs-string">"Find fibonacci number"</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Count unique paths in grid":'</span>,
  classifyDPProblem(<span class="hljs-string">"Count unique paths in grid"</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Edit distance between strings":'</span>,
  classifyDPProblem(<span class="hljs-string">"Edit distance between strings"</span>)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'"Subset sum problem":'</span>, classifyDPProblem(<span class="hljs-string">"Subset sum problem"</span>));

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== DP Strategy Guide ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"1. Identify optimal substructure"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"2. Find overlapping subproblems"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"3. Define recurrence relation"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"4. Choose memoization vs tabulation"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"5. Optimize space if possible"</span>);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// ===== CLASSIC DP PROBLEMS =====</span>

<span class="hljs-comment">// Fibonacci with Memoization</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibonacciMemo</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; memo;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (memo.find(n) != memo.end()) {
            <span class="hljs-keyword">return</span> memo[n];
        }

        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> memo[n] = n;
        }

        <span class="hljs-keyword">return</span> memo[n] = fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);
    }
};

<span class="hljs-comment">// Fibonacci Bottom-Up</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fibonacciDP</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];
    }

    <span class="hljs-keyword">return</span> dp[n];
}

<span class="hljs-comment">// Climbing Stairs</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;

    <span class="hljs-keyword">int</span> prev2 = <span class="hljs-number">1</span>, prev1 = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">int</span> current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }

    <span class="hljs-keyword">return</span> prev1;
}

<span class="hljs-comment">// House Robber</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">if</span> (nums.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (nums.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">int</span> prev2 = <span class="hljs-number">0</span>, prev1 = nums[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++) {
        <span class="hljs-keyword">int</span> current = max(prev1, prev2 + nums[i]);
        prev2 = prev1;
        prev1 = current;
    }

    <span class="hljs-keyword">return</span> prev1;
}

<span class="hljs-comment">// Coin Change</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) {
            <span class="hljs-keyword">if</span> (coin &lt;= i &amp;&amp; dp[i - coin] != INT_MAX) {
                dp[i] = min(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);
            }
        }
    }

    <span class="hljs-keyword">return</span> dp[amount] == INT_MAX ? <span class="hljs-number">-1</span> : dp[amount];
}

<span class="hljs-comment">// Longest Increasing Subsequence</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">if</span> (nums.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;
    <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {
            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) {
                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>);
            }
        }
        maxLength = max(maxLength, dp[i]);
    }

    <span class="hljs-keyword">return</span> maxLength;
}

<span class="hljs-comment">// Maximum Subarray (Kadane's Algorithm)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">int</span> maxSoFar = nums[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">int</span> maxEndingHere = nums[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.size(); i++) {
        maxEndingHere = max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = max(maxSoFar, maxEndingHere);
    }

    <span class="hljs-keyword">return</span> maxSoFar;
}

<span class="hljs-comment">// ===== GRID DP PROBLEMS =====</span>

<span class="hljs-comment">// Unique Paths</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">1</span>))</span></span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
        }
    }

    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
}

<span class="hljs-comment">// Minimum Path Sum</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{
    <span class="hljs-keyword">int</span> m = grid.size(), n = grid[<span class="hljs-number">0</span>].size();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n))</span></span>;

    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];

    <span class="hljs-comment">// Fill first row</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];
    }

    <span class="hljs-comment">// Fill first column</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];
    }

    <span class="hljs-comment">// Fill rest of grid</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
            dp[i][j] = grid[i][j] + min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);
        }
    }

    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
}

<span class="hljs-comment">// ===== STRING DP PROBLEMS =====</span>

<span class="hljs-comment">// Longest Common Subsequence</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(<span class="hljs-built_in">string</span> text1, <span class="hljs-built_in">string</span> text2)</span> </span>{
    <span class="hljs-keyword">int</span> m = text1.length(), n = text2.length();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
            <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) {
                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);
            }
        }
    }

    <span class="hljs-keyword">return</span> dp[m][n];
}

<span class="hljs-comment">// Edit Distance</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word1, <span class="hljs-built_in">string</span> word2)</span> </span>{
    <span class="hljs-keyword">int</span> m = word1.length(), n = word2.length();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>))</span></span>;

    <span class="hljs-comment">// Base cases</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) dp[i][<span class="hljs-number">0</span>] = i;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) dp[<span class="hljs-number">0</span>][j] = j;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
            <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) {
                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
            } <span class="hljs-keyword">else</span> {
                dp[i][j] = <span class="hljs-number">1</span> + min({dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]});
            }
        }
    }

    <span class="hljs-keyword">return</span> dp[m][n];
}

<span class="hljs-comment">// ===== KNAPSACK PROBLEMS =====</span>

<span class="hljs-comment">// 0/1 Knapsack</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; weights, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; values, <span class="hljs-keyword">int</span> capacity)</span> </span>{
    <span class="hljs-keyword">int</span> n = weights.size();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(capacity + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w = <span class="hljs-number">1</span>; w &lt;= capacity; w++) {
            <span class="hljs-keyword">if</span> (weights[i - <span class="hljs-number">1</span>] &lt;= w) {
                dp[i][w] = max(dp[i - <span class="hljs-number">1</span>][w],
                              dp[i - <span class="hljs-number">1</span>][w - weights[i - <span class="hljs-number">1</span>]] + values[i - <span class="hljs-number">1</span>]);
            } <span class="hljs-keyword">else</span> {
                dp[i][w] = dp[i - <span class="hljs-number">1</span>][w];
            }
        }
    }

    <span class="hljs-keyword">return</span> dp[n][capacity];
}

<span class="hljs-comment">// Partition Equal Subset Sum</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) sum += num;

    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;
    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;= num; j--) {
            dp[j] = dp[j] || dp[j - num];
        }
    }

    <span class="hljs-keyword">return</span> dp[target];
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;T&gt;&amp; vec, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; x : vec) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; row : matrix) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : row) {
            <span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Dynamic Programming Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Classic Problems</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Classic DP Problems ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Fibonacci(10): "</span> &lt;&lt; fibonacciDP(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Climb Stairs(5): "</span> &lt;&lt; climbStairs(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; houses = {<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"House Robber: "</span> &lt;&lt; rob(houses) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; coins = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Coin Change(6): "</span> &lt;&lt; coinChange(coins, <span class="hljs-number">6</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">101</span>, <span class="hljs-number">18</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"LIS: "</span> &lt;&lt; lengthOfLIS(nums) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; subarray = {<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">4</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Max Subarray: "</span> &lt;&lt; maxSubArray(subarray) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Grid Problems</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Grid DP Problems ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Unique Paths(3,7): "</span> &lt;&lt; uniquePaths(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; grid = {{<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>}};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Min Path Sum: "</span> &lt;&lt; minPathSum(grid) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test String Problems</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== String DP Problems ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"LCS('abcde', 'ace'): "</span> &lt;&lt; longestCommonSubsequence(<span class="hljs-string">"abcde"</span>, <span class="hljs-string">"ace"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Edit Distance('horse', 'ros'): "</span> &lt;&lt; minDistance(<span class="hljs-string">"horse"</span>, <span class="hljs-string">"ros"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Knapsack Problems</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Knapsack DP Problems ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weights = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; values = {<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Knapsack(capacity=7): "</span> &lt;&lt; knapsack(weights, values, <span class="hljs-number">7</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; partition = {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Can Partition: "</span> &lt;&lt; (canPartition(partition) ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity-improvements">Time Complexity Improvements:</h3>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Naive Approach</th>
<th>DP Approach</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Fibonacci</strong></td>
<td>O(2ⁿ)</td>
<td>O(n)</td>
<td>Exponential to linear</td>
</tr>
<tr>
<td><strong>Coin Change</strong></td>
<td>O(amount^coins)</td>
<td>O(amount × coins)</td>
<td>Exponential to polynomial</td>
</tr>
<tr>
<td><strong>LCS</strong></td>
<td>O(2^(m+n))</td>
<td>O(m × n)</td>
<td>Exponential to polynomial</td>
</tr>
<tr>
<td><strong>Knapsack</strong></td>
<td>O(2ⁿ)</td>
<td>O(n × capacity)</td>
<td>Exponential to polynomial</td>
</tr>
<tr>
<td><strong>Edit Distance</strong></td>
<td>O(3^max(m,n))</td>
<td>O(m × n)</td>
<td>Exponential to polynomial</td>
</tr>
</tbody>
</table>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>2D DP</strong>: O(m × n) - can often be optimized to O(min(m, n))</li>
<li><strong>1D DP</strong>: O(n) - can often be optimized to O(1)</li>
<li><strong>Memoization</strong>: O(recursion depth + memo size)</li>
</ul>
<h3 id="when-dp-excels">When DP Excels:</h3>
<ul>
<li>✅ <strong>Optimization problems</strong>: Min/max/count solutions</li>
<li>✅ <strong>Overlapping subproblems</strong>: Same calculations repeated</li>
<li>✅ <strong>Optimal substructure</strong>: Optimal solution contains optimal subsolutions</li>
<li>✅ <strong>Decision problems</strong>: Choices affect future options</li>
</ul>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-triangle-minimum-path-sum">Problem 1: Triangle Minimum Path Sum</h3>
<p><strong>Question</strong>: Find minimum path sum from top to bottom of triangle.
<strong>Example</strong>: <code>[[2],[3,4],[6,5,7],[4,1,8,3]]</code> → 11 (path: 2+3+5+1)
<strong>Hint</strong>: Bottom-up DP, dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])</p>
<h3 id="problem-2-word-break">Problem 2: Word Break</h3>
<p><strong>Question</strong>: Check if string can be segmented into dictionary words.
<strong>Example</strong>: <code>&quot;leetcode&quot;</code>, dict=[&quot;leet&quot;,&quot;code&quot;] → true
<strong>Hint</strong>: dp[i] = true if substring(0,i) can be segmented</p>
<h3 id="problem-3-decode-ways">Problem 3: Decode Ways</h3>
<p><strong>Question</strong>: Count ways to decode numeric string to letters (A=1, B=2, ..., Z=26).
<strong>Example</strong>: <code>&quot;226&quot;</code> → 3 (&quot;BZ&quot;, &quot;VF&quot;, &quot;BBF&quot;)
<strong>Hint</strong>: dp[i] = dp[i-1] + dp[i-2] (if valid single/double digit)</p>
<h3 id="problem-4-maximum-product-subarray">Problem 4: Maximum Product Subarray</h3>
<p><strong>Question</strong>: Find contiguous subarray with maximum product.
<strong>Example</strong>: <code>[2,3,-2,4]</code> → 6 (subarray [2,3])
<strong>Hint</strong>: Track both max and min products (negative × negative = positive)</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Problem recognition</strong>: Can you identify DP problems?</li>
<li><strong>Recurrence relation</strong>: Can you define the recursive structure?</li>
<li><strong>Base cases</strong>: Do you handle edge cases correctly?</li>
<li><strong>Optimization</strong>: Can you optimize space complexity?</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>1D DP</strong>: Fibonacci-like problems, house robber, climbing stairs</li>
<li><strong>2D DP</strong>: Grid problems, string matching, knapsack</li>
<li><strong>State machines</strong>: Problems with different states/modes</li>
<li><strong>Interval DP</strong>: Problems involving ranges or intervals</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Not identifying optimal substructure</li>
<li>Incorrect recurrence relation</li>
<li>Missing base cases</li>
<li>Not considering space optimization</li>
<li>Confusing top-down vs bottom-up</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Start with recursion</strong>: Write naive recursive solution first</li>
<li><strong>Identify overlapping subproblems</strong>: Look for repeated calculations</li>
<li><strong>Define state clearly</strong>: What parameters uniquely identify a subproblem?</li>
<li><strong>Choose approach</strong>: Memoization (top-down) vs tabulation (bottom-up)</li>
<li><strong>Optimize space</strong>: Can you reduce dimensions?</li>
<li><strong>Practice patterns</strong>: Master common DP patterns</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>DP optimizes overlapping subproblems</strong> - Avoid redundant calculations</li>
<li><strong>Two main approaches</strong> - Top-down (memoization) vs bottom-up (tabulation)</li>
<li><strong>Optimal substructure required</strong> - Optimal solution contains optimal subsolutions</li>
<li><strong>State definition is crucial</strong> - What parameters define a subproblem?</li>
<li><strong>Space optimization often possible</strong> - Reduce dimensions when only recent states needed</li>
<li><strong>Practice pattern recognition</strong> - Learn to identify DP problems quickly</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Backtracking and see how to systematically explore solution spaces by making and undoing choices.</p>
<h1 id="chapter-14-backtracking---systematic-solution-space-exploration">Chapter 14: Backtracking - Systematic Solution Space Exploration</h1>
<h2 id="%F0%9F%8E%AF-what-is-backtracking">🎯 What is Backtracking?</h2>
<p><strong>Backtracking</strong> is an algorithmic technique that systematically explores all possible solutions to a problem by making choices, exploring their consequences, and undoing (backtracking) when a choice leads to a dead end. It's essentially a refined brute force approach that prunes invalid paths early.</p>
<h3 id="why-backtracking-matters">Why Backtracking Matters:</h3>
<ul>
<li><strong>Systematic exploration</strong>: Explores all possible solutions methodically</li>
<li><strong>Early pruning</strong>: Eliminates invalid paths to improve efficiency</li>
<li><strong>Constraint satisfaction</strong>: Solves problems with multiple constraints</li>
<li><strong>Combinatorial problems</strong>: Generates permutations, combinations, subsets</li>
<li><strong>Game solving</strong>: Chess, Sudoku, N-Queens, maze solving</li>
<li><strong>Interview favorite</strong>: Tests problem-solving and recursion skills</li>
</ul>
<h3 id="core-principles">Core Principles:</h3>
<ol>
<li><strong>Choose</strong>: Make a choice from available options</li>
<li><strong>Explore</strong>: Recursively explore the consequences</li>
<li><strong>Unchoose</strong>: Backtrack if the path doesn't lead to a solution</li>
</ol>
<hr>
<h2 id="%F0%9F%93%8A-backtracking-framework">📊 Backtracking Framework</h2>
<h3 id="general-template">General Template:</h3>
<pre class="hljs"><code><div>function backtrack(state, choices):
    if (isComplete(state)):
        processResult(state)
        return

    for choice in choices:
        if (isValid(choice, state)):
            makeChoice(choice, state)
            backtrack(state, getNextChoices(state))
            undoChoice(choice, state)  // Backtrack
</div></code></pre>
<h3 id="problem-classifications">Problem Classifications:</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
<th>Examples</th>
<th>Characteristics</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Decision Problems</strong></td>
<td>Find if solution exists</td>
<td>N-Queens, Sudoku</td>
<td>Boolean result</td>
</tr>
<tr>
<td><strong>Optimization Problems</strong></td>
<td>Find best solution</td>
<td>Traveling Salesman</td>
<td>Compare solutions</td>
</tr>
<tr>
<td><strong>Enumeration Problems</strong></td>
<td>Find all solutions</td>
<td>All permutations</td>
<td>Generate all results</td>
</tr>
<tr>
<td><strong>Construction Problems</strong></td>
<td>Build valid solution</td>
<td>Generate parentheses</td>
<td>Construct step by step</td>
</tr>
</tbody>
</table>
<h3 id="when-to-use-backtracking">When to Use Backtracking:</h3>
<ul>
<li>✅ <strong>Constraint satisfaction</strong>: Multiple rules to satisfy</li>
<li>✅ <strong>Combinatorial enumeration</strong>: Generate all possibilities</li>
<li>✅ <strong>Puzzle solving</strong>: Sudoku, crosswords, mazes</li>
<li>✅ <strong>Game tree search</strong>: Chess, tic-tac-toe</li>
<li>✅ <strong>Path finding</strong>: With constraints or obstacles</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Backtracking - Comprehensive Implementation</span>

<span class="hljs-comment">// ===== CLASSIC BACKTRACKING PROBLEMS =====</span>

<span class="hljs-comment">/**
 * N-Queens Problem
 * Problem: Place N queens on NxN chessboard so none attack each other
 * Constraints: No two queens in same row, column, or diagonal
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solveNQueens</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> board = <span class="hljs-built_in">Array</span>(n)
    .fill(<span class="hljs-literal">null</span>)
    .map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-string">"."</span>));

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">row, col</span>) </span>{
    <span class="hljs-comment">// Check column</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) {
      <span class="hljs-keyword">if</span> (board[i][col] === <span class="hljs-string">"Q"</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Check diagonal (top-left to bottom-right)</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) {
      <span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-string">"Q"</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Check diagonal (top-right to bottom-left)</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) {
      <span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-string">"Q"</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">row</span>) </span>{
    <span class="hljs-comment">// Base case: all queens placed</span>
    <span class="hljs-keyword">if</span> (row === n) {
      result.push(board.map(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> row.join(<span class="hljs-string">""</span>)));
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Try placing queen in each column of current row</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) {
      <span class="hljs-keyword">if</span> (isValid(row, col)) {
        board[row][col] = <span class="hljs-string">"Q"</span>; <span class="hljs-comment">// Choose</span>
        backtrack(row + <span class="hljs-number">1</span>); <span class="hljs-comment">// Explore</span>
        board[row][col] = <span class="hljs-string">"."</span>; <span class="hljs-comment">// Unchoose</span>
      }
    }
  }

  backtrack(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Generate Parentheses
 * Problem: Generate all valid combinations of n pairs of parentheses
 * Constraints: Balanced parentheses
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateParenthesis</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">current, open, close</span>) </span>{
    <span class="hljs-comment">// Base case: used all parentheses</span>
    <span class="hljs-keyword">if</span> (current.length === <span class="hljs-number">2</span> * n) {
      result.push(current);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Add opening parenthesis if we haven't used all</span>
    <span class="hljs-keyword">if</span> (open &lt; n) {
      backtrack(current + <span class="hljs-string">"("</span>, open + <span class="hljs-number">1</span>, close);
    }

    <span class="hljs-comment">// Add closing parenthesis if it won't make string invalid</span>
    <span class="hljs-keyword">if</span> (close &lt; open) {
      backtrack(current + <span class="hljs-string">")"</span>, open, close + <span class="hljs-number">1</span>);
    }
  }

  backtrack(<span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Permutations
 * Problem: Generate all permutations of given array
 * Approach: Choose element, recurse on remaining, backtrack
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permute</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> current = [];
  <span class="hljs-keyword">const</span> used = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length).fill(<span class="hljs-literal">false</span>);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Base case: permutation complete</span>
    <span class="hljs-keyword">if</span> (current.length === nums.length) {
      result.push([...current]); <span class="hljs-comment">// Copy array</span>
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Try each unused number</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
      <span class="hljs-keyword">if</span> (!used[i]) {
        current.push(nums[i]); <span class="hljs-comment">// Choose</span>
        used[i] = <span class="hljs-literal">true</span>;
        backtrack(); <span class="hljs-comment">// Explore</span>
        current.pop(); <span class="hljs-comment">// Unchoose</span>
        used[i] = <span class="hljs-literal">false</span>;
      }
    }
  }

  backtrack();
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Permutations II (with duplicates)
 * Problem: Generate unique permutations from array with duplicates
 * Approach: Sort array and skip duplicates intelligently
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permuteUnique</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> current = [];
  <span class="hljs-keyword">const</span> used = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length).fill(<span class="hljs-literal">false</span>);

  nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">// Sort to group duplicates</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (current.length === nums.length) {
      result.push([...current]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
      <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;

      <span class="hljs-comment">// Skip duplicates: if current element equals previous</span>
      <span class="hljs-comment">// and previous is not used, skip current</span>
      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">continue</span>;
      }

      current.push(nums[i]);
      used[i] = <span class="hljs-literal">true</span>;
      backtrack();
      current.pop();
      used[i] = <span class="hljs-literal">false</span>;
    }
  }

  backtrack();
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Combinations
 * Problem: Generate all combinations of k numbers from 1 to n
 * Approach: Choose number, recurse with remaining choices
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combine</span>(<span class="hljs-params">n, k</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> current = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">start</span>) </span>{
    <span class="hljs-comment">// Base case: combination complete</span>
    <span class="hljs-keyword">if</span> (current.length === k) {
      result.push([...current]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Try numbers from start to n</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= n; i++) {
      current.push(i); <span class="hljs-comment">// Choose</span>
      backtrack(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// Explore (i+1 to avoid duplicates)</span>
      current.pop(); <span class="hljs-comment">// Unchoose</span>
    }
  }

  backtrack(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Combination Sum
 * Problem: Find all combinations that sum to target
 * Approach: Choose number, subtract from target, recurse
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combinationSum</span>(<span class="hljs-params">candidates, target</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> current = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">start, remaining</span>) </span>{
    <span class="hljs-comment">// Base case: found valid combination</span>
    <span class="hljs-keyword">if</span> (remaining === <span class="hljs-number">0</span>) {
      result.push([...current]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Base case: exceeded target</span>
    <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Try each candidate from start index</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; candidates.length; i++) {
      current.push(candidates[i]);
      <span class="hljs-comment">// Can reuse same number, so pass i (not i+1)</span>
      backtrack(i, remaining - candidates[i]);
      current.pop();
    }
  }

  backtrack(<span class="hljs-number">0</span>, target);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Combination Sum II (no duplicates)
 * Problem: Find combinations that sum to target, each number used once
 * Approach: Sort array, skip duplicates at same level
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combinationSum2</span>(<span class="hljs-params">candidates, target</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> current = [];

  candidates.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">start, remaining</span>) </span>{
    <span class="hljs-keyword">if</span> (remaining === <span class="hljs-number">0</span>) {
      result.push([...current]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; candidates.length; i++) {
      <span class="hljs-comment">// Skip duplicates at same recursion level</span>
      <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] === candidates[i - <span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (candidates[i] &gt; remaining) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Optimization</span>

      current.push(candidates[i]);
      backtrack(i + <span class="hljs-number">1</span>, remaining - candidates[i]); <span class="hljs-comment">// i+1: use each number once</span>
      current.pop();
    }
  }

  backtrack(<span class="hljs-number">0</span>, target);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Subsets
 * Problem: Generate all possible subsets (power set)
 * Approach: For each element, choose to include or exclude
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subsets</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> current = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">start</span>) </span>{
    <span class="hljs-comment">// Add current subset to result</span>
    result.push([...current]);

    <span class="hljs-comment">// Try adding each remaining number</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; nums.length; i++) {
      current.push(nums[i]); <span class="hljs-comment">// Choose</span>
      backtrack(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// Explore</span>
      current.pop(); <span class="hljs-comment">// Unchoose</span>
    }
  }

  backtrack(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Subsets II (with duplicates)
 * Problem: Generate unique subsets from array with duplicates
 * Approach: Sort and skip duplicates at same level
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subsetsWithDup</span>(<span class="hljs-params">nums</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> current = [];

  nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">start</span>) </span>{
    result.push([...current]);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; nums.length; i++) {
      <span class="hljs-comment">// Skip duplicates at same level</span>
      <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) {
        <span class="hljs-keyword">continue</span>;
      }

      current.push(nums[i]);
      backtrack(i + <span class="hljs-number">1</span>);
      current.pop();
    }
  }

  backtrack(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Palindrome Partitioning
 * Problem: Partition string into palindromic substrings
 * Approach: Try all possible cuts, check if substring is palindrome
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> current = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPalindrome</span>(<span class="hljs-params">str, start, end</span>) </span>{
    <span class="hljs-keyword">while</span> (start &lt; end) {
      <span class="hljs-keyword">if</span> (str[start] !== str[end]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      start++;
      end--;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">start</span>) </span>{
    <span class="hljs-comment">// Base case: processed entire string</span>
    <span class="hljs-keyword">if</span> (start === s.length) {
      result.push([...current]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Try all possible end positions</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> end = start; end &lt; s.length; end++) {
      <span class="hljs-keyword">if</span> (isPalindrome(s, start, end)) {
        current.push(s.substring(start, end + <span class="hljs-number">1</span>)); <span class="hljs-comment">// Choose</span>
        backtrack(end + <span class="hljs-number">1</span>); <span class="hljs-comment">// Explore</span>
        current.pop(); <span class="hljs-comment">// Unchoose</span>
      }
    }
  }

  backtrack(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Word Search
 * Problem: Find if word exists in 2D board
 * Approach: DFS with backtracking, mark visited cells
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exist</span>(<span class="hljs-params">board, word</span>) </span>{
  <span class="hljs-keyword">const</span> rows = board.length;
  <span class="hljs-keyword">const</span> cols = board[<span class="hljs-number">0</span>].length;
  <span class="hljs-keyword">const</span> directions = [
    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
    [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>],
    [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>],
  ];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">row, col, index</span>) </span>{
    <span class="hljs-comment">// Base case: found complete word</span>
    <span class="hljs-keyword">if</span> (index === word.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-comment">// Check bounds and character match</span>
    <span class="hljs-keyword">if</span> (
      row &lt; <span class="hljs-number">0</span> ||
      row &gt;= rows ||
      col &lt; <span class="hljs-number">0</span> ||
      col &gt;= cols ||
      board[row][col] !== word[index] ||
      board[row][col] === <span class="hljs-string">"#"</span>
    ) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Mark cell as visited</span>
    <span class="hljs-keyword">const</span> temp = board[row][col];
    board[row][col] = <span class="hljs-string">"#"</span>;

    <span class="hljs-comment">// Explore all directions</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [dr, dc] <span class="hljs-keyword">of</span> directions) {
      <span class="hljs-keyword">if</span> (backtrack(row + dr, col + dc, index + <span class="hljs-number">1</span>)) {
        board[row][col] = temp; <span class="hljs-comment">// Restore</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-comment">// Backtrack: restore cell</span>
    board[row][col] = temp;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">// Try starting from each cell</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) {
      <span class="hljs-keyword">if</span> (backtrack(i, j, <span class="hljs-number">0</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">/**
 * Sudoku Solver
 * Problem: Solve 9x9 Sudoku puzzle
 * Approach: Try numbers 1-9 in empty cells, backtrack if invalid
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">solveSudoku</span>(<span class="hljs-params">board</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">board, row, col, num</span>) </span>{
    <span class="hljs-comment">// Check row</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) {
      <span class="hljs-keyword">if</span> (board[row][j] === num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Check column</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
      <span class="hljs-keyword">if</span> (board[i][col] === num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Check 3x3 box</span>
    <span class="hljs-keyword">const</span> boxRow = <span class="hljs-built_in">Math</span>.floor(row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">const</span> boxCol = <span class="hljs-built_in">Math</span>.floor(col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = boxRow; i &lt; boxRow + <span class="hljs-number">3</span>; i++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = boxCol; j &lt; boxCol + <span class="hljs-number">3</span>; j++) {
        <span class="hljs-keyword">if</span> (board[i][j] === num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) {
        <span class="hljs-keyword">if</span> (board[i][j] === <span class="hljs-string">"."</span>) {
          <span class="hljs-comment">// Try numbers 1-9</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num = <span class="hljs-string">"1"</span>; num &lt;= <span class="hljs-string">"9"</span>; num++) {
            <span class="hljs-keyword">if</span> (isValid(board, i, j, num)) {
              board[i][j] = num; <span class="hljs-comment">// Choose</span>
              <span class="hljs-keyword">if</span> (backtrack()) {
                <span class="hljs-comment">// Explore</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
              }
              board[i][j] = <span class="hljs-string">"."</span>; <span class="hljs-comment">// Unchoose</span>
            }
          }
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// No valid number found</span>
        }
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// All cells filled</span>
  }

  backtrack();
}

<span class="hljs-comment">/**
 * Letter Combinations of Phone Number
 * Problem: Generate all letter combinations from phone number
 * Approach: Map digits to letters, backtrack through combinations
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">letterCombinations</span>(<span class="hljs-params">digits</span>) </span>{
  <span class="hljs-keyword">if</span> (digits.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];

  <span class="hljs-keyword">const</span> phoneMap = {
    <span class="hljs-number">2</span>: <span class="hljs-string">"abc"</span>,
    <span class="hljs-number">3</span>: <span class="hljs-string">"def"</span>,
    <span class="hljs-number">4</span>: <span class="hljs-string">"ghi"</span>,
    <span class="hljs-number">5</span>: <span class="hljs-string">"jkl"</span>,
    <span class="hljs-number">6</span>: <span class="hljs-string">"mno"</span>,
    <span class="hljs-number">7</span>: <span class="hljs-string">"pqrs"</span>,
    <span class="hljs-number">8</span>: <span class="hljs-string">"tuv"</span>,
    <span class="hljs-number">9</span>: <span class="hljs-string">"wxyz"</span>,
  };

  <span class="hljs-keyword">const</span> result = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">index, current</span>) </span>{
    <span class="hljs-comment">// Base case: processed all digits</span>
    <span class="hljs-keyword">if</span> (index === digits.length) {
      result.push(current);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Get letters for current digit</span>
    <span class="hljs-keyword">const</span> letters = phoneMap[digits[index]];

    <span class="hljs-comment">// Try each letter</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> letter <span class="hljs-keyword">of</span> letters) {
      backtrack(index + <span class="hljs-number">1</span>, current + letter);
    }
  }

  backtrack(<span class="hljs-number">0</span>, <span class="hljs-string">""</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== ADVANCED BACKTRACKING PROBLEMS =====</span>

<span class="hljs-comment">/**
 * Restore IP Addresses
 * Problem: Generate all valid IP addresses from string
 * Approach: Try all possible segment lengths, validate each segment
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">restoreIpAddresses</span>(<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">const</span> segments = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidSegment</span>(<span class="hljs-params">segment</span>) </span>{
    <span class="hljs-keyword">if</span> (segment.length === <span class="hljs-number">0</span> || segment.length &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (segment[<span class="hljs-number">0</span>] === <span class="hljs-string">"0"</span> &amp;&amp; segment.length &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// No leading zeros</span>
    <span class="hljs-keyword">const</span> num = <span class="hljs-built_in">parseInt</span>(segment);
    <span class="hljs-keyword">return</span> num &gt;= <span class="hljs-number">0</span> &amp;&amp; num &lt;= <span class="hljs-number">255</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">start</span>) </span>{
    <span class="hljs-comment">// Base case: 4 segments formed</span>
    <span class="hljs-keyword">if</span> (segments.length === <span class="hljs-number">4</span>) {
      <span class="hljs-keyword">if</span> (start === s.length) {
        result.push(segments.join(<span class="hljs-string">"."</span>));
      }
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Try segment lengths 1, 2, 3</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> len = <span class="hljs-number">1</span>; len &lt;= <span class="hljs-number">3</span> &amp;&amp; start + len &lt;= s.length; len++) {
      <span class="hljs-keyword">const</span> segment = s.substring(start, start + len);
      <span class="hljs-keyword">if</span> (isValidSegment(segment)) {
        segments.push(segment); <span class="hljs-comment">// Choose</span>
        backtrack(start + len); <span class="hljs-comment">// Explore</span>
        segments.pop(); <span class="hljs-comment">// Unchoose</span>
      }
    }
  }

  backtrack(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Expression Add Operators
 * Problem: Add +, -, * operators to make target
 * Approach: Try all operator placements, handle precedence
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addOperators</span>(<span class="hljs-params">num, target</span>) </span>{
  <span class="hljs-keyword">const</span> result = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">index, expression, value, prev</span>) </span>{
    <span class="hljs-comment">// Base case: processed all digits</span>
    <span class="hljs-keyword">if</span> (index === num.length) {
      <span class="hljs-keyword">if</span> (value === target) {
        result.push(expression);
      }
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Try all possible number lengths from current position</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = index; i &lt; num.length; i++) {
      <span class="hljs-keyword">const</span> numStr = num.substring(index, i + <span class="hljs-number">1</span>);

      <span class="hljs-comment">// Skip numbers with leading zeros (except single '0')</span>
      <span class="hljs-keyword">if</span> (numStr.length &gt; <span class="hljs-number">1</span> &amp;&amp; numStr[<span class="hljs-number">0</span>] === <span class="hljs-string">"0"</span>) <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">const</span> numVal = <span class="hljs-built_in">parseInt</span>(numStr);

      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// First number, no operator needed</span>
        backtrack(i + <span class="hljs-number">1</span>, numStr, numVal, numVal);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Try addition</span>
        backtrack(i + <span class="hljs-number">1</span>, expression + <span class="hljs-string">"+"</span> + numStr, value + numVal, numVal);

        <span class="hljs-comment">// Try subtraction</span>
        backtrack(i + <span class="hljs-number">1</span>, expression + <span class="hljs-string">"-"</span> + numStr, value - numVal, -numVal);

        <span class="hljs-comment">// Try multiplication (handle precedence)</span>
        backtrack(
          i + <span class="hljs-number">1</span>,
          expression + <span class="hljs-string">"*"</span> + numStr,
          value - prev + prev * numVal,
          prev * numVal
        );
      }
    }
  }

  backtrack(<span class="hljs-number">0</span>, <span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-comment">/**
 * Generic Backtracking Template
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genericBacktrack</span>(<span class="hljs-params">
  choices,
  isComplete,
  isValid,
  makeChoice,
  undoChoice,
  processResult
</span>) </span>{
  <span class="hljs-keyword">const</span> state = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (isComplete(state)) {
      processResult([...state]);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> choice <span class="hljs-keyword">of</span> choices(state)) {
      <span class="hljs-keyword">if</span> (isValid(choice, state)) {
        makeChoice(choice, state);
        backtrack();
        undoChoice(choice, state);
      }
    }
  }

  backtrack();
}

<span class="hljs-comment">/**
 * Performance Measurement
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">measureBacktrackingPerformance</span>(<span class="hljs-params">func, ...args</span>) </span>{
  <span class="hljs-keyword">const</span> start = performance.now();
  <span class="hljs-keyword">const</span> result = func(...args);
  <span class="hljs-keyword">const</span> end = performance.now();

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Function: <span class="hljs-subst">${func.name}</span>`</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Time: <span class="hljs-subst">${(end - start).toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Results: <span class="hljs-subst">${<span class="hljs-built_in">Array</span>.isArray(result) ? result.length : result}</span>`</span>);

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">/**
 * Backtracking Problem Classifier
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">classifyBacktrackingProblem</span>(<span class="hljs-params">description</span>) </span>{
  <span class="hljs-keyword">const</span> patterns = {
    <span class="hljs-attr">permutation</span>: [<span class="hljs-string">"permute"</span>, <span class="hljs-string">"arrange"</span>, <span class="hljs-string">"order"</span>],
    <span class="hljs-attr">combination</span>: [<span class="hljs-string">"choose"</span>, <span class="hljs-string">"select"</span>, <span class="hljs-string">"subset"</span>],
    <span class="hljs-attr">partition</span>: [<span class="hljs-string">"split"</span>, <span class="hljs-string">"divide"</span>, <span class="hljs-string">"partition"</span>],
    <span class="hljs-attr">constraint</span>: [<span class="hljs-string">"sudoku"</span>, <span class="hljs-string">"queens"</span>, <span class="hljs-string">"valid"</span>],
    <span class="hljs-attr">path</span>: [<span class="hljs-string">"maze"</span>, <span class="hljs-string">"word search"</span>, <span class="hljs-string">"path"</span>],
    <span class="hljs-attr">expression</span>: [<span class="hljs-string">"operators"</span>, <span class="hljs-string">"parentheses"</span>, <span class="hljs-string">"formula"</span>],
  };

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [category, keywords] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(patterns)) {
    <span class="hljs-keyword">if</span> (
      keywords.some(<span class="hljs-function">(<span class="hljs-params">keyword</span>) =&gt;</span> description.toLowerCase().includes(keyword))
    ) {
      <span class="hljs-keyword">return</span> category;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">"unknown"</span>;
}

<span class="hljs-comment">// ===== EXAMPLE USAGE AND TESTING =====</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Backtracking Demo ==="</span>);

<span class="hljs-comment">// Test Classic Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Classic Backtracking Problems ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"N-Queens(4):"</span>);
solveNQueens(<span class="hljs-number">4</span>).forEach(<span class="hljs-function">(<span class="hljs-params">solution, i</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Solution <span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span>:`</span>);
  solution.forEach(<span class="hljs-function">(<span class="hljs-params">row</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(row));
  <span class="hljs-built_in">console</span>.log();
});

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Generate Parentheses(3):"</span>, generateParenthesis(<span class="hljs-number">3</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Permutations([1,2,3]):"</span>, permute([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Combinations(4,2):"</span>, combine(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Combination Sum([2,3,6,7], 7):"</span>, combinationSum([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], <span class="hljs-number">7</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Subsets([1,2,3]):"</span>, subsets([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));

<span class="hljs-comment">// Test String Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== String Backtracking Problems ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Palindrome Partitioning("aab"):'</span>, partition(<span class="hljs-string">"aab"</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Letter Combinations("23"):'</span>, letterCombinations(<span class="hljs-string">"23"</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Restore IP("25525511135"):'</span>, restoreIpAddresses(<span class="hljs-string">"25525511135"</span>));

<span class="hljs-comment">// Test Board Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Board Backtracking Problems ==="</span>);
<span class="hljs-keyword">const</span> board = [
  [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"E"</span>],
  [<span class="hljs-string">"S"</span>, <span class="hljs-string">"F"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"S"</span>],
  [<span class="hljs-string">"A"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>, <span class="hljs-string">"E"</span>],
];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Word Search("ABCCED"):'</span>, exist(board, <span class="hljs-string">"ABCCED"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Word Search("SEE"):'</span>, exist(board, <span class="hljs-string">"SEE"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Word Search("ABCB"):'</span>, exist(board, <span class="hljs-string">"ABCB"</span>)); <span class="hljs-comment">// false</span>

<span class="hljs-comment">// Performance measurement</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Performance Measurement ==="</span>);
measureBacktrackingPerformance(permute, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);
measureBacktrackingPerformance(subsets, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
measureBacktrackingPerformance(combine, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>);

<span class="hljs-comment">// Problem classification</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Problem Classification ==="</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Generate all permutations":'</span>,
  classifyBacktrackingProblem(<span class="hljs-string">"Generate all permutations"</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Choose k elements":'</span>,
  classifyBacktrackingProblem(<span class="hljs-string">"Choose k elements"</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Solve sudoku puzzle":'</span>,
  classifyBacktrackingProblem(<span class="hljs-string">"Solve sudoku puzzle"</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Find path in maze":'</span>,
  classifyBacktrackingProblem(<span class="hljs-string">"Find path in maze"</span>)
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Backtracking Strategy Guide ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"1. Identify choices at each step"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"2. Define constraints/validity checks"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"3. Implement choose-explore-unchoose pattern"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"4. Handle base cases (complete/invalid states)"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"5. Optimize with early pruning"</span>);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// ===== CLASSIC BACKTRACKING PROBLEMS =====</span>

<span class="hljs-comment">// N-Queens Problem</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NQueens</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">solveNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; result;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">'.'</span>))</span></span>;
        backtrack(result, board, <span class="hljs-number">0</span>, n);
        <span class="hljs-keyword">return</span> result;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; result, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (row == n) {
            result.push_back(board);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) {
            <span class="hljs-keyword">if</span> (isValid(board, row, col, n)) {
                board[row][col] = <span class="hljs-string">'Q'</span>;        <span class="hljs-comment">// Choose</span>
                backtrack(result, board, row + <span class="hljs-number">1</span>, n); <span class="hljs-comment">// Explore</span>
                board[row][col] = <span class="hljs-string">'.'</span>;        <span class="hljs-comment">// Unchoose</span>
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-comment">// Check column</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) {
            <span class="hljs-keyword">if</span> (board[i][col] == <span class="hljs-string">'Q'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// Check diagonal (top-left to bottom-right)</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) {
            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// Check diagonal (top-right to bottom-left)</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) {
            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};

<span class="hljs-comment">// Generate Parentheses</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenerateParentheses</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; result;
        backtrack(result, <span class="hljs-string">""</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);
        <span class="hljs-keyword">return</span> result;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; result, <span class="hljs-built_in">string</span> current, <span class="hljs-keyword">int</span> open, <span class="hljs-keyword">int</span> close, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (current.length() == <span class="hljs-number">2</span> * n) {
            result.push_back(current);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (open &lt; n) {
            backtrack(result, current + <span class="hljs-string">"("</span>, open + <span class="hljs-number">1</span>, close, n);
        }

        <span class="hljs-keyword">if</span> (close &lt; open) {
            backtrack(result, current + <span class="hljs-string">")"</span>, open, close + <span class="hljs-number">1</span>, n);
        }
    }
};

<span class="hljs-comment">// Permutations</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Permutations</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; current;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;
        backtrack(result, current, nums, used);
        <span class="hljs-keyword">return</span> result;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; result, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; current,
                   <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&amp; used)</span> </span>{
        <span class="hljs-keyword">if</span> (current.size() == nums.size()) {
            result.push_back(current);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) {
            <span class="hljs-keyword">if</span> (!used[i]) {
                current.push_back(nums[i]);  <span class="hljs-comment">// Choose</span>
                used[i] = <span class="hljs-literal">true</span>;
                backtrack(result, current, nums, used); <span class="hljs-comment">// Explore</span>
                current.pop_back();          <span class="hljs-comment">// Unchoose</span>
                used[i] = <span class="hljs-literal">false</span>;
            }
        }
    }
};

<span class="hljs-comment">// Combinations</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Combinations</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; current;
        backtrack(result, current, <span class="hljs-number">1</span>, n, k);
        <span class="hljs-keyword">return</span> result;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; result, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; current,
                   <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">if</span> (current.size() == k) {
            result.push_back(current);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= n; i++) {
            current.push_back(i);         <span class="hljs-comment">// Choose</span>
            backtrack(result, current, i + <span class="hljs-number">1</span>, n, k); <span class="hljs-comment">// Explore</span>
            current.pop_back();           <span class="hljs-comment">// Unchoose</span>
        }
    }
};

<span class="hljs-comment">// Combination Sum</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinationSum</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">combinationSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; current;
        backtrack(result, current, candidates, target, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; result, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; current,
                   <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> remaining, <span class="hljs-keyword">int</span> start)</span> </span>{
        <span class="hljs-keyword">if</span> (remaining == <span class="hljs-number">0</span>) {
            result.push_back(current);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; candidates.size(); i++) {
            current.push_back(candidates[i]);
            backtrack(result, current, candidates, remaining - candidates[i], i);
            current.pop_back();
        }
    }
};

<span class="hljs-comment">// Subsets</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subsets</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; current;
        backtrack(result, current, nums, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; result, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; current,
                   <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start)</span> </span>{
        result.push_back(current);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.size(); i++) {
            current.push_back(nums[i]);   <span class="hljs-comment">// Choose</span>
            backtrack(result, current, nums, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// Explore</span>
            current.pop_back();           <span class="hljs-comment">// Unchoose</span>
        }
    }
};

<span class="hljs-comment">// Palindrome Partitioning</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PalindromePartitioning</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; result;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; current;
        backtrack(result, current, s, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; result, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; current,
                   <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> start)</span> </span>{
        <span class="hljs-keyword">if</span> (start == s.length()) {
            result.push_back(current);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = start; end &lt; s.length(); end++) {
            <span class="hljs-keyword">if</span> (isPalindrome(s, start, end)) {
                current.push_back(s.substr(start, end - start + <span class="hljs-number">1</span>));
                backtrack(result, current, s, end + <span class="hljs-number">1</span>);
                current.pop_back();
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
        <span class="hljs-keyword">while</span> (start &lt; end) {
            <span class="hljs-keyword">if</span> (s[start] != s[end]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            start++;
            end--;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};

<span class="hljs-comment">// Word Search</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordSearch</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> word)</span> </span>{
        <span class="hljs-keyword">int</span> rows = board.size(), cols = board[<span class="hljs-number">0</span>].size();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) {
                <span class="hljs-keyword">if</span> (backtrack(board, word, i, j, <span class="hljs-number">0</span>)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span>&amp; word,
                   <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> index)</span> </span>{
        <span class="hljs-keyword">if</span> (index == word.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || row &gt;= board.size() || col &lt; <span class="hljs-number">0</span> || col &gt;= board[<span class="hljs-number">0</span>].size() ||
            board[row][col] != word[index] || board[row][col] == <span class="hljs-string">'#'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">char</span> temp = board[row][col];
        board[row][col] = <span class="hljs-string">'#'</span>;  <span class="hljs-comment">// Mark as visited</span>

        <span class="hljs-comment">// Explore all directions</span>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; directions = {{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>}, {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>}};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dir : directions) {
            <span class="hljs-keyword">if</span> (backtrack(board, word, row + dir[<span class="hljs-number">0</span>], col + dir[<span class="hljs-number">1</span>], index + <span class="hljs-number">1</span>)) {
                board[row][col] = temp; <span class="hljs-comment">// Restore</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
        }

        board[row][col] = temp; <span class="hljs-comment">// Backtrack</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};

<span class="hljs-comment">// Sudoku Solver</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SudokuSolver</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>{
        backtrack(board);
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) {
                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'.'</span>) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> num = <span class="hljs-string">'1'</span>; num &lt;= <span class="hljs-string">'9'</span>; num++) {
                        <span class="hljs-keyword">if</span> (isValid(board, i, j, num)) {
                            board[i][j] = num;    <span class="hljs-comment">// Choose</span>
                            <span class="hljs-keyword">if</span> (backtrack(board)) { <span class="hljs-comment">// Explore</span>
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                            }
                            board[i][j] = <span class="hljs-string">'.'</span>;    <span class="hljs-comment">// Unchoose</span>
                        }
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span> num)</span> </span>{
        <span class="hljs-comment">// Check row</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) {
            <span class="hljs-keyword">if</span> (board[row][j] == num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// Check column</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
            <span class="hljs-keyword">if</span> (board[i][col] == num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// Check 3x3 box</span>
        <span class="hljs-keyword">int</span> boxRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;
        <span class="hljs-keyword">int</span> boxCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = boxRow; i &lt; boxRow + <span class="hljs-number">3</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = boxCol; j &lt; boxCol + <span class="hljs-number">3</span>; j++) {
                <span class="hljs-keyword">if</span> (board[i][j] == num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;T&gt;&amp; vec, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; x : vec) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; row : matrix) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : row) {
            <span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStringMatrix</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; row : matrix) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; val : row) {
            <span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Backtracking Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test N-Queens</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== N-Queens Problem ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    NQueens nq;
    <span class="hljs-keyword">auto</span> queens = nq.solveNQueens(<span class="hljs-number">4</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"N-Queens(4) solutions: "</span> &lt;&lt; queens.size() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queens.size(); i++) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Solution "</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; row : queens[i]) {
            <span class="hljs-built_in">cout</span> &lt;&lt; row &lt;&lt; <span class="hljs-built_in">endl</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Test Generate Parentheses</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Generate Parentheses ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    GenerateParentheses gp;
    <span class="hljs-keyword">auto</span> parentheses = gp.generateParenthesis(<span class="hljs-number">3</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Generate Parentheses(3): "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; p : parentheses) {
        <span class="hljs-built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Permutations</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Permutations ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    Permutations perm;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
    <span class="hljs-keyword">auto</span> perms = perm.permute(nums);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Permutations([1,2,3]):"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printMatrix(perms);

    <span class="hljs-comment">// Test Combinations</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Combinations ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    Combinations comb;
    <span class="hljs-keyword">auto</span> combs = comb.combine(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Combinations(4,2):"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printMatrix(combs);

    <span class="hljs-comment">// Test Combination Sum</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Combination Sum ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    CombinationSum cs;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; candidates = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
    <span class="hljs-keyword">auto</span> combSums = cs.combinationSum(candidates, <span class="hljs-number">7</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Combination Sum([2,3,6,7], 7):"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printMatrix(combSums);

    <span class="hljs-comment">// Test Subsets</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Subsets ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    Subsets sub;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; subNums = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
    <span class="hljs-keyword">auto</span> subsets = sub.subsets(subNums);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Subsets([1,2,3]):"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printMatrix(subsets);

    <span class="hljs-comment">// Test Palindrome Partitioning</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Palindrome Partitioning ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    PalindromePartitioning pp;
    <span class="hljs-keyword">auto</span> partitions = pp.partition(<span class="hljs-string">"aab"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Palindrome Partitioning('aab'):"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    printStringMatrix(partitions);

    <span class="hljs-comment">// Test Word Search</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Word Search ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    WordSearch ws;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board = {
        {<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'E'</span>},
        {<span class="hljs-string">'S'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'S'</span>},
        {<span class="hljs-string">'A'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'E'</span>}
    };
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Word Search('ABCCED'): "</span> &lt;&lt; (ws.exist(board, <span class="hljs-string">"ABCCED"</span>) ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Word Search('SEE'): "</span> &lt;&lt; (ws.exist(board, <span class="hljs-string">"SEE"</span>) ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Word Search('ABCB'): "</span> &lt;&lt; (ws.exist(board, <span class="hljs-string">"ABCB"</span>) ? <span class="hljs-string">"true"</span> : <span class="hljs-string">"false"</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity">Time Complexity:</h3>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>N-Queens</strong></td>
<td>O(N!)</td>
<td>O(N²)</td>
<td>N! possible arrangements</td>
</tr>
<tr>
<td><strong>Permutations</strong></td>
<td>O(N! × N)</td>
<td>O(N)</td>
<td>N! permutations, N to copy</td>
</tr>
<tr>
<td><strong>Combinations</strong></td>
<td>O(C(n,k))</td>
<td>O(k)</td>
<td>Binomial coefficient</td>
</tr>
<tr>
<td><strong>Subsets</strong></td>
<td>O(2ⁿ × N)</td>
<td>O(N)</td>
<td>2ⁿ subsets, N to copy</td>
</tr>
<tr>
<td><strong>Sudoku</strong></td>
<td>O(9^(empty cells))</td>
<td>O(1)</td>
<td>Worst case: try all numbers</td>
</tr>
<tr>
<td><strong>Word Search</strong></td>
<td>O(M×N×4^L)</td>
<td>O(L)</td>
<td>M×N starting points, 4^L paths</td>
</tr>
</tbody>
</table>
<h3 id="space-complexity-factors">Space Complexity Factors:</h3>
<ul>
<li><strong>Recursion stack</strong>: O(depth of recursion)</li>
<li><strong>Current state</strong>: O(size of partial solution)</li>
<li><strong>Result storage</strong>: O(number of solutions × solution size)</li>
</ul>
<h3 id="optimization-techniques">Optimization Techniques:</h3>
<ol>
<li><strong>Early pruning</strong>: Eliminate invalid paths quickly</li>
<li><strong>Constraint propagation</strong>: Use constraints to reduce search space</li>
<li><strong>Ordering heuristics</strong>: Try most promising choices first</li>
<li><strong>Memoization</strong>: Cache results of subproblems (when applicable)</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-beautiful-arrangement">Problem 1: Beautiful Arrangement</h3>
<p><strong>Question</strong>: Count arrangements where nums[i] is divisible by i or i is divisible by nums[i].
<strong>Example</strong>: N=2 → 2 (arrangements: [1,2] and [2,1])
<strong>Hint</strong>: Use backtracking with position-based choices</p>
<h3 id="problem-2-partition-to-k-equal-sum-subsets">Problem 2: Partition to K Equal Sum Subsets</h3>
<p><strong>Question</strong>: Check if array can be partitioned into k subsets with equal sum.
<strong>Example</strong>: [4,3,2,3,5,2,1], k=4 → true
<strong>Hint</strong>: Backtrack by trying to fill each subset to target sum</p>
<h3 id="problem-3-remove-invalid-parentheses">Problem 3: Remove Invalid Parentheses</h3>
<p><strong>Question</strong>: Remove minimum parentheses to make string valid.
<strong>Example</strong>: &quot;()())()&quot; → [&quot;()()()&quot;, &quot;(())()&quot;]
<strong>Hint</strong>: BFS or backtracking with pruning</p>
<h3 id="problem-4-word-search-ii">Problem 4: Word Search II</h3>
<p><strong>Question</strong>: Find all words from dictionary that exist in 2D board.
<strong>Example</strong>: Board + [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] → [&quot;eat&quot;,&quot;oath&quot;]
<strong>Hint</strong>: Use Trie + backtracking for efficiency</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Problem decomposition</strong>: Can you break down the problem?</li>
<li><strong>Constraint identification</strong>: Do you understand the rules?</li>
<li><strong>Backtracking pattern</strong>: Can you implement choose-explore-unchoose?</li>
<li><strong>Base cases</strong>: Do you handle termination correctly?</li>
<li><strong>Optimization</strong>: Can you prune invalid paths early?</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Generate all</strong>: Permutations, combinations, subsets</li>
<li><strong>Find valid</strong>: N-Queens, Sudoku, valid arrangements</li>
<li><strong>Path finding</strong>: Word search, maze solving</li>
<li><strong>Constraint satisfaction</strong>: Scheduling, assignment problems</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Not implementing proper backtracking (missing unchoose step)</li>
<li>Incorrect base cases or termination conditions</li>
<li>Not handling duplicates properly</li>
<li>Missing constraint validation</li>
<li>Inefficient pruning or no pruning at all</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Start with brute force</strong>: Identify all possible choices</li>
<li><strong>Add constraints</strong>: Implement validity checks</li>
<li><strong>Implement backtracking</strong>: Choose-explore-unchoose pattern</li>
<li><strong>Optimize with pruning</strong>: Eliminate invalid paths early</li>
<li><strong>Handle edge cases</strong>: Empty inputs, single elements</li>
<li><strong>Practice templates</strong>: Master the backtracking framework</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Backtracking explores all possibilities systematically</strong> - Choose, explore, unchoose</li>
<li><strong>Early pruning is crucial</strong> - Eliminate invalid paths to improve efficiency</li>
<li><strong>State management matters</strong> - Properly track and restore state</li>
<li><strong>Constraint validation is key</strong> - Check validity before exploring</li>
<li><strong>Template approach works</strong> - Master the general backtracking pattern</li>
<li><strong>Practice problem recognition</strong> - Learn to identify backtracking problems</li>
</ol>
<p><strong>Next Chapter</strong>: We'll explore Simple Greedy Algorithms and learn how to make locally optimal choices that lead to globally optimal solutions.</p>
<h1 id="chapter-15-simple-greedy-algorithms---making-locally-optimal-choices">Chapter 15: Simple Greedy Algorithms - Making Locally Optimal Choices</h1>
<h2 id="%F0%9F%8E%AF-what-are-greedy-algorithms">🎯 What are Greedy Algorithms?</h2>
<p><strong>Greedy Algorithms</strong> make locally optimal choices at each step, hoping to find a globally optimal solution. The key insight is that for certain problems, making the best choice at each moment leads to the best overall solution.</p>
<h3 id="why-greedy-algorithms-matter">Why Greedy Algorithms Matter:</h3>
<ul>
<li><strong>Simplicity</strong>: Often easier to understand and implement than DP</li>
<li><strong>Efficiency</strong>: Usually have better time complexity than exhaustive search</li>
<li><strong>Real-world applications</strong>: Scheduling, resource allocation, networking</li>
<li><strong>Building intuition</strong>: Helps develop algorithmic thinking</li>
<li><strong>Interview frequency</strong>: Common in coding interviews</li>
<li><strong>Foundation</strong>: Basis for more complex optimization algorithms</li>
</ul>
<h3 id="core-principles">Core Principles:</h3>
<ol>
<li><strong>Greedy Choice Property</strong>: Local optimum leads to global optimum</li>
<li><strong>Optimal Substructure</strong>: Optimal solution contains optimal subsolutions</li>
<li><strong>No backtracking</strong>: Once a choice is made, it's never reconsidered</li>
</ol>
<hr>
<h2 id="%F0%9F%93%8A-greedy-vs-other-approaches">📊 Greedy vs Other Approaches</h2>
<h3 id="comparison-table">Comparison Table:</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Greedy</th>
<th>Dynamic Programming</th>
<th>Backtracking</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Strategy</strong></td>
<td>Local optimum</td>
<td>Global optimum via subproblems</td>
<td>Explore all possibilities</td>
</tr>
<tr>
<td><strong>Backtracking</strong></td>
<td>Never</td>
<td>No (bottom-up)</td>
<td>Always</td>
</tr>
<tr>
<td><strong>Time Complexity</strong></td>
<td>Usually O(n log n)</td>
<td>Usually O(n²) or O(n³)</td>
<td>Usually exponential</td>
</tr>
<tr>
<td><strong>Space Complexity</strong></td>
<td>Usually O(1)</td>
<td>Usually O(n) or O(n²)</td>
<td>Usually O(depth)</td>
</tr>
<tr>
<td><strong>Guarantee</strong></td>
<td>Not always optimal</td>
<td>Always optimal (if applicable)</td>
<td>Always finds solution</td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>Activity selection</td>
<td>Knapsack</td>
<td>N-Queens</td>
</tr>
</tbody>
</table>
<h3 id="when-greedy-works">When Greedy Works:</h3>
<ul>
<li>✅ <strong>Greedy choice property holds</strong>: Local optimum → global optimum</li>
<li>✅ <strong>Optimal substructure exists</strong>: Problem can be broken down</li>
<li>✅ <strong>No dependencies</strong>: Current choice doesn't affect future optimality</li>
<li>✅ <strong>Sorting helps</strong>: Often involves sorting by some criteria</li>
</ul>
<h3 id="when-greedy-fails">When Greedy Fails:</h3>
<ul>
<li>❌ <strong>Coin change with arbitrary denominations</strong>: [1,3,4] for amount 6</li>
<li>❌ <strong>0/1 Knapsack</strong>: Need to consider all combinations</li>
<li>❌ <strong>Shortest path with negative weights</strong>: Need to consider all paths</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-javascript-implementation">💻 JavaScript Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// Greedy Algorithms - Comprehensive Implementation</span>

<span class="hljs-comment">// ===== CLASSIC GREEDY PROBLEMS =====</span>

<span class="hljs-comment">/**
 * Activity Selection Problem
 * Problem: Select maximum number of non-overlapping activities
 * Greedy Strategy: Always pick activity that finishes earliest
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">activitySelection</span>(<span class="hljs-params">activities</span>) </span>{
  <span class="hljs-comment">// Sort by finish time</span>
  activities.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.finish - b.finish);

  <span class="hljs-keyword">const</span> selected = [];
  <span class="hljs-keyword">let</span> lastFinishTime = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> activity <span class="hljs-keyword">of</span> activities) {
    <span class="hljs-comment">// If activity starts after last selected activity finishes</span>
    <span class="hljs-keyword">if</span> (activity.start &gt;= lastFinishTime) {
      selected.push(activity);
      lastFinishTime = activity.finish;
    }
  }

  <span class="hljs-keyword">return</span> selected;
}

<span class="hljs-comment">/**
 * Fractional Knapsack
 * Problem: Maximize value with weight constraint (can take fractions)
 * Greedy Strategy: Sort by value-to-weight ratio, take highest ratios first
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fractionalKnapsack</span>(<span class="hljs-params">items, capacity</span>) </span>{
  <span class="hljs-comment">// Calculate value-to-weight ratio and sort</span>
  <span class="hljs-keyword">const</span> itemsWithRatio = items.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> ({
    ...item,
    <span class="hljs-attr">ratio</span>: item.value / item.weight,
    index,
  }));

  itemsWithRatio.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.ratio - a.ratio);

  <span class="hljs-keyword">let</span> totalValue = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> remainingCapacity = capacity;
  <span class="hljs-keyword">const</span> solution = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> itemsWithRatio) {
    <span class="hljs-keyword">if</span> (remainingCapacity === <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">if</span> (item.weight &lt;= remainingCapacity) {
      <span class="hljs-comment">// Take entire item</span>
      solution.push({ ...item, <span class="hljs-attr">fraction</span>: <span class="hljs-number">1</span> });
      totalValue += item.value;
      remainingCapacity -= item.weight;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Take fraction of item</span>
      <span class="hljs-keyword">const</span> fraction = remainingCapacity / item.weight;
      solution.push({ ...item, fraction });
      totalValue += item.value * fraction;
      remainingCapacity = <span class="hljs-number">0</span>;
    }
  }

  <span class="hljs-keyword">return</span> { totalValue, solution };
}

<span class="hljs-comment">/**
 * Coin Change (Greedy - works for standard denominations)
 * Problem: Make change using minimum number of coins
 * Greedy Strategy: Use largest denomination first
 * Note: Only works for canonical coin systems (like US coins)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coinChangeGreedy</span>(<span class="hljs-params">coins, amount</span>) </span>{
  coins.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a); <span class="hljs-comment">// Sort in descending order</span>

  <span class="hljs-keyword">const</span> result = [];
  <span class="hljs-keyword">let</span> remaining = amount;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> coin <span class="hljs-keyword">of</span> coins) {
    <span class="hljs-keyword">while</span> (remaining &gt;= coin) {
      result.push(coin);
      remaining -= coin;
    }
  }

  <span class="hljs-keyword">return</span> remaining === <span class="hljs-number">0</span> ? result : <span class="hljs-literal">null</span>; <span class="hljs-comment">// null if can't make exact change</span>
}

<span class="hljs-comment">/**
 * Job Scheduling with Deadlines
 * Problem: Schedule jobs to maximize profit within deadlines
 * Greedy Strategy: Sort by profit, schedule highest profit jobs first
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jobScheduling</span>(<span class="hljs-params">jobs</span>) </span>{
  <span class="hljs-comment">// Sort jobs by profit in descending order</span>
  jobs.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.profit - a.profit);

  <span class="hljs-keyword">const</span> maxDeadline = <span class="hljs-built_in">Math</span>.max(...jobs.map(<span class="hljs-function">(<span class="hljs-params">job</span>) =&gt;</span> job.deadline));
  <span class="hljs-keyword">const</span> schedule = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(maxDeadline).fill(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> selectedJobs = [];
  <span class="hljs-keyword">let</span> totalProfit = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> job <span class="hljs-keyword">of</span> jobs) {
    <span class="hljs-comment">// Find latest available slot before deadline</span>
    <span class="hljs-keyword">for</span> (
      <span class="hljs-keyword">let</span> slot = <span class="hljs-built_in">Math</span>.min(job.deadline - <span class="hljs-number">1</span>, maxDeadline - <span class="hljs-number">1</span>);
      slot &gt;= <span class="hljs-number">0</span>;
      slot--
    ) {
      <span class="hljs-keyword">if</span> (schedule[slot] === <span class="hljs-literal">null</span>) {
        schedule[slot] = job;
        selectedJobs.push(job);
        totalProfit += job.profit;
        <span class="hljs-keyword">break</span>;
      }
    }
  }

  <span class="hljs-keyword">return</span> { selectedJobs, totalProfit, schedule };
}

<span class="hljs-comment">/**
 * Huffman Coding
 * Problem: Create optimal prefix-free binary codes
 * Greedy Strategy: Always merge two nodes with smallest frequencies
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanNode</span> </span>{
  <span class="hljs-keyword">constructor</span>(char, freq, left = null, right = null) {
    <span class="hljs-keyword">this</span>.char = char;
    <span class="hljs-keyword">this</span>.freq = freq;
    <span class="hljs-keyword">this</span>.left = left;
    <span class="hljs-keyword">this</span>.right = right;
  }

  isLeaf() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left === <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.right === <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHeap</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.heap = [];
  }

  insert(node) {
    <span class="hljs-keyword">this</span>.heap.push(node);
    <span class="hljs-keyword">this</span>.heapifyUp(<span class="hljs-keyword">this</span>.heap.length - <span class="hljs-number">1</span>);
  }

  extractMin() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.heap.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.heap.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.heap.pop();

    <span class="hljs-keyword">const</span> min = <span class="hljs-keyword">this</span>.heap[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-keyword">this</span>.heap.pop();
    <span class="hljs-keyword">this</span>.heapifyDown(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> min;
  }

  heapifyUp(index) {
    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">Math</span>.floor((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.heap[parentIndex].freq &lt;= <span class="hljs-keyword">this</span>.heap[index].freq) <span class="hljs-keyword">break</span>;

      [<span class="hljs-keyword">this</span>.heap[parentIndex], <span class="hljs-keyword">this</span>.heap[index]] = [
        <span class="hljs-keyword">this</span>.heap[index],
        <span class="hljs-keyword">this</span>.heap[parentIndex],
      ];
      index = parentIndex;
    }
  }

  heapifyDown(index) {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">let</span> smallest = index;
      <span class="hljs-keyword">const</span> leftChild = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">const</span> rightChild = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;

      <span class="hljs-keyword">if</span> (
        leftChild &lt; <span class="hljs-keyword">this</span>.heap.length &amp;&amp;
        <span class="hljs-keyword">this</span>.heap[leftChild].freq &lt; <span class="hljs-keyword">this</span>.heap[smallest].freq
      ) {
        smallest = leftChild;
      }

      <span class="hljs-keyword">if</span> (
        rightChild &lt; <span class="hljs-keyword">this</span>.heap.length &amp;&amp;
        <span class="hljs-keyword">this</span>.heap[rightChild].freq &lt; <span class="hljs-keyword">this</span>.heap[smallest].freq
      ) {
        smallest = rightChild;
      }

      <span class="hljs-keyword">if</span> (smallest === index) <span class="hljs-keyword">break</span>;

      [<span class="hljs-keyword">this</span>.heap[index], <span class="hljs-keyword">this</span>.heap[smallest]] = [
        <span class="hljs-keyword">this</span>.heap[smallest],
        <span class="hljs-keyword">this</span>.heap[index],
      ];
      index = smallest;
    }
  }

  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.heap.length;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">huffmanCoding</span>(<span class="hljs-params">text</span>) </span>{
  <span class="hljs-comment">// Count character frequencies</span>
  <span class="hljs-keyword">const</span> freqMap = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> text) {
    freqMap[char] = (freqMap[char] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
  }

  <span class="hljs-comment">// Create min heap with character nodes</span>
  <span class="hljs-keyword">const</span> heap = <span class="hljs-keyword">new</span> MinHeap();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [char, freq] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(freqMap)) {
    heap.insert(<span class="hljs-keyword">new</span> HuffmanNode(char, freq));
  }

  <span class="hljs-comment">// Build Huffman tree</span>
  <span class="hljs-keyword">while</span> (heap.size() &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">const</span> left = heap.extractMin();
    <span class="hljs-keyword">const</span> right = heap.extractMin();
    <span class="hljs-keyword">const</span> merged = <span class="hljs-keyword">new</span> HuffmanNode(<span class="hljs-literal">null</span>, left.freq + right.freq, left, right);
    heap.insert(merged);
  }

  <span class="hljs-keyword">const</span> root = heap.extractMin();

  <span class="hljs-comment">// Generate codes</span>
  <span class="hljs-keyword">const</span> codes = {};

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateCodes</span>(<span class="hljs-params">node, code = <span class="hljs-string">""</span></span>) </span>{
    <span class="hljs-keyword">if</span> (node.isLeaf()) {
      codes[node.char] = code || <span class="hljs-string">"0"</span>; <span class="hljs-comment">// Handle single character case</span>
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (node.left) generateCodes(node.left, code + <span class="hljs-string">"0"</span>);
    <span class="hljs-keyword">if</span> (node.right) generateCodes(node.right, code + <span class="hljs-string">"1"</span>);
  }

  generateCodes(root);

  <span class="hljs-comment">// Encode text</span>
  <span class="hljs-keyword">const</span> encoded = text
    .split(<span class="hljs-string">""</span>)
    .map(<span class="hljs-function">(<span class="hljs-params">char</span>) =&gt;</span> codes[char])
    .join(<span class="hljs-string">""</span>);

  <span class="hljs-keyword">return</span> { codes, encoded, root };
}

<span class="hljs-comment">/**
 * Minimum Spanning Tree - Kruskal's Algorithm
 * Problem: Find minimum cost to connect all vertices
 * Greedy Strategy: Sort edges by weight, add edge if it doesn't create cycle
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>{
  <span class="hljs-keyword">constructor</span>(n) {
    <span class="hljs-keyword">this</span>.parent = <span class="hljs-built_in">Array</span>.from({ <span class="hljs-attr">length</span>: n }, (_, i) =&gt; i);
    <span class="hljs-keyword">this</span>.rank = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>);
  }

  find(x) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent[x] !== x) {
      <span class="hljs-keyword">this</span>.parent[x] = <span class="hljs-keyword">this</span>.find(<span class="hljs-keyword">this</span>.parent[x]); <span class="hljs-comment">// Path compression</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parent[x];
  }

  union(x, y) {
    <span class="hljs-keyword">const</span> rootX = <span class="hljs-keyword">this</span>.find(x);
    <span class="hljs-keyword">const</span> rootY = <span class="hljs-keyword">this</span>.find(y);

    <span class="hljs-keyword">if</span> (rootX === rootY) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Already connected</span>

    <span class="hljs-comment">// Union by rank</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rank[rootX] &lt; <span class="hljs-keyword">this</span>.rank[rootY]) {
      <span class="hljs-keyword">this</span>.parent[rootX] = rootY;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rank[rootX] &gt; <span class="hljs-keyword">this</span>.rank[rootY]) {
      <span class="hljs-keyword">this</span>.parent[rootY] = rootX;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.parent[rootY] = rootX;
      <span class="hljs-keyword">this</span>.rank[rootX]++;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">kruskalMST</span>(<span class="hljs-params">vertices, edges</span>) </span>{
  <span class="hljs-comment">// Sort edges by weight</span>
  edges.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.weight - b.weight);

  <span class="hljs-keyword">const</span> uf = <span class="hljs-keyword">new</span> UnionFind(vertices);
  <span class="hljs-keyword">const</span> mst = [];
  <span class="hljs-keyword">let</span> totalWeight = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> edge <span class="hljs-keyword">of</span> edges) {
    <span class="hljs-keyword">if</span> (uf.union(edge.from, edge.to)) {
      mst.push(edge);
      totalWeight += edge.weight;

      <span class="hljs-comment">// MST complete when we have V-1 edges</span>
      <span class="hljs-keyword">if</span> (mst.length === vertices - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">return</span> { mst, totalWeight };
}

<span class="hljs-comment">/**
 * Minimum Spanning Tree - Prim's Algorithm
 * Problem: Find minimum cost to connect all vertices
 * Greedy Strategy: Start from vertex, always add minimum weight edge to new vertex
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">primMST</span>(<span class="hljs-params">graph</span>) </span>{
  <span class="hljs-keyword">const</span> vertices = graph.length;
  <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(vertices).fill(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> minEdge = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(vertices).fill(<span class="hljs-literal">Infinity</span>);
  <span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(vertices).fill(<span class="hljs-number">-1</span>);

  minEdge[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// Start from vertex 0</span>
  <span class="hljs-keyword">const</span> mst = [];
  <span class="hljs-keyword">let</span> totalWeight = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; count &lt; vertices; count++) {
    <span class="hljs-comment">// Find minimum weight edge to unvisited vertex</span>
    <span class="hljs-keyword">let</span> u = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v = <span class="hljs-number">0</span>; v &lt; vertices; v++) {
      <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; (u === <span class="hljs-number">-1</span> || minEdge[v] &lt; minEdge[u])) {
        u = v;
      }
    }

    visited[u] = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">if</span> (parent[u] !== <span class="hljs-number">-1</span>) {
      mst.push({ <span class="hljs-attr">from</span>: parent[u], <span class="hljs-attr">to</span>: u, <span class="hljs-attr">weight</span>: minEdge[u] });
      totalWeight += minEdge[u];
    }

    <span class="hljs-comment">// Update minimum edges to adjacent vertices</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v = <span class="hljs-number">0</span>; v &lt; vertices; v++) {
      <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] &lt; minEdge[v]) {
        minEdge[v] = graph[u][v];
        parent[v] = u;
      }
    }
  }

  <span class="hljs-keyword">return</span> { mst, totalWeight };
}

<span class="hljs-comment">/**
 * Dijkstra's Shortest Path
 * Problem: Find shortest path from source to all vertices
 * Greedy Strategy: Always process vertex with minimum distance
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dijkstra</span>(<span class="hljs-params">graph, source</span>) </span>{
  <span class="hljs-keyword">const</span> vertices = graph.length;
  <span class="hljs-keyword">const</span> dist = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(vertices).fill(<span class="hljs-literal">Infinity</span>);
  <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(vertices).fill(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(vertices).fill(<span class="hljs-number">-1</span>);

  dist[source] = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; count &lt; vertices; count++) {
    <span class="hljs-comment">// Find unvisited vertex with minimum distance</span>
    <span class="hljs-keyword">let</span> u = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v = <span class="hljs-number">0</span>; v &lt; vertices; v++) {
      <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; (u === <span class="hljs-number">-1</span> || dist[v] &lt; dist[u])) {
        u = v;
      }
    }

    visited[u] = <span class="hljs-literal">true</span>;

    <span class="hljs-comment">// Update distances to adjacent vertices</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v = <span class="hljs-number">0</span>; v &lt; vertices; v++) {
      <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] !== <span class="hljs-number">0</span> &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) {
        dist[v] = dist[u] + graph[u][v];
        parent[v] = u;
      }
    }
  }

  <span class="hljs-keyword">return</span> { <span class="hljs-attr">distances</span>: dist, <span class="hljs-attr">parents</span>: parent };
}

<span class="hljs-comment">// ===== INTERVAL PROBLEMS =====</span>

<span class="hljs-comment">/**
 * Meeting Rooms II
 * Problem: Find minimum number of meeting rooms needed
 * Greedy Strategy: Sort by start time, use heap to track end times
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minMeetingRooms</span>(<span class="hljs-params">intervals</span>) </span>{
  <span class="hljs-keyword">if</span> (intervals.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Sort by start time</span>
  intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.start - b.start);

  <span class="hljs-comment">// Min heap to track end times of ongoing meetings</span>
  <span class="hljs-keyword">const</span> endTimes = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertHeap</span>(<span class="hljs-params">time</span>) </span>{
    endTimes.push(time);
    <span class="hljs-keyword">let</span> i = endTimes.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">Math</span>.floor((i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
      <span class="hljs-keyword">if</span> (endTimes[parent] &lt;= endTimes[i]) <span class="hljs-keyword">break</span>;
      [endTimes[parent], endTimes[i]] = [endTimes[i], endTimes[parent]];
      i = parent;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractMin</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (endTimes.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> endTimes.pop();
    <span class="hljs-keyword">const</span> min = endTimes[<span class="hljs-number">0</span>];
    endTimes[<span class="hljs-number">0</span>] = endTimes.pop();

    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">let</span> smallest = i;
      <span class="hljs-keyword">const</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">const</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;

      <span class="hljs-keyword">if</span> (left &lt; endTimes.length &amp;&amp; endTimes[left] &lt; endTimes[smallest]) {
        smallest = left;
      }
      <span class="hljs-keyword">if</span> (right &lt; endTimes.length &amp;&amp; endTimes[right] &lt; endTimes[smallest]) {
        smallest = right;
      }

      <span class="hljs-keyword">if</span> (smallest === i) <span class="hljs-keyword">break</span>;
      [endTimes[i], endTimes[smallest]] = [endTimes[smallest], endTimes[i]];
      i = smallest;
    }

    <span class="hljs-keyword">return</span> min;
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> interval <span class="hljs-keyword">of</span> intervals) {
    <span class="hljs-comment">// If current meeting starts after earliest ending meeting</span>
    <span class="hljs-keyword">if</span> (endTimes.length &gt; <span class="hljs-number">0</span> &amp;&amp; interval.start &gt;= endTimes[<span class="hljs-number">0</span>]) {
      extractMin(); <span class="hljs-comment">// Free up a room</span>
    }
    insertHeap(interval.end); <span class="hljs-comment">// Allocate room for current meeting</span>
  }

  <span class="hljs-keyword">return</span> endTimes.length;
}

<span class="hljs-comment">/**
 * Non-overlapping Intervals
 * Problem: Remove minimum intervals to make rest non-overlapping
 * Greedy Strategy: Sort by end time, keep intervals that end earliest
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eraseOverlapIntervals</span>(<span class="hljs-params">intervals</span>) </span>{
  <span class="hljs-keyword">if</span> (intervals.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Sort by end time</span>
  intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);

  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> lastEnd = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; intervals.length; i++) {
    <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; lastEnd) {
      <span class="hljs-comment">// Overlapping interval, remove it</span>
      count++;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Non-overlapping, update last end time</span>
      lastEnd = intervals[i][<span class="hljs-number">1</span>];
    }
  }

  <span class="hljs-keyword">return</span> count;
}

<span class="hljs-comment">// ===== STRING PROBLEMS =====</span>

<span class="hljs-comment">/**
 * Remove K Digits
 * Problem: Remove k digits to make smallest possible number
 * Greedy Strategy: Remove digits that make number larger (monotonic stack)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeKdigits</span>(<span class="hljs-params">num, k</span>) </span>{
  <span class="hljs-keyword">const</span> stack = [];
  <span class="hljs-keyword">let</span> toRemove = k;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> digit <span class="hljs-keyword">of</span> num) {
    <span class="hljs-comment">// Remove larger digits from stack</span>
    <span class="hljs-keyword">while</span> (
      toRemove &gt; <span class="hljs-number">0</span> &amp;&amp;
      stack.length &gt; <span class="hljs-number">0</span> &amp;&amp;
      stack[stack.length - <span class="hljs-number">1</span>] &gt; digit
    ) {
      stack.pop();
      toRemove--;
    }
    stack.push(digit);
  }

  <span class="hljs-comment">// Remove remaining digits from end</span>
  <span class="hljs-keyword">while</span> (toRemove &gt; <span class="hljs-number">0</span>) {
    stack.pop();
    toRemove--;
  }

  <span class="hljs-comment">// Build result, removing leading zeros</span>
  <span class="hljs-keyword">const</span> result = stack.join(<span class="hljs-string">""</span>).replace(<span class="hljs-regexp">/^0+/</span>, <span class="hljs-string">""</span>);
  <span class="hljs-keyword">return</span> result === <span class="hljs-string">""</span> ? <span class="hljs-string">"0"</span> : result;
}

<span class="hljs-comment">/**
 * Gas Station
 * Problem: Find starting gas station to complete circular route
 * Greedy Strategy: If total gas &gt;= total cost, solution exists
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canCompleteCircuit</span>(<span class="hljs-params">gas, cost</span>) </span>{
  <span class="hljs-keyword">let</span> totalGas = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> totalCost = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> currentGas = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; gas.length; i++) {
    totalGas += gas[i];
    totalCost += cost[i];
    currentGas += gas[i] - cost[i];

    <span class="hljs-comment">// If we can't reach next station, start from next station</span>
    <span class="hljs-keyword">if</span> (currentGas &lt; <span class="hljs-number">0</span>) {
      start = i + <span class="hljs-number">1</span>;
      currentGas = <span class="hljs-number">0</span>;
    }
  }

  <span class="hljs-keyword">return</span> totalGas &gt;= totalCost ? start : <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-comment">/**
 * Greedy Algorithm Validator
 * Checks if greedy choice property holds for a problem
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateGreedyChoice</span>(<span class="hljs-params">problem, testCases</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Validating greedy choice for: <span class="hljs-subst">${problem}</span>`</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> testCase <span class="hljs-keyword">of</span> testCases) {
    <span class="hljs-keyword">const</span> greedyResult = testCase.greedyFunction(...testCase.input);
    <span class="hljs-keyword">const</span> optimalResult = testCase.optimalFunction(...testCase.input);

    <span class="hljs-keyword">const</span> isValid =
      <span class="hljs-built_in">JSON</span>.stringify(greedyResult) === <span class="hljs-built_in">JSON</span>.stringify(optimalResult);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Test case <span class="hljs-subst">${testCase.name}</span>: <span class="hljs-subst">${isValid ? <span class="hljs-string">"PASS"</span> : <span class="hljs-string">"FAIL"</span>}</span>`</span>);

    <span class="hljs-keyword">if</span> (!isValid) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`  Greedy: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(greedyResult)}</span>`</span>);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`  Optimal: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(optimalResult)}</span>`</span>);
    }
  }
}

<span class="hljs-comment">/**
 * Performance Comparison
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareAlgorithmPerformance</span>(<span class="hljs-params">algorithms, input</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Algorithm Performance Comparison ==="</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> algo <span class="hljs-keyword">of</span> algorithms) {
    <span class="hljs-built_in">console</span>.time(algo.name);
    <span class="hljs-keyword">const</span> result = algo<span class="hljs-function">.<span class="hljs-keyword">function</span>(<span class="hljs-params">...input</span>);
    <span class="hljs-title">console</span>.<span class="hljs-title">timeEnd</span>(<span class="hljs-params">algo.name</span>);
    <span class="hljs-title">console</span>.<span class="hljs-title">log</span>(<span class="hljs-params"><span class="hljs-string">`<span class="hljs-subst">${algo.name}</span> result:`</span>, result</span>);
    <span class="hljs-title">console</span>.<span class="hljs-title">log</span>(<span class="hljs-params"></span>);
  }
}

/**
 * <span class="hljs-title">Greedy</span> <span class="hljs-title">Problem</span> <span class="hljs-title">Classifier</span>
 */
<span class="hljs-title">function</span> <span class="hljs-title">classifyGreedyProblem</span>(<span class="hljs-params">description</span>) </span>{
  <span class="hljs-keyword">const</span> patterns = {
    <span class="hljs-attr">scheduling</span>: [<span class="hljs-string">"activity"</span>, <span class="hljs-string">"job"</span>, <span class="hljs-string">"meeting"</span>, <span class="hljs-string">"interval"</span>],
    <span class="hljs-attr">graph</span>: [<span class="hljs-string">"spanning tree"</span>, <span class="hljs-string">"shortest path"</span>, <span class="hljs-string">"minimum cost"</span>],
    <span class="hljs-attr">optimization</span>: [<span class="hljs-string">"maximum"</span>, <span class="hljs-string">"minimum"</span>, <span class="hljs-string">"optimal"</span>],
    <span class="hljs-attr">selection</span>: [<span class="hljs-string">"choose"</span>, <span class="hljs-string">"select"</span>, <span class="hljs-string">"pick"</span>],
    <span class="hljs-attr">partitioning</span>: [<span class="hljs-string">"partition"</span>, <span class="hljs-string">"divide"</span>, <span class="hljs-string">"split"</span>],
    <span class="hljs-attr">encoding</span>: [<span class="hljs-string">"huffman"</span>, <span class="hljs-string">"compression"</span>, <span class="hljs-string">"coding"</span>],
  };

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [category, keywords] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(patterns)) {
    <span class="hljs-keyword">if</span> (
      keywords.some(<span class="hljs-function">(<span class="hljs-params">keyword</span>) =&gt;</span> description.toLowerCase().includes(keyword))
    ) {
      <span class="hljs-keyword">return</span> category;
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">"unknown"</span>;
}

<span class="hljs-comment">// ===== EXAMPLE USAGE AND TESTING =====</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Greedy Algorithms Demo ==="</span>);

<span class="hljs-comment">// Test Activity Selection</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Activity Selection ==="</span>);
<span class="hljs-keyword">const</span> activities = [
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"A1"</span>, <span class="hljs-attr">start</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">finish</span>: <span class="hljs-number">4</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"A2"</span>, <span class="hljs-attr">start</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">finish</span>: <span class="hljs-number">5</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"A3"</span>, <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">finish</span>: <span class="hljs-number">6</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"A4"</span>, <span class="hljs-attr">start</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">finish</span>: <span class="hljs-number">7</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"A5"</span>, <span class="hljs-attr">start</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">finish</span>: <span class="hljs-number">9</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">"A6"</span>, <span class="hljs-attr">start</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">finish</span>: <span class="hljs-number">9</span> },
];
<span class="hljs-keyword">const</span> selectedActivities = activitySelection(activities);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Selected activities:"</span>,
  selectedActivities.map(<span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> a.name)
);

<span class="hljs-comment">// Test Fractional Knapsack</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Fractional Knapsack ==="</span>);
<span class="hljs-keyword">const</span> items = [
  { <span class="hljs-attr">value</span>: <span class="hljs-number">60</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">10</span> },
  { <span class="hljs-attr">value</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">20</span> },
  { <span class="hljs-attr">value</span>: <span class="hljs-number">120</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">30</span> },
];
<span class="hljs-keyword">const</span> knapsackResult = fractionalKnapsack(items, <span class="hljs-number">50</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Fractional Knapsack result:"</span>, knapsackResult);

<span class="hljs-comment">// Test Coin Change</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Coin Change (Greedy) ==="</span>);
<span class="hljs-keyword">const</span> coins = [<span class="hljs-number">25</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Change for 67:"</span>, coinChangeGreedy(coins, <span class="hljs-number">67</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Change for 43:"</span>, coinChangeGreedy(coins, <span class="hljs-number">43</span>));

<span class="hljs-comment">// Test Job Scheduling</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Job Scheduling ==="</span>);
<span class="hljs-keyword">const</span> jobs = [
  { <span class="hljs-attr">id</span>: <span class="hljs-string">"J1"</span>, <span class="hljs-attr">deadline</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">profit</span>: <span class="hljs-number">20</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-string">"J2"</span>, <span class="hljs-attr">deadline</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">profit</span>: <span class="hljs-number">10</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-string">"J3"</span>, <span class="hljs-attr">deadline</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">profit</span>: <span class="hljs-number">40</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-string">"J4"</span>, <span class="hljs-attr">deadline</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">profit</span>: <span class="hljs-number">30</span> },
];
<span class="hljs-keyword">const</span> jobResult = jobScheduling(jobs);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Job scheduling result:"</span>, jobResult);

<span class="hljs-comment">// Test Huffman Coding</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Huffman Coding ==="</span>);
<span class="hljs-keyword">const</span> text = <span class="hljs-string">"hello world"</span>;
<span class="hljs-keyword">const</span> huffmanResult = huffmanCoding(text);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Huffman codes:"</span>, huffmanResult.codes);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Encoded text:"</span>, huffmanResult.encoded);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Compression ratio:"</span>,
  (huffmanResult.encoded.length / (text.length * <span class="hljs-number">8</span>)).toFixed(<span class="hljs-number">2</span>)
);

<span class="hljs-comment">// Test MST</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Minimum Spanning Tree ==="</span>);
<span class="hljs-keyword">const</span> edges = [
  { <span class="hljs-attr">from</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">10</span> },
  { <span class="hljs-attr">from</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">6</span> },
  { <span class="hljs-attr">from</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">5</span> },
  { <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">15</span> },
  { <span class="hljs-attr">from</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">to</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">weight</span>: <span class="hljs-number">4</span> },
];
<span class="hljs-keyword">const</span> mstResult = kruskalMST(<span class="hljs-number">4</span>, edges);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Kruskal MST:"</span>, mstResult);

<span class="hljs-comment">// Test Dijkstra</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Dijkstra Shortest Path ==="</span>);
<span class="hljs-keyword">const</span> graph = [
  [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">14</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>],
  [<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>],
  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>],
];
<span class="hljs-keyword">const</span> dijkstraResult = dijkstra(graph, <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Shortest distances from vertex 0:"</span>, dijkstraResult.distances);

<span class="hljs-comment">// Test Interval Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Interval Problems ==="</span>);
<span class="hljs-keyword">const</span> meetings = [
  { <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">end</span>: <span class="hljs-number">30</span> },
  { <span class="hljs-attr">start</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">end</span>: <span class="hljs-number">10</span> },
  { <span class="hljs-attr">start</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">end</span>: <span class="hljs-number">20</span> },
];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Minimum meeting rooms needed:"</span>, minMeetingRooms(meetings));

<span class="hljs-keyword">const</span> intervals = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>],
];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Intervals to remove:"</span>, eraseOverlapIntervals(intervals));

<span class="hljs-comment">// Test String Problems</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== String Problems ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Remove 3 digits from "1432219":'</span>, removeKdigits(<span class="hljs-string">"1432219"</span>, <span class="hljs-number">3</span>));
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Remove 1 digit from "10200":'</span>, removeKdigits(<span class="hljs-string">"10200"</span>, <span class="hljs-number">1</span>));

<span class="hljs-keyword">const</span> gas = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> cost = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Gas station starting point:"</span>, canCompleteCircuit(gas, cost));

<span class="hljs-comment">// Problem classification</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Problem Classification ==="</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Activity selection problem":'</span>,
  classifyGreedyProblem(<span class="hljs-string">"Activity selection problem"</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Find minimum spanning tree":'</span>,
  classifyGreedyProblem(<span class="hljs-string">"Find minimum spanning tree"</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Choose maximum profit jobs":'</span>,
  classifyGreedyProblem(<span class="hljs-string">"Choose maximum profit jobs"</span>)
);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'"Huffman encoding algorithm":'</span>,
  classifyGreedyProblem(<span class="hljs-string">"Huffman encoding algorithm"</span>)
);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Greedy Strategy Guide ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"1. Identify the greedy choice property"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"2. Prove that greedy choice leads to optimal solution"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"3. Sort input by appropriate criteria"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"4. Make locally optimal choices"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"5. Verify solution optimality"</span>);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// ===== CLASSIC GREEDY PROBLEMS =====</span>

<span class="hljs-comment">// Activity Selection</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Activity</span> {</span>
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> start, finish;
};

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;Activity&gt; <span class="hljs-title">activitySelection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Activity&gt; activities)</span> </span>{
    <span class="hljs-comment">// Sort by finish time</span>
    sort(activities.begin(), activities.end(),
         [](<span class="hljs-keyword">const</span> Activity&amp; a, <span class="hljs-keyword">const</span> Activity&amp; b) {
             <span class="hljs-keyword">return</span> a.finish &lt; b.finish;
         });

    <span class="hljs-built_in">vector</span>&lt;Activity&gt; selected;
    <span class="hljs-keyword">int</span> lastFinishTime = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; activity : activities) {
        <span class="hljs-keyword">if</span> (activity.start &gt;= lastFinishTime) {
            selected.push_back(activity);
            lastFinishTime = activity.finish;
        }
    }

    <span class="hljs-keyword">return</span> selected;
}

<span class="hljs-comment">// Fractional Knapsack</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Item</span> {</span>
    <span class="hljs-keyword">int</span> value, weight;
    <span class="hljs-keyword">double</span> ratio;
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KnapsackResult</span> {</span>
    <span class="hljs-keyword">double</span> totalValue;
    <span class="hljs-built_in">vector</span>&lt;pair&lt;Item, <span class="hljs-keyword">double</span>&gt;&gt; solution; <span class="hljs-comment">// item and fraction taken</span>
};

<span class="hljs-function">KnapsackResult <span class="hljs-title">fractionalKnapsack</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Item&gt; items, <span class="hljs-keyword">int</span> capacity)</span> </span>{
    <span class="hljs-comment">// Calculate ratios</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : items) {
        item.ratio = (<span class="hljs-keyword">double</span>)item.value / item.weight;
    }

    <span class="hljs-comment">// Sort by ratio in descending order</span>
    sort(items.begin(), items.end(),
         [](<span class="hljs-keyword">const</span> Item&amp; a, <span class="hljs-keyword">const</span> Item&amp; b) {
             <span class="hljs-keyword">return</span> a.ratio &gt; b.ratio;
         });

    KnapsackResult result;
    result.totalValue = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> remainingCapacity = capacity;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; item : items) {
        <span class="hljs-keyword">if</span> (remainingCapacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">if</span> (item.weight &lt;= remainingCapacity) {
            <span class="hljs-comment">// Take entire item</span>
            result.solution.push_back({item, <span class="hljs-number">1.0</span>});
            result.totalValue += item.value;
            remainingCapacity -= item.weight;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Take fraction</span>
            <span class="hljs-keyword">double</span> fraction = (<span class="hljs-keyword">double</span>)remainingCapacity / item.weight;
            result.solution.push_back({item, fraction});
            result.totalValue += item.value * fraction;
            remainingCapacity = <span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Job Scheduling</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Job</span> {</span>
    <span class="hljs-built_in">string</span> id;
    <span class="hljs-keyword">int</span> deadline, profit;
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JobResult</span> {</span>
    <span class="hljs-built_in">vector</span>&lt;Job&gt; selectedJobs;
    <span class="hljs-keyword">int</span> totalProfit;
    <span class="hljs-built_in">vector</span>&lt;Job&gt; schedule;
};

<span class="hljs-function">JobResult <span class="hljs-title">jobScheduling</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Job&gt; jobs)</span> </span>{
    <span class="hljs-comment">// Sort by profit in descending order</span>
    sort(jobs.begin(), jobs.end(),
         [](<span class="hljs-keyword">const</span> Job&amp; a, <span class="hljs-keyword">const</span> Job&amp; b) {
             <span class="hljs-keyword">return</span> a.profit &gt; b.profit;
         });

    <span class="hljs-keyword">int</span> maxDeadline = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; job : jobs) {
        maxDeadline = max(maxDeadline, job.deadline);
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;Job&gt; <span class="hljs-title">schedule</span><span class="hljs-params">(maxDeadline)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">occupied</span><span class="hljs-params">(maxDeadline, <span class="hljs-literal">false</span>)</span></span>;
    JobResult result;
    result.totalProfit = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; job : jobs) {
        <span class="hljs-comment">// Find latest available slot before deadline</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> slot = min(job.deadline - <span class="hljs-number">1</span>, maxDeadline - <span class="hljs-number">1</span>); slot &gt;= <span class="hljs-number">0</span>; slot--) {
            <span class="hljs-keyword">if</span> (!occupied[slot]) {
                schedule[slot] = job;
                occupied[slot] = <span class="hljs-literal">true</span>;
                result.selectedJobs.push_back(job);
                result.totalProfit += job.profit;
                <span class="hljs-keyword">break</span>;
            }
        }
    }

    result.schedule = schedule;
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Union-Find for Kruskal's Algorithm</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parent, rank;

    UnionFind(<span class="hljs-keyword">int</span> n) : parent(n), rank(n, <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            parent[i] = i;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        <span class="hljs-keyword">if</span> (parent[x] != x) {
            parent[x] = find(parent[x]); <span class="hljs-comment">// Path compression</span>
        }
        <span class="hljs-keyword">return</span> parent[x];
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        <span class="hljs-keyword">int</span> rootX = find(x), rootY = find(y);
        <span class="hljs-keyword">if</span> (rootX == rootY) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-comment">// Union by rank</span>
        <span class="hljs-keyword">if</span> (rank[rootX] &lt; rank[rootY]) {
            parent[rootX] = rootY;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank[rootX] &gt; rank[rootY]) {
            parent[rootY] = rootX;
        } <span class="hljs-keyword">else</span> {
            parent[rootY] = rootX;
            rank[rootX]++;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};

<span class="hljs-comment">// Kruskal's MST</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> {</span>
    <span class="hljs-keyword">int</span> from, to, weight;
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MSTResult</span> {</span>
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; mst;
    <span class="hljs-keyword">int</span> totalWeight;
};

<span class="hljs-function">MSTResult <span class="hljs-title">kruskalMST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertices, <span class="hljs-built_in">vector</span>&lt;Edge&gt; edges)</span> </span>{
    <span class="hljs-comment">// Sort edges by weight</span>
    sort(edges.begin(), edges.end(),
         [](<span class="hljs-keyword">const</span> Edge&amp; a, <span class="hljs-keyword">const</span> Edge&amp; b) {
             <span class="hljs-keyword">return</span> a.weight &lt; b.weight;
         });

    <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(vertices)</span></span>;
    MSTResult result;
    result.totalWeight = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) {
        <span class="hljs-keyword">if</span> (uf.unite(edge.from, edge.to)) {
            result.mst.push_back(edge);
            result.totalWeight += edge.weight;

            <span class="hljs-keyword">if</span> (result.mst.size() == vertices - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// Dijkstra's Algorithm</span>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph, <span class="hljs-keyword">int</span> source)</span> </span>{
    <span class="hljs-keyword">int</span> vertices = graph.size();
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(vertices, INT_MAX)</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(vertices, <span class="hljs-literal">false</span>)</span></span>;

    dist[source] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; count &lt; vertices; count++) {
        <span class="hljs-comment">// Find unvisited vertex with minimum distance</span>
        <span class="hljs-keyword">int</span> u = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; vertices; v++) {
            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; (u == <span class="hljs-number">-1</span> || dist[v] &lt; dist[u])) {
                u = v;
            }
        }

        visited[u] = <span class="hljs-literal">true</span>;

        <span class="hljs-comment">// Update distances</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; vertices; v++) {
            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] != <span class="hljs-number">0</span> &amp;&amp;
                dist[u] != INT_MAX &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) {
                dist[v] = dist[u] + graph[u][v];
            }
        }
    }

    <span class="hljs-keyword">return</span> dist;
}

<span class="hljs-comment">// Meeting Rooms II</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Interval</span> {</span>
    <span class="hljs-keyword">int</span> start, end;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Interval&gt; intervals)</span> </span>{
    <span class="hljs-keyword">if</span> (intervals.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Sort by start time</span>
    sort(intervals.begin(), intervals.end(),
         [](<span class="hljs-keyword">const</span> Interval&amp; a, <span class="hljs-keyword">const</span> Interval&amp; b) {
             <span class="hljs-keyword">return</span> a.start &lt; b.start;
         });

    <span class="hljs-comment">// Min heap for end times</span>
    priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; endTimes;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; interval : intervals) {
        <span class="hljs-comment">// If current meeting starts after earliest ending meeting</span>
        <span class="hljs-keyword">if</span> (!endTimes.empty() &amp;&amp; interval.start &gt;= endTimes.top()) {
            endTimes.pop(); <span class="hljs-comment">// Free up a room</span>
        }
        endTimes.push(interval.end); <span class="hljs-comment">// Allocate room</span>
    }

    <span class="hljs-keyword">return</span> endTimes.size();
}

<span class="hljs-comment">// Remove K Digits</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeKdigits</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-built_in">string</span> <span class="hljs-built_in">stack</span>;
    <span class="hljs-keyword">int</span> toRemove = k;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> digit : num) {
        <span class="hljs-comment">// Remove larger digits</span>
        <span class="hljs-keyword">while</span> (toRemove &gt; <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-built_in">stack</span>.empty() &amp;&amp; <span class="hljs-built_in">stack</span>.back() &gt; digit) {
            <span class="hljs-built_in">stack</span>.pop_back();
            toRemove--;
        }
        <span class="hljs-built_in">stack</span>.push_back(digit);
    }

    <span class="hljs-comment">// Remove remaining digits from end</span>
    <span class="hljs-keyword">while</span> (toRemove &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">stack</span>.pop_back();
        toRemove--;
    }

    <span class="hljs-comment">// Remove leading zeros</span>
    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (start &lt; <span class="hljs-built_in">stack</span>.length() &amp;&amp; <span class="hljs-built_in">stack</span>[start] == <span class="hljs-string">'0'</span>) {
        start++;
    }

    <span class="hljs-built_in">string</span> result = <span class="hljs-built_in">stack</span>.substr(start);
    <span class="hljs-keyword">return</span> result.empty() ? <span class="hljs-string">"0"</span> : result;
}

<span class="hljs-comment">// Gas Station</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; gas, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>{
    <span class="hljs-keyword">int</span> totalGas = <span class="hljs-number">0</span>, totalCost = <span class="hljs-number">0</span>, currentGas = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.size(); i++) {
        totalGas += gas[i];
        totalCost += cost[i];
        currentGas += gas[i] - cost[i];

        <span class="hljs-keyword">if</span> (currentGas &lt; <span class="hljs-number">0</span>) {
            start = i + <span class="hljs-number">1</span>;
            currentGas = <span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-keyword">return</span> totalGas &gt;= totalCost ? start : <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">// ===== UTILITY FUNCTIONS =====</span>

<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;T&gt;&amp; vec, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; label = <span class="hljs-string">""</span>)</span> </span>{
    <span class="hljs-keyword">if</span> (!label.empty()) {
        <span class="hljs-built_in">cout</span> &lt;&lt; label &lt;&lt; <span class="hljs-string">": "</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; x : vec) {
        <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printActivities</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Activity&gt;&amp; activities)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; activity : activities) {
        <span class="hljs-built_in">cout</span> &lt;&lt; activity.name &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; activity.start &lt;&lt; <span class="hljs-string">"-"</span> &lt;&lt; activity.finish &lt;&lt; <span class="hljs-string">") "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printJobs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Job&gt;&amp; jobs)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; job : jobs) {
        <span class="hljs-built_in">cout</span> &lt;&lt; job.id &lt;&lt; <span class="hljs-string">"(deadline:"</span> &lt;&lt; job.deadline &lt;&lt; <span class="hljs-string">", profit:"</span> &lt;&lt; job.profit &lt;&lt; <span class="hljs-string">") "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printEdges</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Edge&gt;&amp; edges)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) {
        <span class="hljs-built_in">cout</span> &lt;&lt; edge.from &lt;&lt; <span class="hljs-string">"-"</span> &lt;&lt; edge.to &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; edge.weight &lt;&lt; <span class="hljs-string">") "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// Example Usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Greedy Algorithms Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Activity Selection</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Activity Selection ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;Activity&gt; activities = {
        {<span class="hljs-string">"A1"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>}, {<span class="hljs-string">"A2"</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>}, {<span class="hljs-string">"A3"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>},
        {<span class="hljs-string">"A4"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>}, {<span class="hljs-string">"A5"</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>}, {<span class="hljs-string">"A6"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>}
    };
    <span class="hljs-keyword">auto</span> selected = activitySelection(activities);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Selected activities: "</span>;
    printActivities(selected);

    <span class="hljs-comment">// Test Fractional Knapsack</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Fractional Knapsack ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;Item&gt; items = {{<span class="hljs-number">60</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">100</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">120</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>}};
    <span class="hljs-keyword">auto</span> knapsackResult = fractionalKnapsack(items, <span class="hljs-number">50</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total value: "</span> &lt;&lt; knapsackResult.totalValue &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Job Scheduling</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Job Scheduling ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;Job&gt; jobs = {
        {<span class="hljs-string">"J1"</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>}, {<span class="hljs-string">"J2"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>}, {<span class="hljs-string">"J3"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">40</span>}, {<span class="hljs-string">"J4"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">30</span>}
    };
    <span class="hljs-keyword">auto</span> jobResult = jobScheduling(jobs);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Selected jobs: "</span>;
    printJobs(jobResult.selectedJobs);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total profit: "</span> &lt;&lt; jobResult.totalProfit &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Kruskal's MST</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Kruskal's MST ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;Edge&gt; edges = {
        {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>}, {<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>}, {<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}
    };
    <span class="hljs-keyword">auto</span> mstResult = kruskalMST(<span class="hljs-number">4</span>, edges);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"MST edges: "</span>;
    printEdges(mstResult.mst);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total weight: "</span> &lt;&lt; mstResult.totalWeight &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Dijkstra</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Dijkstra's Algorithm ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; graph = {
        {<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>},
        {<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>},
        {<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>},
        {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>},
        {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>},
        {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">14</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>},
        {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>},
        {<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>},
        {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>}
    };
    <span class="hljs-keyword">auto</span> distances = dijkstra(graph, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Shortest distances from vertex 0: "</span>;
    printVector(distances);

    <span class="hljs-comment">// Test Meeting Rooms</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Meeting Rooms ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;Interval&gt; meetings = {{<span class="hljs-number">0</span>, <span class="hljs-number">30</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">10</span>}, {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>}};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Minimum meeting rooms: "</span> &lt;&lt; minMeetingRooms(meetings) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Remove K Digits</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Remove K Digits ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Remove 3 digits from '1432219': "</span> &lt;&lt; removeKdigits(<span class="hljs-string">"1432219"</span>, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Remove 1 digit from '10200': "</span> &lt;&lt; removeKdigits(<span class="hljs-string">"10200"</span>, <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Test Gas Station</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Gas Station ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; gas = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cost = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Starting gas station: "</span> &lt;&lt; canCompleteCircuit(gas, cost) &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%E2%9A%A1-performance-analysis">⚡ Performance Analysis</h2>
<h3 id="time-complexity-comparison">Time Complexity Comparison:</h3>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Greedy Time</th>
<th>Optimal Time</th>
<th>Space</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Activity Selection</strong></td>
<td>O(n log n)</td>
<td>O(2ⁿ)</td>
<td>O(1)</td>
<td>Sorting dominates</td>
</tr>
<tr>
<td><strong>Fractional Knapsack</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>Greedy is optimal</td>
</tr>
<tr>
<td><strong>Coin Change</strong></td>
<td>O(n)</td>
<td>O(amount × coins)</td>
<td>O(1)</td>
<td>Only for canonical systems</td>
</tr>
<tr>
<td><strong>Job Scheduling</strong></td>
<td>O(n log n)</td>
<td>O(2ⁿ)</td>
<td>O(n)</td>
<td>Sorting + scheduling</td>
</tr>
<tr>
<td><strong>MST (Kruskal)</strong></td>
<td>O(E log E)</td>
<td>O(E log E)</td>
<td>O(V)</td>
<td>Greedy is optimal</td>
</tr>
<tr>
<td><strong>MST (Prim)</strong></td>
<td>O(V²)</td>
<td>O(V²)</td>
<td>O(V)</td>
<td>With adjacency matrix</td>
</tr>
<tr>
<td><strong>Shortest Path</strong></td>
<td>O(V²)</td>
<td>O(V²)</td>
<td>O(V)</td>
<td>Dijkstra is optimal</td>
</tr>
</tbody>
</table>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>Most greedy algorithms</strong>: O(1) to O(n) auxiliary space</li>
<li><strong>Graph algorithms</strong>: O(V + E) for adjacency representation</li>
<li><strong>Heap-based algorithms</strong>: O(n) for priority queue</li>
</ul>
<h3 id="when-greedy-is-optimal">When Greedy is Optimal:</h3>
<ol>
<li><strong>Greedy choice property</strong>: Local optimum leads to global optimum</li>
<li><strong>Optimal substructure</strong>: Problem exhibits optimal substructure</li>
<li><strong>No future dependencies</strong>: Current choice doesn't affect future optimality</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%A9-practice-problems">🧩 Practice Problems</h2>
<h3 id="problem-1-jump-game-ii">Problem 1: Jump Game II</h3>
<p><strong>Question</strong>: Find minimum jumps to reach end of array.
<strong>Example</strong>: <code>[2,3,1,1,4]</code> → 2 (jump 1 step from index 0 to 1, then 3 steps to last index)
<strong>Hint</strong>: Greedy - always jump to position that allows furthest reach</p>
<h3 id="problem-2-candy-distribution">Problem 2: Candy Distribution</h3>
<p><strong>Question</strong>: Distribute minimum candies to children with rating constraints.
<strong>Example</strong>: <code>[1,0,2]</code> → 5 (give [2,1,2] candies)
<strong>Hint</strong>: Two passes - left to right, then right to left</p>
<h3 id="problem-3-task-scheduler">Problem 3: Task Scheduler</h3>
<p><strong>Question</strong>: Find minimum time to execute tasks with cooldown period.
<strong>Example</strong>: <code>['A','A','A','B','B','B']</code>, n=2 → 8
<strong>Hint</strong>: Greedy scheduling with most frequent tasks first</p>
<h3 id="problem-4-minimum-number-of-arrows">Problem 4: Minimum Number of Arrows</h3>
<p><strong>Question</strong>: Find minimum arrows to burst all balloons.
<strong>Example</strong>: <code>[[10,16],[2,8],[1,6],[7,12]]</code> → 2
<strong>Hint</strong>: Sort by end position, shoot arrow at earliest end</p>
<hr>
<h2 id="%F0%9F%8E%AF-interview-tips">🎯 Interview Tips</h2>
<h3 id="what-interviewers-look-for">What Interviewers Look For:</h3>
<ol>
<li><strong>Problem recognition</strong>: Can you identify when greedy works?</li>
<li><strong>Proof of correctness</strong>: Can you prove greedy choice property?</li>
<li><strong>Implementation</strong>: Clean, efficient code</li>
<li><strong>Edge cases</strong>: Handle empty inputs, single elements</li>
<li><strong>Optimization</strong>: Can you optimize time/space complexity?</li>
</ol>
<h3 id="common-interview-patterns">Common Interview Patterns:</h3>
<ul>
<li><strong>Interval problems</strong>: Activity selection, meeting rooms</li>
<li><strong>Graph problems</strong>: MST, shortest path</li>
<li><strong>Optimization problems</strong>: Knapsack variants, scheduling</li>
<li><strong>String problems</strong>: Parentheses, digit removal</li>
<li><strong>Array problems</strong>: Jump game, candy distribution</li>
</ul>
<h3 id="red-flags-to-avoid">Red Flags to Avoid:</h3>
<ul>
<li>Using greedy when it doesn't guarantee optimal solution</li>
<li>Not proving greedy choice property</li>
<li>Incorrect sorting criteria</li>
<li>Missing edge cases</li>
<li>Inefficient implementation</li>
</ul>
<h3 id="pro-tips">Pro Tips:</h3>
<ol>
<li><strong>Identify the greedy choice</strong>: What's the locally optimal decision?</li>
<li><strong>Prove correctness</strong>: Show that greedy choice leads to optimal solution</li>
<li><strong>Sort when needed</strong>: Many greedy algorithms require sorting</li>
<li><strong>Consider counterexamples</strong>: Test if greedy always works</li>
<li><strong>Optimize implementation</strong>: Use appropriate data structures</li>
<li><strong>Practice pattern recognition</strong>: Learn common greedy problem types</li>
</ol>
<hr>
<h2 id="%F0%9F%9A%80-key-takeaways">🚀 Key Takeaways</h2>
<ol>
<li><strong>Greedy makes locally optimal choices</strong> - Hope for globally optimal solution</li>
<li><strong>Not always optimal</strong> - Must prove greedy choice property</li>
<li><strong>Often involves sorting</strong> - Sort by appropriate criteria first</li>
<li><strong>Efficient when applicable</strong> - Usually better time complexity than DP</li>
<li><strong>Pattern recognition crucial</strong> - Learn to identify greedy problems</li>
<li><strong>Proof is important</strong> - Always verify correctness</li>
</ol>
<p><strong>Congratulations!</strong> You've completed the Medium Complexity section of the DSA learning path. You now have a solid foundation in fundamental data structures and essential algorithms. The next step would be to work on the final mini-project that combines multiple concepts you've learned.</p>
<p><strong>Next Steps</strong>:</p>
<ul>
<li>Review all chapters and practice problems</li>
<li>Work on the comprehensive mini-project</li>
<li>Apply these concepts to real-world problems</li>
<li>Continue with advanced topics like advanced graph algorithms, advanced DP, and system design</li>
</ul>
<h1 id="mini-project-task-management-system-with-advanced-data-structures">Mini-Project: Task Management System with Advanced Data Structures</h1>
<h2 id="%F0%9F%8E%AF-project-overview">🎯 Project Overview</h2>
<p>This comprehensive mini-project combines multiple data structures and algorithms concepts learned throughout the course. You'll build a <strong>Task Management System</strong> that demonstrates practical applications of arrays, linked lists, stacks, queues, hash tables, trees, graphs, sorting, searching, dynamic programming, backtracking, and greedy algorithms.</p>
<h3 id="learning-objectives">Learning Objectives:</h3>
<ul>
<li><strong>Integration</strong>: Combine multiple DSA concepts in a real-world application</li>
<li><strong>Problem-solving</strong>: Apply algorithmic thinking to practical problems</li>
<li><strong>Optimization</strong>: Use appropriate data structures for different operations</li>
<li><strong>Scalability</strong>: Design systems that can handle growing data</li>
<li><strong>Performance</strong>: Analyze and optimize time/space complexity</li>
</ul>
<h3 id="project-features">Project Features:</h3>
<ol>
<li><strong>Task Management</strong>: Create, update, delete, and organize tasks</li>
<li><strong>Priority Scheduling</strong>: Implement priority-based task scheduling</li>
<li><strong>Dependency Management</strong>: Handle task dependencies using graphs</li>
<li><strong>Search &amp; Filter</strong>: Efficient searching and filtering capabilities</li>
<li><strong>Analytics</strong>: Generate insights using various algorithms</li>
<li><strong>Optimization</strong>: Resource allocation and scheduling optimization</li>
</ol>
<hr>
<h2 id="%F0%9F%8F%97%EF%B8%8F-system-architecture">🏗️ System Architecture</h2>
<h3 id="core-components">Core Components:</h3>
<pre class="hljs"><code><div>TaskManagementSystem
├── TaskManager (Hash Table + Linked List)
├── PriorityScheduler (Heap + Queue)
├── DependencyGraph (Graph + Topological Sort)
├── SearchEngine (Trie + Binary Search)
├── Analytics (Dynamic Programming)
└── Optimizer (Greedy Algorithms)
</div></code></pre>
<h3 id="data-structures-used">Data Structures Used:</h3>
<ul>
<li><strong>Hash Table</strong>: Fast task lookup and storage</li>
<li><strong>Linked List</strong>: Task history and undo operations</li>
<li><strong>Stack</strong>: Undo/Redo functionality</li>
<li><strong>Queue</strong>: Task processing pipeline</li>
<li><strong>Heap</strong>: Priority-based scheduling</li>
<li><strong>Tree</strong>: Hierarchical task organization</li>
<li><strong>Graph</strong>: Task dependencies</li>
<li><strong>Trie</strong>: Efficient text search</li>
</ul>
<hr>
<h2 id="%F0%9F%92%BB-implementation">💻 Implementation</h2>
<h3 id="javascript-implementation">JavaScript Implementation</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// Task Management System - Comprehensive Implementation</span>

<span class="hljs-comment">// ===== CORE DATA STRUCTURES =====</span>

<span class="hljs-comment">/**
 * Task Entity
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>{
  <span class="hljs-keyword">constructor</span>(
    id,
    title,
    description,
    priority = 1,
    estimatedTime = 1,
    tags = []
  ) {
    <span class="hljs-keyword">this</span>.id = id;
    <span class="hljs-keyword">this</span>.title = title;
    <span class="hljs-keyword">this</span>.description = description;
    <span class="hljs-keyword">this</span>.priority = priority; <span class="hljs-comment">// 1-5 (5 = highest)</span>
    <span class="hljs-keyword">this</span>.estimatedTime = estimatedTime; <span class="hljs-comment">// in hours</span>
    <span class="hljs-keyword">this</span>.actualTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">"pending"</span>; <span class="hljs-comment">// pending, in-progress, completed, cancelled</span>
    <span class="hljs-keyword">this</span>.tags = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(tags);
    <span class="hljs-keyword">this</span>.dependencies = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">this</span>.dependents = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">this</span>.createdAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    <span class="hljs-keyword">this</span>.updatedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    <span class="hljs-keyword">this</span>.completedAt = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.assignee = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.deadline = <span class="hljs-literal">null</span>;
  }

  addDependency(taskId) {
    <span class="hljs-keyword">this</span>.dependencies.add(taskId);
  }

  addDependent(taskId) {
    <span class="hljs-keyword">this</span>.dependents.add(taskId);
  }

  updateStatus(status) {
    <span class="hljs-keyword">this</span>.status = status;
    <span class="hljs-keyword">this</span>.updatedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    <span class="hljs-keyword">if</span> (status === <span class="hljs-string">"completed"</span>) {
      <span class="hljs-keyword">this</span>.completedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
    }
  }

  addTag(tag) {
    <span class="hljs-keyword">this</span>.tags.add(tag);
  }

  removeTag(tag) {
    <span class="hljs-keyword">this</span>.tags.delete(tag);
  }

  isBlocked() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dependencies.size &gt; <span class="hljs-number">0</span>;
  }

  getEfficiency() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.actualTime === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.estimatedTime / <span class="hljs-keyword">this</span>.actualTime;
  }
}

<span class="hljs-comment">/**
 * Custom Hash Table for Task Storage
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskHashTable</span> </span>{
  <span class="hljs-keyword">constructor</span>(initialSize = 16) {
    <span class="hljs-keyword">this</span>.size = initialSize;
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.buckets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">this</span>.size).fill(<span class="hljs-literal">null</span>).map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> []);
  }

  hash(key) {
    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; key.length; i++) {
      hash = (hash * <span class="hljs-number">31</span> + key.charCodeAt(i)) % <span class="hljs-keyword">this</span>.size;
    }
    <span class="hljs-keyword">return</span> hash;
  }

  put(key, value) {
    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.hash(key);
    <span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">this</span>.buckets[index];

    <span class="hljs-comment">// Check if key already exists</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) {
      <span class="hljs-keyword">if</span> (bucket[i][<span class="hljs-number">0</span>] === key) {
        bucket[i][<span class="hljs-number">1</span>] = value;
        <span class="hljs-keyword">return</span>;
      }
    }

    <span class="hljs-comment">// Add new key-value pair</span>
    bucket.push([key, value]);
    <span class="hljs-keyword">this</span>.count++;

    <span class="hljs-comment">// Resize if load factor &gt; 0.75</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &gt; <span class="hljs-keyword">this</span>.size * <span class="hljs-number">0.75</span>) {
      <span class="hljs-keyword">this</span>.resize();
    }
  }

  <span class="hljs-keyword">get</span>(key) {
    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.hash(key);
    <span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">this</span>.buckets[index];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k, v] <span class="hljs-keyword">of</span> bucket) {
      <span class="hljs-keyword">if</span> (k === key) <span class="hljs-keyword">return</span> v;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">delete</span>(key) {
    <span class="hljs-keyword">const</span> index = <span class="hljs-keyword">this</span>.hash(key);
    <span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">this</span>.buckets[index];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bucket.length; i++) {
      <span class="hljs-keyword">if</span> (bucket[i][<span class="hljs-number">0</span>] === key) {
        bucket.splice(i, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">this</span>.count--;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  resize() {
    <span class="hljs-keyword">const</span> oldBuckets = <span class="hljs-keyword">this</span>.buckets;
    <span class="hljs-keyword">this</span>.size *= <span class="hljs-number">2</span>;
    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.buckets = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">this</span>.size).fill(<span class="hljs-literal">null</span>).map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> []);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bucket <span class="hljs-keyword">of</span> oldBuckets) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> bucket) {
        <span class="hljs-keyword">this</span>.put(key, value);
      }
    }
  }

  getAllValues() {
    <span class="hljs-keyword">const</span> values = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> bucket <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.buckets) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> bucket) {
        values.push(value);
      }
    }
    <span class="hljs-keyword">return</span> values;
  }
}

<span class="hljs-comment">/**
 * Priority Queue using Min/Max Heap
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span> </span>{
  <span class="hljs-keyword">constructor</span>(compareFn = (a, b) =&gt; a.priority - b.priority) {
    <span class="hljs-keyword">this</span>.heap = [];
    <span class="hljs-keyword">this</span>.compare = compareFn;
  }

  enqueue(item) {
    <span class="hljs-keyword">this</span>.heap.push(item);
    <span class="hljs-keyword">this</span>.heapifyUp(<span class="hljs-keyword">this</span>.heap.length - <span class="hljs-number">1</span>);
  }

  dequeue() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.heap.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.heap.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.heap.pop();

    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">this</span>.heap[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">this</span>.heap[<span class="hljs-number">0</span>] = <span class="hljs-keyword">this</span>.heap.pop();
    <span class="hljs-keyword">this</span>.heapifyDown(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> root;
  }

  peek() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.heap.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">this</span>.heap[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;
  }

  heapifyUp(index) {
    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">Math</span>.floor((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.compare(<span class="hljs-keyword">this</span>.heap[index], <span class="hljs-keyword">this</span>.heap[parentIndex]) &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;

      [<span class="hljs-keyword">this</span>.heap[index], <span class="hljs-keyword">this</span>.heap[parentIndex]] = [
        <span class="hljs-keyword">this</span>.heap[parentIndex],
        <span class="hljs-keyword">this</span>.heap[index],
      ];
      index = parentIndex;
    }
  }

  heapifyDown(index) {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">let</span> smallest = index;
      <span class="hljs-keyword">const</span> leftChild = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;
      <span class="hljs-keyword">const</span> rightChild = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;

      <span class="hljs-keyword">if</span> (
        leftChild &lt; <span class="hljs-keyword">this</span>.heap.length &amp;&amp;
        <span class="hljs-keyword">this</span>.compare(<span class="hljs-keyword">this</span>.heap[leftChild], <span class="hljs-keyword">this</span>.heap[smallest]) &lt; <span class="hljs-number">0</span>
      ) {
        smallest = leftChild;
      }

      <span class="hljs-keyword">if</span> (
        rightChild &lt; <span class="hljs-keyword">this</span>.heap.length &amp;&amp;
        <span class="hljs-keyword">this</span>.compare(<span class="hljs-keyword">this</span>.heap[rightChild], <span class="hljs-keyword">this</span>.heap[smallest]) &lt; <span class="hljs-number">0</span>
      ) {
        smallest = rightChild;
      }

      <span class="hljs-keyword">if</span> (smallest === index) <span class="hljs-keyword">break</span>;

      [<span class="hljs-keyword">this</span>.heap[index], <span class="hljs-keyword">this</span>.heap[smallest]] = [
        <span class="hljs-keyword">this</span>.heap[smallest],
        <span class="hljs-keyword">this</span>.heap[index],
      ];
      index = smallest;
    }
  }

  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.heap.length;
  }

  isEmpty() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.heap.length === <span class="hljs-number">0</span>;
  }
}

<span class="hljs-comment">/**
 * Trie for Efficient Text Search
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.children = {};
    <span class="hljs-keyword">this</span>.isEndOfWord = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.taskIds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">new</span> TrieNode();
  }

  insert(word, taskId) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> word.toLowerCase()) {
      <span class="hljs-keyword">if</span> (!node.children[char]) {
        node.children[char] = <span class="hljs-keyword">new</span> TrieNode();
      }
      node = node.children[char];
      node.taskIds.add(taskId);
    }

    node.isEndOfWord = <span class="hljs-literal">true</span>;
  }

  search(prefix) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> prefix.toLowerCase()) {
      <span class="hljs-keyword">if</span> (!node.children[char]) {
        <span class="hljs-keyword">return</span> [];
      }
      node = node.children[char];
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(node.taskIds);
  }

  <span class="hljs-keyword">delete</span>(word, taskId) {
    <span class="hljs-keyword">this</span>.deleteHelper(<span class="hljs-keyword">this</span>.root, word.toLowerCase(), <span class="hljs-number">0</span>, taskId);
  }

  deleteHelper(node, word, index, taskId) {
    <span class="hljs-keyword">if</span> (index === word.length) {
      node.isEndOfWord = <span class="hljs-literal">false</span>;
      node.taskIds.delete(taskId);
      <span class="hljs-keyword">return</span> node.taskIds.size === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Object</span>.keys(node.children).length === <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">const</span> char = word[index];
    <span class="hljs-keyword">const</span> childNode = node.children[char];

    <span class="hljs-keyword">if</span> (!childNode) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">const</span> shouldDeleteChild = <span class="hljs-keyword">this</span>.deleteHelper(
      childNode,
      word,
      index + <span class="hljs-number">1</span>,
      taskId
    );

    <span class="hljs-keyword">if</span> (shouldDeleteChild) {
      <span class="hljs-keyword">delete</span> node.children[char];
    }

    childNode.taskIds.delete(taskId);

    <span class="hljs-keyword">return</span> (
      node.taskIds.size === <span class="hljs-number">0</span> &amp;&amp;
      <span class="hljs-built_in">Object</span>.keys(node.children).length === <span class="hljs-number">0</span> &amp;&amp;
      !node.isEndOfWord
    );
  }
}

<span class="hljs-comment">/**
 * Dependency Graph for Task Dependencies
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependencyGraph</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.adjacencyList = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>.inDegree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  }

  addTask(taskId) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.adjacencyList.has(taskId)) {
      <span class="hljs-keyword">this</span>.adjacencyList.set(taskId, []);
      <span class="hljs-keyword">this</span>.inDegree.set(taskId, <span class="hljs-number">0</span>);
    }
  }

  addDependency(fromTask, toTask) {
    <span class="hljs-keyword">this</span>.addTask(fromTask);
    <span class="hljs-keyword">this</span>.addTask(toTask);

    <span class="hljs-keyword">this</span>.adjacencyList.get(fromTask).push(toTask);
    <span class="hljs-keyword">this</span>.inDegree.set(toTask, <span class="hljs-keyword">this</span>.inDegree.get(toTask) + <span class="hljs-number">1</span>);
  }

  removeDependency(fromTask, toTask) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.adjacencyList.has(fromTask)) {
      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-keyword">this</span>.adjacencyList.get(fromTask);
      <span class="hljs-keyword">const</span> index = neighbors.indexOf(toTask);
      <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">-1</span>) {
        neighbors.splice(index, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">this</span>.inDegree.set(toTask, <span class="hljs-keyword">this</span>.inDegree.get(toTask) - <span class="hljs-number">1</span>);
      }
    }
  }

  getTopologicalOrder() {
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">const</span> queue = [];
    <span class="hljs-keyword">const</span> inDegreeMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-keyword">this</span>.inDegree);

    <span class="hljs-comment">// Find all tasks with no dependencies</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [taskId, degree] <span class="hljs-keyword">of</span> inDegreeMap) {
      <span class="hljs-keyword">if</span> (degree === <span class="hljs-number">0</span>) {
        queue.push(taskId);
      }
    }

    <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> current = queue.shift();
      result.push(current);

      <span class="hljs-comment">// Process all dependent tasks</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.adjacencyList.get(current) || []) {
        inDegreeMap.set(neighbor, inDegreeMap.get(neighbor) - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (inDegreeMap.get(neighbor) === <span class="hljs-number">0</span>) {
          queue.push(neighbor);
        }
      }
    }

    <span class="hljs-comment">// Check for cycles</span>
    <span class="hljs-keyword">if</span> (result.length !== <span class="hljs-keyword">this</span>.adjacencyList.size) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Circular dependency detected!"</span>);
    }

    <span class="hljs-keyword">return</span> result;
  }

  hasCycle() {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.getTopologicalOrder();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }

  getReadyTasks() {
    <span class="hljs-keyword">const</span> readyTasks = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [taskId, degree] <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.inDegree) {
      <span class="hljs-keyword">if</span> (degree === <span class="hljs-number">0</span>) {
        readyTasks.push(taskId);
      }
    }
    <span class="hljs-keyword">return</span> readyTasks;
  }
}

<span class="hljs-comment">/**
 * Undo/Redo Stack
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UndoRedoStack</span> </span>{
  <span class="hljs-keyword">constructor</span>(maxSize = 50) {
    <span class="hljs-keyword">this</span>.undoStack = [];
    <span class="hljs-keyword">this</span>.redoStack = [];
    <span class="hljs-keyword">this</span>.maxSize = maxSize;
  }

  execute(command) {
    command.execute();
    <span class="hljs-keyword">this</span>.undoStack.push(command);
    <span class="hljs-keyword">this</span>.redoStack = []; <span class="hljs-comment">// Clear redo stack</span>

    <span class="hljs-comment">// Limit stack size</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.undoStack.length &gt; <span class="hljs-keyword">this</span>.maxSize) {
      <span class="hljs-keyword">this</span>.undoStack.shift();
    }
  }

  undo() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.undoStack.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">const</span> command = <span class="hljs-keyword">this</span>.undoStack.pop();
    command.undo();
    <span class="hljs-keyword">this</span>.redoStack.push(command);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  redo() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.redoStack.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">const</span> command = <span class="hljs-keyword">this</span>.redoStack.pop();
    command.execute();
    <span class="hljs-keyword">this</span>.undoStack.push(command);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  canUndo() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.undoStack.length &gt; <span class="hljs-number">0</span>;
  }

  canRedo() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.redoStack.length &gt; <span class="hljs-number">0</span>;
  }
}

<span class="hljs-comment">// ===== COMMAND PATTERN FOR UNDO/REDO =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span> </span>{
  execute() {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Execute method must be implemented"</span>);
  }

  undo() {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Undo method must be implemented"</span>);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateTaskCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Command</span> </span>{
  <span class="hljs-keyword">constructor</span>(taskManager, task) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.taskManager = taskManager;
    <span class="hljs-keyword">this</span>.task = task;
  }

  execute() {
    <span class="hljs-keyword">this</span>.taskManager.addTaskDirect(<span class="hljs-keyword">this</span>.task);
  }

  undo() {
    <span class="hljs-keyword">this</span>.taskManager.deleteTaskDirect(<span class="hljs-keyword">this</span>.task.id);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateTaskCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Command</span> </span>{
  <span class="hljs-keyword">constructor</span>(taskManager, taskId, oldData, newData) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.taskManager = taskManager;
    <span class="hljs-keyword">this</span>.taskId = taskId;
    <span class="hljs-keyword">this</span>.oldData = oldData;
    <span class="hljs-keyword">this</span>.newData = newData;
  }

  execute() {
    <span class="hljs-keyword">this</span>.taskManager.updateTaskDirect(<span class="hljs-keyword">this</span>.taskId, <span class="hljs-keyword">this</span>.newData);
  }

  undo() {
    <span class="hljs-keyword">this</span>.taskManager.updateTaskDirect(<span class="hljs-keyword">this</span>.taskId, <span class="hljs-keyword">this</span>.oldData);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeleteTaskCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Command</span> </span>{
  <span class="hljs-keyword">constructor</span>(taskManager, task) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.taskManager = taskManager;
    <span class="hljs-keyword">this</span>.task = task;
  }

  execute() {
    <span class="hljs-keyword">this</span>.taskManager.deleteTaskDirect(<span class="hljs-keyword">this</span>.task.id);
  }

  undo() {
    <span class="hljs-keyword">this</span>.taskManager.addTaskDirect(<span class="hljs-keyword">this</span>.task);
  }
}

<span class="hljs-comment">// ===== MAIN TASK MANAGEMENT SYSTEM =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskManagementSystem</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.tasks = <span class="hljs-keyword">new</span> TaskHashTable();
    <span class="hljs-keyword">this</span>.priorityQueue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.priority - a.priority);
    <span class="hljs-keyword">this</span>.searchTrie = <span class="hljs-keyword">new</span> Trie();
    <span class="hljs-keyword">this</span>.dependencyGraph = <span class="hljs-keyword">new</span> DependencyGraph();
    <span class="hljs-keyword">this</span>.undoRedoStack = <span class="hljs-keyword">new</span> UndoRedoStack();
    <span class="hljs-keyword">this</span>.taskIdCounter = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">this</span>.analytics = <span class="hljs-keyword">new</span> TaskAnalytics();
  }

  <span class="hljs-comment">// ===== TASK CRUD OPERATIONS =====</span>

  createTask(title, description, priority = <span class="hljs-number">1</span>, estimatedTime = <span class="hljs-number">1</span>, tags = []) {
    <span class="hljs-keyword">const</span> taskId = <span class="hljs-string">`task_<span class="hljs-subst">${<span class="hljs-keyword">this</span>.taskIdCounter++}</span>`</span>;
    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">new</span> Task(
      taskId,
      title,
      description,
      priority,
      estimatedTime,
      tags
    );

    <span class="hljs-keyword">const</span> command = <span class="hljs-keyword">new</span> CreateTaskCommand(<span class="hljs-keyword">this</span>, task);
    <span class="hljs-keyword">this</span>.undoRedoStack.execute(command);

    <span class="hljs-keyword">return</span> task;
  }

  addTaskDirect(task) {
    <span class="hljs-keyword">this</span>.tasks.put(task.id, task);
    <span class="hljs-keyword">this</span>.priorityQueue.enqueue(task);
    <span class="hljs-keyword">this</span>.dependencyGraph.addTask(task.id);

    <span class="hljs-comment">// Index for search</span>
    <span class="hljs-keyword">this</span>.indexTaskForSearch(task);

    <span class="hljs-comment">// Update analytics</span>
    <span class="hljs-keyword">this</span>.analytics.addTask(task);
  }

  updateTask(taskId, updates) {
    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">this</span>.tasks.get(taskId);
    <span class="hljs-keyword">if</span> (!task) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Task <span class="hljs-subst">${taskId}</span> not found`</span>);

    <span class="hljs-keyword">const</span> oldData = { ...task };
    <span class="hljs-keyword">const</span> command = <span class="hljs-keyword">new</span> UpdateTaskCommand(<span class="hljs-keyword">this</span>, taskId, oldData, updates);
    <span class="hljs-keyword">this</span>.undoRedoStack.execute(command);

    <span class="hljs-keyword">return</span> task;
  }

  updateTaskDirect(taskId, updates) {
    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">this</span>.tasks.get(taskId);
    <span class="hljs-keyword">if</span> (!task) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// Remove old search indices</span>
    <span class="hljs-keyword">this</span>.removeTaskFromSearch(task);

    <span class="hljs-comment">// Update task properties</span>
    <span class="hljs-built_in">Object</span>.assign(task, updates);
    task.updatedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

    <span class="hljs-comment">// Re-index for search</span>
    <span class="hljs-keyword">this</span>.indexTaskForSearch(task);

    <span class="hljs-comment">// Update analytics</span>
    <span class="hljs-keyword">this</span>.analytics.updateTask(task);
  }

  deleteTask(taskId) {
    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">this</span>.tasks.get(taskId);
    <span class="hljs-keyword">if</span> (!task) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Task <span class="hljs-subst">${taskId}</span> not found`</span>);

    <span class="hljs-keyword">const</span> command = <span class="hljs-keyword">new</span> DeleteTaskCommand(<span class="hljs-keyword">this</span>, task);
    <span class="hljs-keyword">this</span>.undoRedoStack.execute(command);

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  deleteTaskDirect(taskId) {
    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">this</span>.tasks.get(taskId);
    <span class="hljs-keyword">if</span> (!task) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">this</span>.tasks.delete(taskId);
    <span class="hljs-keyword">this</span>.removeTaskFromSearch(task);

    <span class="hljs-comment">// Remove from dependency graph</span>
    <span class="hljs-keyword">this</span>.dependencyGraph.adjacencyList.delete(taskId);
    <span class="hljs-keyword">this</span>.dependencyGraph.inDegree.delete(taskId);

    <span class="hljs-comment">// Update analytics</span>
    <span class="hljs-keyword">this</span>.analytics.removeTask(task);
  }

  getTask(taskId) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tasks.get(taskId);
  }

  getAllTasks() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tasks.getAllValues();
  }

  <span class="hljs-comment">// ===== SEARCH AND FILTERING =====</span>

  indexTaskForSearch(task) {
    <span class="hljs-comment">// Index title and description words</span>
    <span class="hljs-keyword">const</span> words = [
      ...task.title.split(<span class="hljs-regexp">/\s+/</span>),
      ...task.description.split(<span class="hljs-regexp">/\s+/</span>),
    ];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> word <span class="hljs-keyword">of</span> words) {
      <span class="hljs-keyword">if</span> (word.length &gt; <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">this</span>.searchTrie.insert(word, task.id);
      }
    }

    <span class="hljs-comment">// Index tags</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> tag <span class="hljs-keyword">of</span> task.tags) {
      <span class="hljs-keyword">this</span>.searchTrie.insert(tag, task.id);
    }
  }

  removeTaskFromSearch(task) {
    <span class="hljs-keyword">const</span> words = [
      ...task.title.split(<span class="hljs-regexp">/\s+/</span>),
      ...task.description.split(<span class="hljs-regexp">/\s+/</span>),
    ];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> word <span class="hljs-keyword">of</span> words) {
      <span class="hljs-keyword">if</span> (word.length &gt; <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">this</span>.searchTrie.delete(word, task.id);
      }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> tag <span class="hljs-keyword">of</span> task.tags) {
      <span class="hljs-keyword">this</span>.searchTrie.delete(tag, task.id);
    }
  }

  searchTasks(query) {
    <span class="hljs-keyword">const</span> taskIds = <span class="hljs-keyword">this</span>.searchTrie.search(query);
    <span class="hljs-keyword">return</span> taskIds
      .map(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-keyword">this</span>.tasks.get(id))
      .filter(<span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> task !== <span class="hljs-literal">null</span>);
  }

  filterTasks(criteria) {
    <span class="hljs-keyword">const</span> allTasks = <span class="hljs-keyword">this</span>.getAllTasks();

    <span class="hljs-keyword">return</span> allTasks.filter(<span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (criteria.status &amp;&amp; task.status !== criteria.status) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (criteria.priority &amp;&amp; task.priority !== criteria.priority)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (criteria.assignee &amp;&amp; task.assignee !== criteria.assignee)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (criteria.tag &amp;&amp; !task.tags.has(criteria.tag)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (criteria.minPriority &amp;&amp; task.priority &lt; criteria.minPriority)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (criteria.maxPriority &amp;&amp; task.priority &gt; criteria.maxPriority)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    });
  }

  <span class="hljs-comment">// ===== DEPENDENCY MANAGEMENT =====</span>

  addDependency(fromTaskId, toTaskId) {
    <span class="hljs-keyword">const</span> fromTask = <span class="hljs-keyword">this</span>.tasks.get(fromTaskId);
    <span class="hljs-keyword">const</span> toTask = <span class="hljs-keyword">this</span>.tasks.get(toTaskId);

    <span class="hljs-keyword">if</span> (!fromTask || !toTask) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"One or both tasks not found"</span>);
    }

    <span class="hljs-keyword">this</span>.dependencyGraph.addDependency(fromTaskId, toTaskId);

    <span class="hljs-comment">// Check for cycles</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dependencyGraph.hasCycle()) {
      <span class="hljs-keyword">this</span>.dependencyGraph.removeDependency(fromTaskId, toTaskId);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Adding this dependency would create a cycle"</span>);
    }

    fromTask.addDependent(toTaskId);
    toTask.addDependency(fromTaskId);
  }

  removeDependency(fromTaskId, toTaskId) {
    <span class="hljs-keyword">this</span>.dependencyGraph.removeDependency(fromTaskId, toTaskId);

    <span class="hljs-keyword">const</span> fromTask = <span class="hljs-keyword">this</span>.tasks.get(fromTaskId);
    <span class="hljs-keyword">const</span> toTask = <span class="hljs-keyword">this</span>.tasks.get(toTaskId);

    <span class="hljs-keyword">if</span> (fromTask) fromTask.dependents.delete(toTaskId);
    <span class="hljs-keyword">if</span> (toTask) toTask.dependencies.delete(fromTaskId);
  }

  getTaskExecutionOrder() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dependencyGraph.getTopologicalOrder();
  }

  getReadyTasks() {
    <span class="hljs-keyword">const</span> readyTaskIds = <span class="hljs-keyword">this</span>.dependencyGraph.getReadyTasks();
    <span class="hljs-keyword">return</span> readyTaskIds
      .map(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> <span class="hljs-keyword">this</span>.tasks.get(id))
      .filter(<span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> task &amp;&amp; task.status === <span class="hljs-string">"pending"</span>);
  }

  <span class="hljs-comment">// ===== SCHEDULING AND OPTIMIZATION =====</span>

  getNextTaskByPriority() {
    <span class="hljs-keyword">const</span> readyTasks = <span class="hljs-keyword">this</span>.getReadyTasks();
    <span class="hljs-keyword">if</span> (readyTasks.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-comment">// Sort by priority (descending) then by creation time (ascending)</span>
    readyTasks.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (a.priority !== b.priority) {
        <span class="hljs-keyword">return</span> b.priority - a.priority;
      }
      <span class="hljs-keyword">return</span> a.createdAt - b.createdAt;
    });

    <span class="hljs-keyword">return</span> readyTasks[<span class="hljs-number">0</span>];
  }

  scheduleTasksGreedy(availableHours) {
    <span class="hljs-keyword">const</span> readyTasks = <span class="hljs-keyword">this</span>.getReadyTasks();

    <span class="hljs-comment">// Sort by value-to-time ratio (priority / estimated time)</span>
    readyTasks.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> ratioA = a.priority / a.estimatedTime;
      <span class="hljs-keyword">const</span> ratioB = b.priority / b.estimatedTime;
      <span class="hljs-keyword">return</span> ratioB - ratioA;
    });

    <span class="hljs-keyword">const</span> schedule = [];
    <span class="hljs-keyword">let</span> remainingHours = availableHours;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> readyTasks) {
      <span class="hljs-keyword">if</span> (task.estimatedTime &lt;= remainingHours) {
        schedule.push(task);
        remainingHours -= task.estimatedTime;
      }
    }

    <span class="hljs-keyword">return</span> {
      schedule,
      <span class="hljs-attr">totalTime</span>: availableHours - remainingHours,
      <span class="hljs-attr">remainingTime</span>: remainingHours,
    };
  }

  optimizeTaskOrder() {
    <span class="hljs-comment">// Use dynamic programming to find optimal task completion order</span>
    <span class="hljs-keyword">const</span> tasks = <span class="hljs-keyword">this</span>.getAllTasks().filter(
      <span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> task.status === <span class="hljs-string">"pending"</span>
    );
    <span class="hljs-keyword">const</span> n = tasks.length;

    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];

    <span class="hljs-comment">// DP state: dp[mask] = minimum time to complete tasks in mask</span>
    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span> &lt;&lt; n).fill(<span class="hljs-literal">Infinity</span>);
    <span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span> &lt;&lt; n).fill(<span class="hljs-number">-1</span>);
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> mask = <span class="hljs-number">0</span>; mask &lt; <span class="hljs-number">1</span> &lt;&lt; n; mask++) {
      <span class="hljs-keyword">if</span> (dp[mask] === <span class="hljs-literal">Infinity</span>) <span class="hljs-keyword">continue</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">if</span> (mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Task already completed</span>

        <span class="hljs-comment">// Check if dependencies are satisfied</span>
        <span class="hljs-keyword">let</span> canExecute = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
          <span class="hljs-keyword">if</span> (tasks[i].dependencies.has(tasks[j].id) &amp;&amp; !(mask &amp; (<span class="hljs-number">1</span> &lt;&lt; j))) {
            canExecute = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">if</span> (canExecute) {
          <span class="hljs-keyword">const</span> newMask = mask | (<span class="hljs-number">1</span> &lt;&lt; i);
          <span class="hljs-keyword">const</span> newTime = dp[mask] + tasks[i].estimatedTime;

          <span class="hljs-keyword">if</span> (newTime &lt; dp[newMask]) {
            dp[newMask] = newTime;
            parent[newMask] = mask;
          }
        }
      }
    }

    <span class="hljs-comment">// Reconstruct optimal order</span>
    <span class="hljs-keyword">const</span> order = [];
    <span class="hljs-keyword">let</span> currentMask = (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (currentMask &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> prevMask = parent[currentMask];
      <span class="hljs-keyword">const</span> taskIndex = <span class="hljs-built_in">Math</span>.log2(currentMask ^ prevMask);
      order.unshift(tasks[taskIndex]);
      currentMask = prevMask;
    }

    <span class="hljs-keyword">return</span> order;
  }

  <span class="hljs-comment">// ===== UNDO/REDO OPERATIONS =====</span>

  undo() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.undoRedoStack.undo();
  }

  redo() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.undoRedoStack.redo();
  }

  canUndo() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.undoRedoStack.canUndo();
  }

  canRedo() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.undoRedoStack.canRedo();
  }

  <span class="hljs-comment">// ===== ANALYTICS AND REPORTING =====</span>

  getAnalytics() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.analytics.generateReport();
  }

  getTaskStatistics() {
    <span class="hljs-keyword">const</span> tasks = <span class="hljs-keyword">this</span>.getAllTasks();
    <span class="hljs-keyword">const</span> stats = {
      <span class="hljs-attr">total</span>: tasks.length,
      <span class="hljs-attr">pending</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">inProgress</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">completed</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">cancelled</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">averagePriority</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">totalEstimatedTime</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">totalActualTime</span>: <span class="hljs-number">0</span>,
    };

    <span class="hljs-keyword">let</span> prioritySum = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> tasks) {
      stats[task.status]++;
      prioritySum += task.priority;
      stats.totalEstimatedTime += task.estimatedTime;
      stats.totalActualTime += task.actualTime;
    }

    stats.averagePriority = tasks.length &gt; <span class="hljs-number">0</span> ? prioritySum / tasks.length : <span class="hljs-number">0</span>;
    stats.efficiency =
      stats.totalActualTime &gt; <span class="hljs-number">0</span>
        ? stats.totalEstimatedTime / stats.totalActualTime
        : <span class="hljs-number">1</span>;

    <span class="hljs-keyword">return</span> stats;
  }
}

<span class="hljs-comment">// ===== ANALYTICS MODULE =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskAnalytics</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.taskHistory = [];
    <span class="hljs-keyword">this</span>.completionTimes = [];
    <span class="hljs-keyword">this</span>.priorityDistribution = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  }

  addTask(task) {
    <span class="hljs-keyword">this</span>.taskHistory.push({
      <span class="hljs-attr">action</span>: <span class="hljs-string">"created"</span>,
      <span class="hljs-attr">taskId</span>: task.id,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
      <span class="hljs-attr">data</span>: { ...task },
    });

    <span class="hljs-keyword">this</span>.updatePriorityDistribution(task.priority, <span class="hljs-number">1</span>);
  }

  updateTask(task) {
    <span class="hljs-keyword">this</span>.taskHistory.push({
      <span class="hljs-attr">action</span>: <span class="hljs-string">"updated"</span>,
      <span class="hljs-attr">taskId</span>: task.id,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
      <span class="hljs-attr">data</span>: { ...task },
    });

    <span class="hljs-keyword">if</span> (task.status === <span class="hljs-string">"completed"</span> &amp;&amp; task.completedAt) {
      <span class="hljs-keyword">const</span> completionTime = task.completedAt - task.createdAt;
      <span class="hljs-keyword">this</span>.completionTimes.push(completionTime);
    }
  }

  removeTask(task) {
    <span class="hljs-keyword">this</span>.taskHistory.push({
      <span class="hljs-attr">action</span>: <span class="hljs-string">"deleted"</span>,
      <span class="hljs-attr">taskId</span>: task.id,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
      <span class="hljs-attr">data</span>: { ...task },
    });

    <span class="hljs-keyword">this</span>.updatePriorityDistribution(task.priority, <span class="hljs-number">-1</span>);
  }

  updatePriorityDistribution(priority, delta) {
    <span class="hljs-keyword">const</span> current = <span class="hljs-keyword">this</span>.priorityDistribution.get(priority) || <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.priorityDistribution.set(priority, current + delta);
  }

  generateReport() {
    <span class="hljs-keyword">const</span> report = {
      <span class="hljs-attr">totalActions</span>: <span class="hljs-keyword">this</span>.taskHistory.length,
      <span class="hljs-attr">averageCompletionTime</span>: <span class="hljs-keyword">this</span>.getAverageCompletionTime(),
      <span class="hljs-attr">priorityDistribution</span>: <span class="hljs-built_in">Object</span>.fromEntries(<span class="hljs-keyword">this</span>.priorityDistribution),
      <span class="hljs-attr">productivityTrend</span>: <span class="hljs-keyword">this</span>.getProductivityTrend(),
      <span class="hljs-attr">recentActivity</span>: <span class="hljs-keyword">this</span>.getRecentActivity(<span class="hljs-number">10</span>),
    };

    <span class="hljs-keyword">return</span> report;
  }

  getAverageCompletionTime() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.completionTimes.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> sum = <span class="hljs-keyword">this</span>.completionTimes.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> sum / <span class="hljs-keyword">this</span>.completionTimes.length;
  }

  getProductivityTrend() {
    <span class="hljs-comment">// Calculate tasks completed per day for last 30 days</span>
    <span class="hljs-keyword">const</span> thirtyDaysAgo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.now() - <span class="hljs-number">30</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);
    <span class="hljs-keyword">const</span> completedTasks = <span class="hljs-keyword">this</span>.taskHistory.filter(
      <span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span>
        entry.action === <span class="hljs-string">"updated"</span> &amp;&amp;
        entry.data.status === <span class="hljs-string">"completed"</span> &amp;&amp;
        entry.timestamp &gt;= thirtyDaysAgo
    );

    <span class="hljs-keyword">const</span> dailyCompletion = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> completedTasks) {
      <span class="hljs-keyword">const</span> date = task.timestamp.toDateString();
      dailyCompletion.set(date, (dailyCompletion.get(date) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.fromEntries(dailyCompletion);
  }

  getRecentActivity(limit = <span class="hljs-number">10</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.taskHistory
      .slice(-limit)
      .reverse()
      .map(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> ({
        <span class="hljs-attr">action</span>: entry.action,
        <span class="hljs-attr">taskId</span>: entry.taskId,
        <span class="hljs-attr">timestamp</span>: entry.timestamp,
        <span class="hljs-attr">title</span>: entry.data.title,
      }));
  }
}

<span class="hljs-comment">// ===== EXAMPLE USAGE AND TESTING =====</span>

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"=== Task Management System Demo ==="</span>);

<span class="hljs-comment">// Create task management system</span>
<span class="hljs-keyword">const</span> tms = <span class="hljs-keyword">new</span> TaskManagementSystem();

<span class="hljs-comment">// Create sample tasks</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Creating Tasks ==="</span>);
<span class="hljs-keyword">const</span> task1 = tms.createTask(
  <span class="hljs-string">"Design Database Schema"</span>,
  <span class="hljs-string">"Create ERD and table structures"</span>,
  <span class="hljs-number">4</span>,
  <span class="hljs-number">8</span>,
  [<span class="hljs-string">"database"</span>, <span class="hljs-string">"design"</span>]
);
<span class="hljs-keyword">const</span> task2 = tms.createTask(
  <span class="hljs-string">"Implement User Authentication"</span>,
  <span class="hljs-string">"Build login/logout functionality"</span>,
  <span class="hljs-number">5</span>,
  <span class="hljs-number">12</span>,
  [<span class="hljs-string">"backend"</span>, <span class="hljs-string">"security"</span>]
);
<span class="hljs-keyword">const</span> task3 = tms.createTask(
  <span class="hljs-string">"Create API Endpoints"</span>,
  <span class="hljs-string">"Build REST API for user management"</span>,
  <span class="hljs-number">4</span>,
  <span class="hljs-number">16</span>,
  [<span class="hljs-string">"backend"</span>, <span class="hljs-string">"api"</span>]
);
<span class="hljs-keyword">const</span> task4 = tms.createTask(
  <span class="hljs-string">"Design UI Mockups"</span>,
  <span class="hljs-string">"Create wireframes and mockups"</span>,
  <span class="hljs-number">3</span>,
  <span class="hljs-number">6</span>,
  [<span class="hljs-string">"frontend"</span>, <span class="hljs-string">"design"</span>]
);
<span class="hljs-keyword">const</span> task5 = tms.createTask(
  <span class="hljs-string">"Write Unit Tests"</span>,
  <span class="hljs-string">"Create comprehensive test suite"</span>,
  <span class="hljs-number">3</span>,
  <span class="hljs-number">10</span>,
  [<span class="hljs-string">"testing"</span>, <span class="hljs-string">"quality"</span>]
);

<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Created tasks:"</span>,
  [task1, task2, task3, task4, task5].map(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> t.title)
);

<span class="hljs-comment">// Add dependencies</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Adding Dependencies ==="</span>);
<span class="hljs-keyword">try</span> {
  tms.addDependency(task1.id, task2.id); <span class="hljs-comment">// Auth depends on DB</span>
  tms.addDependency(task1.id, task3.id); <span class="hljs-comment">// API depends on DB</span>
  tms.addDependency(task2.id, task3.id); <span class="hljs-comment">// API depends on Auth</span>
  tms.addDependency(task4.id, task5.id); <span class="hljs-comment">// Tests depend on UI</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Dependencies added successfully"</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"Error adding dependencies:"</span>, error.message);
}

<span class="hljs-comment">// Get execution order</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Task Execution Order ==="</span>);
<span class="hljs-keyword">const</span> executionOrder = tms.getTaskExecutionOrder();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Optimal execution order:"</span>, executionOrder);

<span class="hljs-comment">// Get ready tasks</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Ready Tasks ==="</span>);
<span class="hljs-keyword">const</span> readyTasks = tms.getReadyTasks();
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Tasks ready to start:"</span>,
  readyTasks.map(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> t.title)
);

<span class="hljs-comment">// Search functionality</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Search Functionality ==="</span>);
<span class="hljs-keyword">const</span> searchResults = tms.searchTasks(<span class="hljs-string">"design"</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'Search results for "design":'</span>,
  searchResults.map(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> t.title)
);

<span class="hljs-comment">// Filter tasks</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Filter Tasks ==="</span>);
<span class="hljs-keyword">const</span> highPriorityTasks = tms.filterTasks({ <span class="hljs-attr">minPriority</span>: <span class="hljs-number">4</span> });
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"High priority tasks:"</span>,
  highPriorityTasks.map(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${t.title}</span> (Priority: <span class="hljs-subst">${t.priority}</span>)`</span>)
);

<span class="hljs-keyword">const</span> backendTasks = tms.filterTasks({ <span class="hljs-attr">tag</span>: <span class="hljs-string">"backend"</span> });
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Backend tasks:"</span>,
  backendTasks.map(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> t.title)
);

<span class="hljs-comment">// Schedule tasks with greedy algorithm</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Greedy Scheduling ==="</span>);
<span class="hljs-keyword">const</span> schedule = tms.scheduleTasksGreedy(<span class="hljs-number">20</span>); <span class="hljs-comment">// 20 hours available</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Greedy schedule for 20 hours:"</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Selected tasks:"</span>,
  schedule.schedule.map(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${t.title}</span> (<span class="hljs-subst">${t.estimatedTime}</span>h)`</span>)
);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Total time used:"</span>, schedule.totalTime, <span class="hljs-string">"hours"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Remaining time:"</span>, schedule.remainingTime, <span class="hljs-string">"hours"</span>);

<span class="hljs-comment">// Get next task by priority</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Priority-based Next Task ==="</span>);
<span class="hljs-keyword">const</span> nextTask = tms.getNextTaskByPriority();
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"Next task to work on:"</span>,
  nextTask ? nextTask.title : <span class="hljs-string">"No tasks available"</span>
);

<span class="hljs-comment">// Update task status</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Update Task Status ==="</span>);
tms.updateTask(task1.id, { <span class="hljs-attr">status</span>: <span class="hljs-string">"completed"</span>, <span class="hljs-attr">actualTime</span>: <span class="hljs-number">7</span> });
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Updated task1 status to completed"</span>);

<span class="hljs-comment">// Check ready tasks after completion</span>
<span class="hljs-keyword">const</span> newReadyTasks = tms.getReadyTasks();
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"New ready tasks after task1 completion:"</span>,
  newReadyTasks.map(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> t.title)
);

<span class="hljs-comment">// Undo/Redo functionality</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Undo/Redo Functionality ==="</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Can undo:"</span>, tms.canUndo());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Can redo:"</span>, tms.canRedo());

<span class="hljs-keyword">if</span> (tms.canUndo()) {
  tms.undo();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Undid last action"</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Task1 status after undo:"</span>, tms.getTask(task1.id).status);
}

<span class="hljs-keyword">if</span> (tms.canRedo()) {
  tms.redo();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Redid last action"</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Task1 status after redo:"</span>, tms.getTask(task1.id).status);
}

<span class="hljs-comment">// Get statistics</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Task Statistics ==="</span>);
<span class="hljs-keyword">const</span> stats = tms.getTaskStatistics();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Task statistics:"</span>, stats);

<span class="hljs-comment">// Get analytics</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Analytics Report ==="</span>);
<span class="hljs-keyword">const</span> analytics = tms.getAnalytics();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Analytics report:"</span>, analytics);

<span class="hljs-comment">// Optimize task order using DP</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Optimal Task Order (DP) ==="</span>);
<span class="hljs-keyword">const</span> optimalOrder = tms.optimizeTaskOrder();
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">"DP-optimized task order:"</span>,
  optimalOrder.map(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> t.title)
);

<span class="hljs-comment">// Performance testing</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Performance Testing ==="</span>);
<span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Create 1000 tasks"</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  tms.createTask(
    <span class="hljs-string">`Task <span class="hljs-subst">${i}</span>`</span>,
    <span class="hljs-string">`Description for task <span class="hljs-subst">${i}</span>`</span>,
    <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">5</span>) + <span class="hljs-number">1</span>
  );
}
<span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Create 1000 tasks"</span>);

<span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Search in 1000+ tasks"</span>);
<span class="hljs-keyword">const</span> largeSearchResults = tms.searchTasks(<span class="hljs-string">"task"</span>);
<span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Search in 1000+ tasks"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Search results count:"</span>, largeSearchResults.length);

<span class="hljs-built_in">console</span>.time(<span class="hljs-string">"Filter 1000+ tasks"</span>);
<span class="hljs-keyword">const</span> filteredResults = tms.filterTasks({ <span class="hljs-attr">minPriority</span>: <span class="hljs-number">4</span> });
<span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">"Filter 1000+ tasks"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Filtered results count:"</span>, filteredResults.length);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n=== Task Management System Demo Complete ==="</span>);
</div></code></pre>
<hr>
<h2 id="%F0%9F%94%A7-c-implementation">🔧 C++ Implementation</h2>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::chrono;

<span class="hljs-comment">// ===== TASK ENTITY =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">string</span> id;
    <span class="hljs-built_in">string</span> title;
    <span class="hljs-built_in">string</span> description;
    <span class="hljs-keyword">int</span> priority;
    <span class="hljs-keyword">int</span> estimatedTime;
    <span class="hljs-keyword">int</span> actualTime;
    <span class="hljs-built_in">string</span> status; <span class="hljs-comment">// "pending", "in-progress", "completed", "cancelled"</span>
    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; tags;
    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; dependencies;
    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; dependents;
    time_point&lt;system_clock&gt; createdAt;
    time_point&lt;system_clock&gt; updatedAt;
    time_point&lt;system_clock&gt; completedAt;
    <span class="hljs-built_in">string</span> assignee;

    Task(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; id, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; title, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; description,
         <span class="hljs-keyword">int</span> priority = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> estimatedTime = <span class="hljs-number">1</span>)
        : id(id), title(title), description(description), priority(priority),
          estimatedTime(estimatedTime), actualTime(<span class="hljs-number">0</span>), status(<span class="hljs-string">"pending"</span>),
          createdAt(system_clock::now()), updatedAt(system_clock::now()) {}

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDependency</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; taskId)</span> </span>{
        dependencies.insert(taskId);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDependent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; taskId)</span> </span>{
        dependents.insert(taskId);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; newStatus)</span> </span>{
        status = newStatus;
        updatedAt = system_clock::now();
        <span class="hljs-keyword">if</span> (newStatus == <span class="hljs-string">"completed"</span>) {
            completedAt = system_clock::now();
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addTag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; tag)</span> </span>{
        tags.insert(tag);
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBlocked</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> !dependencies.empty();
    }

    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getEfficiency</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">if</span> (actualTime == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(estimatedTime) / actualTime;
    }
};

<span class="hljs-comment">// ===== PRIORITY QUEUE FOR TASK SCHEDULING =====</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TaskComparator</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&amp; b)</span> </span>{
        <span class="hljs-keyword">if</span> (a-&gt;priority != b-&gt;priority) {
            <span class="hljs-keyword">return</span> a-&gt;priority &lt; b-&gt;priority; <span class="hljs-comment">// Max heap by priority</span>
        }
        <span class="hljs-keyword">return</span> a-&gt;createdAt &gt; b-&gt;createdAt; <span class="hljs-comment">// Earlier tasks first</span>
    }
};

<span class="hljs-comment">// ===== DEPENDENCY GRAPH =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependencyGraph</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; adjacencyList;
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; inDegree;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; taskId)</span> </span>{
        <span class="hljs-keyword">if</span> (adjacencyList.find(taskId) == adjacencyList.end()) {
            adjacencyList[taskId] = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;();
            inDegree[taskId] = <span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDependency</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; fromTask, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; toTask)</span> </span>{
        addTask(fromTask);
        addTask(toTask);

        adjacencyList[fromTask].push_back(toTask);
        inDegree[toTask]++;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeDependency</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; fromTask, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; toTask)</span> </span>{
        <span class="hljs-keyword">auto</span>&amp; neighbors = adjacencyList[fromTask];
        <span class="hljs-keyword">auto</span> it = find(neighbors.begin(), neighbors.end(), toTask);
        <span class="hljs-keyword">if</span> (it != neighbors.end()) {
            neighbors.erase(it);
            inDegree[toTask]--;
        }
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">getTopologicalOrder</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; result;
        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">string</span>&gt; q;
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; tempInDegree = inDegree;

        <span class="hljs-comment">// Find all tasks with no dependencies</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : tempInDegree) {
            <span class="hljs-keyword">if</span> (pair.second == <span class="hljs-number">0</span>) {
                q.push(pair.first);
            }
        }

        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-built_in">string</span> current = q.front();
            q.pop();
            result.push_back(current);

            <span class="hljs-comment">// Process all dependent tasks</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; neighbor : adjacencyList[current]) {
                tempInDegree[neighbor]--;
                <span class="hljs-keyword">if</span> (tempInDegree[neighbor] == <span class="hljs-number">0</span>) {
                    q.push(neighbor);
                }
            }
        }

        <span class="hljs-comment">// Check for cycles</span>
        <span class="hljs-keyword">if</span> (result.size() != adjacencyList.size()) {
            <span class="hljs-keyword">throw</span> runtime_error(<span class="hljs-string">"Circular dependency detected!"</span>);
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">getReadyTasks</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; readyTasks;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : inDegree) {
            <span class="hljs-keyword">if</span> (pair.second == <span class="hljs-number">0</span>) {
                readyTasks.push_back(pair.first);
            }
        }
        <span class="hljs-keyword">return</span> readyTasks;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            getTopologicalOrder();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> runtime_error&amp;) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }
};

<span class="hljs-comment">// ===== TRIE FOR TEXT SEARCH =====</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> {</span>
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt;&gt; children;
    <span class="hljs-keyword">bool</span> isEndOfWord;
    <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-built_in">string</span>&gt; taskIds;

    TrieNode() : isEndOfWord(<span class="hljs-literal">false</span>) {}
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; root;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toLowerCase</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; str)</span> </span>{
        transform(str.begin(), str.end(), str.begin(), ::<span class="hljs-built_in">tolower</span>);
    }

<span class="hljs-keyword">public</span>:
    Trie() : root(make_unique&lt;TrieNode&gt;()) {}

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; taskId)</span> </span>{
        toLowerCase(word);
        TrieNode* node = root.get();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word) {
            <span class="hljs-keyword">if</span> (node-&gt;children.find(c) == node-&gt;children.end()) {
                node-&gt;children[c] = make_unique&lt;TrieNode&gt;();
            }
            node = node-&gt;children[c].get();
            node-&gt;taskIds.insert(taskId);
        }

        node-&gt;isEndOfWord = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span> </span>{
        toLowerCase(prefix);
        TrieNode* node = root.get();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : prefix) {
            <span class="hljs-keyword">if</span> (node-&gt;children.find(c) == node-&gt;children.end()) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;();
            }
            node = node-&gt;children[c].get();
        }

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;(node-&gt;taskIds.begin(), node-&gt;taskIds.end());
    }
};

<span class="hljs-comment">// ===== MAIN TASK MANAGEMENT SYSTEM =====</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskManagementSystem</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; tasks;
    priority_queue&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt;, TaskComparator&gt; priorityQueue;
    Trie searchTrie;
    DependencyGraph dependencyGraph;
    <span class="hljs-keyword">int</span> taskIdCounter;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">indexTaskForSearch</span><span class="hljs-params">(<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt; task)</span> </span>{
        <span class="hljs-comment">// Index title words</span>
        <span class="hljs-function"><span class="hljs-built_in">istringstream</span> <span class="hljs-title">titleStream</span><span class="hljs-params">(task-&gt;title)</span></span>;
        <span class="hljs-built_in">string</span> word;
        <span class="hljs-keyword">while</span> (titleStream &gt;&gt; word) {
            <span class="hljs-keyword">if</span> (word.length() &gt; <span class="hljs-number">2</span>) {
                searchTrie.insert(word, task-&gt;id);
            }
        }

        <span class="hljs-comment">// Index description words</span>
        <span class="hljs-function"><span class="hljs-built_in">istringstream</span> <span class="hljs-title">descStream</span><span class="hljs-params">(task-&gt;description)</span></span>;
        <span class="hljs-keyword">while</span> (descStream &gt;&gt; word) {
            <span class="hljs-keyword">if</span> (word.length() &gt; <span class="hljs-number">2</span>) {
                searchTrie.insert(word, task-&gt;id);
            }
        }

        <span class="hljs-comment">// Index tags</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; tag : task-&gt;tags) {
            searchTrie.insert(tag, task-&gt;id);
        }
    }

<span class="hljs-keyword">public</span>:
    TaskManagementSystem() : taskIdCounter(<span class="hljs-number">1</span>) {}

    <span class="hljs-comment">// ===== TASK CRUD OPERATIONS =====</span>

    <span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Task&gt; <span class="hljs-title">createTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; title, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; description,
                               <span class="hljs-keyword">int</span> priority = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> estimatedTime = <span class="hljs-number">1</span>)</span> </span>{
        <span class="hljs-built_in">string</span> taskId = <span class="hljs-string">"task_"</span> + to_string(taskIdCounter++);
        <span class="hljs-keyword">auto</span> task = make_shared&lt;Task&gt;(taskId, title, description, priority, estimatedTime);

        tasks[taskId] = task;
        priorityQueue.push(task);
        dependencyGraph.addTask(taskId);
        indexTaskForSearch(task);

        <span class="hljs-keyword">return</span> task;
    }

    <span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Task&gt; <span class="hljs-title">getTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; taskId)</span> </span>{
        <span class="hljs-keyword">auto</span> it = tasks.find(taskId);
        <span class="hljs-keyword">return</span> (it != tasks.end()) ? it-&gt;second : <span class="hljs-literal">nullptr</span>;
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; <span class="hljs-title">getAllTasks</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; allTasks;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : tasks) {
            allTasks.push_back(pair.second);
        }
        <span class="hljs-keyword">return</span> allTasks;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">updateTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; taskId, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; field, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; value)</span> </span>{
        <span class="hljs-keyword">auto</span> task = getTask(taskId);
        <span class="hljs-keyword">if</span> (!task) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (field == <span class="hljs-string">"status"</span>) {
            task-&gt;updateStatus(value);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field == <span class="hljs-string">"title"</span>) {
            task-&gt;title = value;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field == <span class="hljs-string">"description"</span>) {
            task-&gt;description = value;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field == <span class="hljs-string">"assignee"</span>) {
            task-&gt;assignee = value;
        }

        task-&gt;updatedAt = system_clock::now();
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteTask</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; taskId)</span> </span>{
        <span class="hljs-keyword">auto</span> it = tasks.find(taskId);
        <span class="hljs-keyword">if</span> (it == tasks.end()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        tasks.erase(it);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// ===== SEARCH AND FILTERING =====</span>

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; <span class="hljs-title">searchTasks</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; query)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; taskIds = searchTrie.search(query);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; results;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; id : taskIds) {
            <span class="hljs-keyword">auto</span> task = getTask(id);
            <span class="hljs-keyword">if</span> (task) {
                results.push_back(task);
            }
        }

        <span class="hljs-keyword">return</span> results;
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; <span class="hljs-title">filterTasksByStatus</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; status)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; filtered;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : tasks) {
            <span class="hljs-keyword">if</span> (pair.second-&gt;status == status) {
                filtered.push_back(pair.second);
            }
        }
        <span class="hljs-keyword">return</span> filtered;
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; <span class="hljs-title">filterTasksByPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minPriority)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; filtered;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : tasks) {
            <span class="hljs-keyword">if</span> (pair.second-&gt;priority &gt;= minPriority) {
                filtered.push_back(pair.second);
            }
        }
        <span class="hljs-keyword">return</span> filtered;
    }

    <span class="hljs-comment">// ===== DEPENDENCY MANAGEMENT =====</span>

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">addDependency</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; fromTaskId, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; toTaskId)</span> </span>{
        <span class="hljs-keyword">auto</span> fromTask = getTask(fromTaskId);
        <span class="hljs-keyword">auto</span> toTask = getTask(toTaskId);

        <span class="hljs-keyword">if</span> (!fromTask || !toTask) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        dependencyGraph.addDependency(fromTaskId, toTaskId);

        <span class="hljs-comment">// Check for cycles</span>
        <span class="hljs-keyword">if</span> (dependencyGraph.hasCycle()) {
            dependencyGraph.removeDependency(fromTaskId, toTaskId);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        fromTask-&gt;addDependent(toTaskId);
        toTask-&gt;addDependency(fromTaskId);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">getTaskExecutionOrder</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> dependencyGraph.getTopologicalOrder();
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; <span class="hljs-title">getReadyTasks</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; readyTaskIds = dependencyGraph.getReadyTasks();
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; readyTasks;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; id : readyTaskIds) {
            <span class="hljs-keyword">auto</span> task = getTask(id);
            <span class="hljs-keyword">if</span> (task &amp;&amp; task-&gt;status == <span class="hljs-string">"pending"</span>) {
                readyTasks.push_back(task);
            }
        }

        <span class="hljs-keyword">return</span> readyTasks;
    }

    <span class="hljs-comment">// ===== SCHEDULING =====</span>

    <span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Task&gt; <span class="hljs-title">getNextTaskByPriority</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> readyTasks = getReadyTasks();
        <span class="hljs-keyword">if</span> (readyTasks.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;

        <span class="hljs-comment">// Sort by priority (descending) then by creation time (ascending)</span>
        sort(readyTasks.begin(), readyTasks.end(),
             [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&amp; b) {
                 <span class="hljs-keyword">if</span> (a-&gt;priority != b-&gt;priority) {
                     <span class="hljs-keyword">return</span> a-&gt;priority &gt; b-&gt;priority;
                 }
                 <span class="hljs-keyword">return</span> a-&gt;createdAt &lt; b-&gt;createdAt;
             });

        <span class="hljs-keyword">return</span> readyTasks[<span class="hljs-number">0</span>];
    }

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ScheduleResult</span> {</span>
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&gt; schedule;
        <span class="hljs-keyword">int</span> totalTime;
        <span class="hljs-keyword">int</span> remainingTime;
    };

    <span class="hljs-function">ScheduleResult <span class="hljs-title">scheduleTasksGreedy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> availableHours)</span> </span>{
        <span class="hljs-keyword">auto</span> readyTasks = getReadyTasks();

        <span class="hljs-comment">// Sort by value-to-time ratio (priority / estimated time)</span>
        sort(readyTasks.begin(), readyTasks.end(),
             [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Task&gt;&amp; b) {
                 <span class="hljs-keyword">double</span> ratioA = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(a-&gt;priority) / a-&gt;estimatedTime;
                 <span class="hljs-keyword">double</span> ratioB = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(b-&gt;priority) / b-&gt;estimatedTime;
                 <span class="hljs-keyword">return</span> ratioA &gt; ratioB;
             });

        ScheduleResult result;
        result.totalTime = <span class="hljs-number">0</span>;
        result.remainingTime = availableHours;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> task : readyTasks) {
            <span class="hljs-keyword">if</span> (task-&gt;estimatedTime &lt;= result.remainingTime) {
                result.schedule.push_back(task);
                result.totalTime += task-&gt;estimatedTime;
                result.remainingTime -= task-&gt;estimatedTime;
            }
        }

        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-comment">// ===== STATISTICS =====</span>

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TaskStatistics</span> {</span>
        <span class="hljs-keyword">int</span> total;
        <span class="hljs-keyword">int</span> pending;
        <span class="hljs-keyword">int</span> inProgress;
        <span class="hljs-keyword">int</span> completed;
        <span class="hljs-keyword">int</span> cancelled;
        <span class="hljs-keyword">double</span> averagePriority;
        <span class="hljs-keyword">int</span> totalEstimatedTime;
        <span class="hljs-keyword">int</span> totalActualTime;
        <span class="hljs-keyword">double</span> efficiency;
    };

    <span class="hljs-function">TaskStatistics <span class="hljs-title">getTaskStatistics</span><span class="hljs-params">()</span> </span>{
        TaskStatistics stats = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>};
        <span class="hljs-keyword">int</span> prioritySum = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : tasks) {
            <span class="hljs-keyword">auto</span> task = pair.second;
            stats.total++;

            <span class="hljs-keyword">if</span> (task-&gt;status == <span class="hljs-string">"pending"</span>) stats.pending++;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task-&gt;status == <span class="hljs-string">"in-progress"</span>) stats.inProgress++;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task-&gt;status == <span class="hljs-string">"completed"</span>) stats.completed++;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task-&gt;status == <span class="hljs-string">"cancelled"</span>) stats.cancelled++;

            prioritySum += task-&gt;priority;
            stats.totalEstimatedTime += task-&gt;estimatedTime;
            stats.totalActualTime += task-&gt;actualTime;
        }

        <span class="hljs-keyword">if</span> (stats.total &gt; <span class="hljs-number">0</span>) {
            stats.averagePriority = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(prioritySum) / stats.total;
        }

        <span class="hljs-keyword">if</span> (stats.totalActualTime &gt; <span class="hljs-number">0</span>) {
            stats.efficiency = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(stats.totalEstimatedTime) / stats.totalActualTime;
        }

        <span class="hljs-keyword">return</span> stats;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStatistics</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> stats = getTaskStatistics();
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Task Statistics ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total tasks: "</span> &lt;&lt; stats.total &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Pending: "</span> &lt;&lt; stats.pending &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"In Progress: "</span> &lt;&lt; stats.inProgress &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Completed: "</span> &lt;&lt; stats.completed &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cancelled: "</span> &lt;&lt; stats.cancelled &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Average Priority: "</span> &lt;&lt; stats.averagePriority &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total Estimated Time: "</span> &lt;&lt; stats.totalEstimatedTime &lt;&lt; <span class="hljs-string">" hours"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total Actual Time: "</span> &lt;&lt; stats.totalActualTime &lt;&lt; <span class="hljs-string">" hours"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Efficiency: "</span> &lt;&lt; stats.efficiency &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};

<span class="hljs-comment">// ===== EXAMPLE USAGE =====</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=== Task Management System Demo ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    TaskManagementSystem tms;

    <span class="hljs-comment">// Create sample tasks</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Creating Tasks ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">auto</span> task1 = tms.createTask(<span class="hljs-string">"Design Database Schema"</span>, <span class="hljs-string">"Create ERD and table structures"</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>);
    <span class="hljs-keyword">auto</span> task2 = tms.createTask(<span class="hljs-string">"Implement User Authentication"</span>, <span class="hljs-string">"Build login/logout functionality"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">12</span>);
    <span class="hljs-keyword">auto</span> task3 = tms.createTask(<span class="hljs-string">"Create API Endpoints"</span>, <span class="hljs-string">"Build REST API for user management"</span>, <span class="hljs-number">4</span>, <span class="hljs-number">16</span>);
    <span class="hljs-keyword">auto</span> task4 = tms.createTask(<span class="hljs-string">"Design UI Mockups"</span>, <span class="hljs-string">"Create wireframes and mockups"</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>);
    <span class="hljs-keyword">auto</span> task5 = tms.createTask(<span class="hljs-string">"Write Unit Tests"</span>, <span class="hljs-string">"Create comprehensive test suite"</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>);

    task1-&gt;addTag(<span class="hljs-string">"database"</span>);
    task1-&gt;addTag(<span class="hljs-string">"design"</span>);
    task2-&gt;addTag(<span class="hljs-string">"backend"</span>);
    task2-&gt;addTag(<span class="hljs-string">"security"</span>);
    task3-&gt;addTag(<span class="hljs-string">"backend"</span>);
    task3-&gt;addTag(<span class="hljs-string">"api"</span>);
    task4-&gt;addTag(<span class="hljs-string">"frontend"</span>);
    task4-&gt;addTag(<span class="hljs-string">"design"</span>);
    task5-&gt;addTag(<span class="hljs-string">"testing"</span>);
    task5-&gt;addTag(<span class="hljs-string">"quality"</span>);

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Created 5 tasks successfully"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Add dependencies</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Adding Dependencies ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">if</span> (tms.addDependency(task1-&gt;id, task2-&gt;id)) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Added dependency: Auth depends on DB"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">if</span> (tms.addDependency(task1-&gt;id, task3-&gt;id)) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Added dependency: API depends on DB"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">if</span> (tms.addDependency(task2-&gt;id, task3-&gt;id)) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Added dependency: API depends on Auth"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">if</span> (tms.addDependency(task4-&gt;id, task5-&gt;id)) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Added dependency: Tests depend on UI"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Get execution order</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Task Execution Order ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">auto</span> executionOrder = tms.getTaskExecutionOrder();
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Optimal execution order: "</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; taskId : executionOrder) {
            <span class="hljs-keyword">auto</span> task = tms.getTask(taskId);
            <span class="hljs-keyword">if</span> (task) {
                <span class="hljs-built_in">cout</span> &lt;&lt; task-&gt;title &lt;&lt; <span class="hljs-string">" -&gt; "</span>;
            }
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"END"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> runtime_error&amp; e) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Error: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Get ready tasks</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Ready Tasks ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">auto</span> readyTasks = tms.getReadyTasks();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Tasks ready to start: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> task : readyTasks) {
        <span class="hljs-built_in">cout</span> &lt;&lt; task-&gt;title &lt;&lt; <span class="hljs-string">", "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Search functionality</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Search Functionality ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">auto</span> searchResults = tms.searchTasks(<span class="hljs-string">"design"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Search results for 'design': "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> task : searchResults) {
        <span class="hljs-built_in">cout</span> &lt;&lt; task-&gt;title &lt;&lt; <span class="hljs-string">", "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Filter tasks</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Filter Tasks ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">auto</span> highPriorityTasks = tms.filterTasksByPriority(<span class="hljs-number">4</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"High priority tasks (&gt;=4): "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> task : highPriorityTasks) {
        <span class="hljs-built_in">cout</span> &lt;&lt; task-&gt;title &lt;&lt; <span class="hljs-string">" (Priority: "</span> &lt;&lt; task-&gt;priority &lt;&lt; <span class="hljs-string">"), "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">auto</span> pendingTasks = tms.filterTasksByStatus(<span class="hljs-string">"pending"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Pending tasks: "</span> &lt;&lt; pendingTasks.size() &lt;&lt; <span class="hljs-string">" tasks"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Schedule tasks with greedy algorithm</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Greedy Scheduling ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">auto</span> schedule = tms.scheduleTasksGreedy(<span class="hljs-number">20</span>); <span class="hljs-comment">// 20 hours available</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Greedy schedule for 20 hours:"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Selected tasks: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> task : schedule.schedule) {
        <span class="hljs-built_in">cout</span> &lt;&lt; task-&gt;title &lt;&lt; <span class="hljs-string">" ("</span> &lt;&lt; task-&gt;estimatedTime &lt;&lt; <span class="hljs-string">"h), "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Total time used: "</span> &lt;&lt; schedule.totalTime &lt;&lt; <span class="hljs-string">" hours"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Remaining time: "</span> &lt;&lt; schedule.remainingTime &lt;&lt; <span class="hljs-string">" hours"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Get next task by priority</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Priority-based Next Task ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">auto</span> nextTask = tms.getNextTaskByPriority();
    <span class="hljs-keyword">if</span> (nextTask) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Next task to work on: "</span> &lt;&lt; nextTask-&gt;title &lt;&lt; <span class="hljs-built_in">endl</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"No tasks available"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Update task status</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Update Task Status ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">if</span> (tms.updateTask(task1-&gt;id, <span class="hljs-string">"status"</span>, <span class="hljs-string">"completed"</span>)) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Updated task1 status to completed"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// Check ready tasks after completion</span>
    <span class="hljs-keyword">auto</span> newReadyTasks = tms.getReadyTasks();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"New ready tasks after task1 completion: "</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> task : newReadyTasks) {
        <span class="hljs-built_in">cout</span> &lt;&lt; task-&gt;title &lt;&lt; <span class="hljs-string">", "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// Get statistics</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Task Statistics ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    tms.printStatistics();

    <span class="hljs-comment">// Performance testing</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Performance Testing ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">auto</span> start = high_resolution_clock::now();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
        tms.createTask(<span class="hljs-string">"Task "</span> + to_string(i), <span class="hljs-string">"Description for task "</span> + to_string(i),
                      (rand() % <span class="hljs-number">5</span>) + <span class="hljs-number">1</span>, (rand() % <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">auto</span> end = high_resolution_clock::now();
    <span class="hljs-keyword">auto</span> duration = duration_cast&lt;milliseconds&gt;(end - start);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Created 1000 tasks in: "</span> &lt;&lt; duration.count() &lt;&lt; <span class="hljs-string">" ms"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    start = high_resolution_clock::now();
    <span class="hljs-keyword">auto</span> largeSearchResults = tms.searchTasks(<span class="hljs-string">"task"</span>);
    end = high_resolution_clock::now();
    duration = duration_cast&lt;milliseconds&gt;(end - start);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Search in 1000+ tasks took: "</span> &lt;&lt; duration.count() &lt;&lt; <span class="hljs-string">" ms"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Search results count: "</span> &lt;&lt; largeSearchResults.size() &lt;&lt; <span class="hljs-built_in">endl</span>;

    start = high_resolution_clock::now();
    <span class="hljs-keyword">auto</span> filteredResults = tms.filterTasksByPriority(<span class="hljs-number">4</span>);
    end = high_resolution_clock::now();
    duration = duration_cast&lt;milliseconds&gt;(end - start);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Filter 1000+ tasks took: "</span> &lt;&lt; duration.count() &lt;&lt; <span class="hljs-string">" ms"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Filtered results count: "</span> &lt;&lt; filteredResults.size() &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n=== Task Management System Demo Complete ==="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="%F0%9F%8E%AF-project-challenges-and-extensions">🎯 Project Challenges and Extensions</h2>
<h3 id="phase-1-basic-implementation-beginner">Phase 1: Basic Implementation (Beginner)</h3>
<ol>
<li><strong>Task CRUD Operations</strong>: Implement basic create, read, update, delete</li>
<li><strong>Simple Search</strong>: Linear search through task titles</li>
<li><strong>Basic Priority Queue</strong>: Use built-in priority queue</li>
<li><strong>Simple Dependencies</strong>: Track dependencies without cycle detection</li>
</ol>
<h3 id="phase-2-intermediate-features-medium">Phase 2: Intermediate Features (Medium)</h3>
<ol>
<li><strong>Advanced Search</strong>: Implement Trie-based search with autocomplete</li>
<li><strong>Dependency Management</strong>: Add cycle detection and topological sorting</li>
<li><strong>Undo/Redo System</strong>: Implement command pattern with stacks</li>
<li><strong>Performance Optimization</strong>: Add hash tables and efficient data structures</li>
</ol>
<h3 id="phase-3-advanced-features-advanced">Phase 3: Advanced Features (Advanced)</h3>
<ol>
<li><strong>Dynamic Programming</strong>: Optimize task scheduling with DP</li>
<li><strong>Graph Algorithms</strong>: Implement shortest path for task dependencies</li>
<li><strong>Machine Learning</strong>: Add task time estimation based on historical data</li>
<li><strong>Distributed System</strong>: Scale to multiple users with conflict resolution</li>
</ol>
<h3 id="bonus-challenges">Bonus Challenges:</h3>
<ol>
<li><strong>Real-time Collaboration</strong>: Multiple users editing simultaneously</li>
<li><strong>Mobile App</strong>: Create mobile interface with offline sync</li>
<li><strong>AI Assistant</strong>: Natural language task creation and scheduling</li>
<li><strong>Analytics Dashboard</strong>: Visual insights and productivity metrics</li>
</ol>
<hr>
<h2 id="%F0%9F%93%8A-performance-analysis">📊 Performance Analysis</h2>
<h3 id="time-complexity-analysis">Time Complexity Analysis:</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Hash Table</th>
<th>Priority Queue</th>
<th>Trie Search</th>
<th>Dependency Graph</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>O(1) avg</td>
<td>O(log n)</td>
<td>O(m)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Search</td>
<td>O(1) avg</td>
<td>O(n)</td>
<td>O(m + k)</td>
<td>O(V + E)</td>
</tr>
<tr>
<td>Delete</td>
<td>O(1) avg</td>
<td>O(log n)</td>
<td>O(m)</td>
<td>O(V + E)</td>
</tr>
<tr>
<td>Update</td>
<td>O(1) avg</td>
<td>O(log n)</td>
<td>O(m)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p><em>Where n = number of tasks, m = length of search term, k = number of results, V = vertices, E = edges</em></p>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li><strong>Hash Table</strong>: O(n) for task storage</li>
<li><strong>Trie</strong>: O(ALPHABET*SIZE * N _ M) where N is number of words, M is average word length</li>
<li><strong>Dependency Graph</strong>: O(V + E) for adjacency list representation</li>
<li><strong>Priority Queue</strong>: O(n) for heap storage</li>
<li><strong>Undo Stack</strong>: O(k) where k is maximum undo operations</li>
</ul>
<h3 id="optimization-techniques-used">Optimization Techniques Used:</h3>
<ol>
<li><strong>Hash Table Resizing</strong>: Dynamic resizing to maintain load factor</li>
<li><strong>Trie Compression</strong>: Store task IDs at each node for efficient retrieval</li>
<li><strong>Lazy Evaluation</strong>: Compute topological order only when needed</li>
<li><strong>Memoization</strong>: Cache frequently accessed computations</li>
<li><strong>Batch Operations</strong>: Group multiple operations for better performance</li>
</ol>
<hr>
<h2 id="%F0%9F%A7%AA-testing-strategy">🧪 Testing Strategy</h2>
<h3 id="unit-tests">Unit Tests:</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// Example test cases</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testTaskCreation</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> tms = <span class="hljs-keyword">new</span> TaskManagementSystem();
  <span class="hljs-keyword">const</span> task = tms.createTask(<span class="hljs-string">"Test Task"</span>, <span class="hljs-string">"Test Description"</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);

  assert(task.title === <span class="hljs-string">"Test Task"</span>);
  assert(task.priority === <span class="hljs-number">3</span>);
  assert(task.estimatedTime === <span class="hljs-number">5</span>);
  assert(task.status === <span class="hljs-string">"pending"</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"✓ Task creation test passed"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testDependencyManagement</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> tms = <span class="hljs-keyword">new</span> TaskManagementSystem();
  <span class="hljs-keyword">const</span> task1 = tms.createTask(<span class="hljs-string">"Task 1"</span>, <span class="hljs-string">"First task"</span>, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> task2 = tms.createTask(<span class="hljs-string">"Task 2"</span>, <span class="hljs-string">"Second task"</span>, <span class="hljs-number">2</span>);

  tms.addDependency(task1.id, task2.id);

  <span class="hljs-keyword">const</span> readyTasks = tms.getReadyTasks();
  assert(readyTasks.length === <span class="hljs-number">1</span>);
  assert(readyTasks[<span class="hljs-number">0</span>].id === task1.id);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"✓ Dependency management test passed"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testSearchFunctionality</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> tms = <span class="hljs-keyword">new</span> TaskManagementSystem();
  tms.createTask(<span class="hljs-string">"Design Database"</span>, <span class="hljs-string">"Create schema"</span>, <span class="hljs-number">4</span>);
  tms.createTask(<span class="hljs-string">"Implement API"</span>, <span class="hljs-string">"Build endpoints"</span>, <span class="hljs-number">3</span>);

  <span class="hljs-keyword">const</span> results = tms.searchTasks(<span class="hljs-string">"design"</span>);
  assert(results.length === <span class="hljs-number">1</span>);
  assert(results[<span class="hljs-number">0</span>].title.includes(<span class="hljs-string">"Design"</span>));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"✓ Search functionality test passed"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testGreedyScheduling</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> tms = <span class="hljs-keyword">new</span> TaskManagementSystem();
  tms.createTask(<span class="hljs-string">"High Priority Short"</span>, <span class="hljs-string">"Quick task"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>);
  tms.createTask(<span class="hljs-string">"Low Priority Long"</span>, <span class="hljs-string">"Long task"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>);

  <span class="hljs-keyword">const</span> schedule = tms.scheduleTasksGreedy(<span class="hljs-number">5</span>);
  assert(schedule.schedule.length === <span class="hljs-number">1</span>);
  assert(schedule.schedule[<span class="hljs-number">0</span>].priority === <span class="hljs-number">5</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"✓ Greedy scheduling test passed"</span>);
}

<span class="hljs-comment">// Run all tests</span>
testTaskCreation();
testDependencyManagement();
testSearchFunctionality();
testGreedyScheduling();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"\n🎉 All tests passed!"</span>);
</div></code></pre>
<h3 id="integration-tests">Integration Tests:</h3>
<ol>
<li><strong>End-to-End Workflow</strong>: Create → Add Dependencies → Schedule → Complete</li>
<li><strong>Performance Tests</strong>: Large dataset operations (1000+ tasks)</li>
<li><strong>Stress Tests</strong>: Concurrent operations and edge cases</li>
<li><strong>Memory Tests</strong>: Check for memory leaks in long-running operations</li>
</ol>
<h3 id="edge-cases-to-test">Edge Cases to Test:</h3>
<ol>
<li><strong>Circular Dependencies</strong>: Ensure proper cycle detection</li>
<li><strong>Empty Datasets</strong>: Handle operations on empty task lists</li>
<li><strong>Invalid Inputs</strong>: Graceful handling of malformed data</li>
<li><strong>Boundary Conditions</strong>: Maximum task limits and constraints</li>
</ol>
<hr>
<h2 id="%F0%9F%8E%93-learning-outcomes">🎓 Learning Outcomes</h2>
<p>After completing this mini-project, you will have:</p>
<h3 id="data-structures-mastery"><strong>Data Structures Mastery</strong>:</h3>
<ul>
<li>✅ <strong>Hash Tables</strong>: Fast lookups and storage</li>
<li>✅ <strong>Linked Lists</strong>: Dynamic data management</li>
<li>✅ <strong>Stacks</strong>: Undo/Redo functionality</li>
<li>✅ <strong>Queues</strong>: Task processing pipelines</li>
<li>✅ <strong>Heaps</strong>: Priority-based scheduling</li>
<li>✅ <strong>Trees</strong>: Hierarchical organization</li>
<li>✅ <strong>Graphs</strong>: Dependency relationships</li>
<li>✅ <strong>Tries</strong>: Efficient text searching</li>
</ul>
<h3 id="algorithm-proficiency"><strong>Algorithm Proficiency</strong>:</h3>
<ul>
<li>✅ <strong>Sorting</strong>: Task prioritization and ordering</li>
<li>✅ <strong>Searching</strong>: Binary search and text search</li>
<li>✅ <strong>Graph Traversal</strong>: DFS/BFS for dependencies</li>
<li>✅ <strong>Topological Sort</strong>: Task execution ordering</li>
<li>✅ <strong>Dynamic Programming</strong>: Optimal scheduling</li>
<li>✅ <strong>Greedy Algorithms</strong>: Resource allocation</li>
<li>✅ <strong>Backtracking</strong>: Constraint satisfaction</li>
</ul>
<h3 id="system-design-skills"><strong>System Design Skills</strong>:</h3>
<ul>
<li>✅ <strong>Modular Architecture</strong>: Separation of concerns</li>
<li>✅ <strong>Performance Optimization</strong>: Time/space complexity</li>
<li>✅ <strong>Error Handling</strong>: Robust error management</li>
<li>✅ <strong>Testing Strategy</strong>: Comprehensive test coverage</li>
<li>✅ <strong>Scalability</strong>: Design for growth</li>
</ul>
<h3 id="real-world-applications"><strong>Real-World Applications</strong>:</h3>
<ul>
<li>✅ <strong>Project Management</strong>: Task scheduling and tracking</li>
<li>✅ <strong>Resource Optimization</strong>: Efficient allocation algorithms</li>
<li>✅ <strong>User Experience</strong>: Search and filtering capabilities</li>
<li>✅ <strong>Data Analytics</strong>: Performance insights and reporting</li>
</ul>
<hr>
<h2 id="%F0%9F%9A%80-next-steps-and-career-applications">🚀 Next Steps and Career Applications</h2>
<h3 id="portfolio-enhancement"><strong>Portfolio Enhancement</strong>:</h3>
<ol>
<li><strong>GitHub Repository</strong>: Create a well-documented repo</li>
<li><strong>Live Demo</strong>: Deploy a web version</li>
<li><strong>Technical Blog</strong>: Write about your implementation</li>
<li><strong>Video Walkthrough</strong>: Explain your design decisions</li>
</ol>
<h3 id="interview-preparation"><strong>Interview Preparation</strong>:</h3>
<ol>
<li><strong>System Design</strong>: Use this as a system design example</li>
<li><strong>Coding Challenges</strong>: Extract individual algorithms for practice</li>
<li><strong>Complexity Analysis</strong>: Discuss optimization decisions</li>
<li><strong>Trade-offs</strong>: Explain design choices and alternatives</li>
</ol>
<h3 id="industry-applications"><strong>Industry Applications</strong>:</h3>
<ul>
<li><strong>Project Management Tools</strong>: Jira, Asana, Trello</li>
<li><strong>Development Workflows</strong>: CI/CD pipelines, build systems</li>
<li><strong>Resource Planning</strong>: Manufacturing, logistics, scheduling</li>
<li><strong>Game Development</strong>: Quest systems, skill trees</li>
<li><strong>AI/ML</strong>: Task scheduling in distributed training</li>
</ul>
<h3 id="advanced-extensions"><strong>Advanced Extensions</strong>:</h3>
<ol>
<li><strong>Microservices</strong>: Split into independent services</li>
<li><strong>Event Sourcing</strong>: Track all state changes</li>
<li><strong>CQRS</strong>: Separate read/write models</li>
<li><strong>Real-time Updates</strong>: WebSocket integration</li>
<li><strong>Machine Learning</strong>: Predictive analytics</li>
</ol>
<hr>
<h2 id="%F0%9F%93%9A-additional-resources">📚 Additional Resources</h2>
<h3 id="books"><strong>Books</strong>:</h3>
<ul>
<li>&quot;Introduction to Algorithms&quot; by Cormen, Leiserson, Rivest, Stein</li>
<li>&quot;System Design Interview&quot; by Alex Xu</li>
<li>&quot;Designing Data-Intensive Applications&quot; by Martin Kleppmann</li>
</ul>
<h3 id="online-courses"><strong>Online Courses</strong>:</h3>
<ul>
<li>Coursera: &quot;Algorithms Specialization&quot; by Stanford</li>
<li>edX: &quot;Data Structures and Algorithms&quot; by MIT</li>
<li>Udemy: &quot;Master the Coding Interview: Data Structures + Algorithms&quot;</li>
</ul>
<h3 id="practice-platforms"><strong>Practice Platforms</strong>:</h3>
<ul>
<li>LeetCode: Algorithm practice problems</li>
<li>HackerRank: Data structures challenges</li>
<li>CodeSignal: System design questions</li>
<li>Pramp: Mock interviews</li>
</ul>
<h3 id="documentation"><strong>Documentation</strong>:</h3>
<ul>
<li>MDN Web Docs: JavaScript reference</li>
<li>cppreference.com: C++ standard library</li>
<li>GeeksforGeeks: Algorithm explanations</li>
<li>Stack Overflow: Community Q&amp;A</li>
</ul>
<hr>
<h2 id="%F0%9F%8E%89-conclusion">🎉 Conclusion</h2>
<p>Congratulations! You've completed a comprehensive mini-project that integrates multiple data structures and algorithms concepts. This Task Management System demonstrates practical applications of:</p>
<ul>
<li><strong>15+ Data Structures</strong>: From basic arrays to complex graphs</li>
<li><strong>10+ Algorithms</strong>: Sorting, searching, optimization, and more</li>
<li><strong>Real-world Problem Solving</strong>: Practical software development</li>
<li><strong>Performance Optimization</strong>: Efficient algorithm selection</li>
<li><strong>System Design</strong>: Scalable architecture patterns</li>
</ul>
<p>This project serves as an excellent portfolio piece and interview preparation tool. You've not only learned individual concepts but also how to combine them effectively to solve complex problems.</p>
<p><strong>Keep building, keep learning, and keep coding!</strong> 🚀</p>
<hr>
<p><em>&quot;The best way to learn data structures and algorithms is to implement them in real projects. This mini-project gives you that hands-on experience while building something genuinely useful.&quot;</em></p>
<p><strong>Happy Coding!</strong> 💻✨</p>

</body>
</html>
